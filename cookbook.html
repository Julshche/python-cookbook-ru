<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAzUABAAAAAAFNgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABwAAAAcZMzaOEdERUYAAAGIAAAAHQAAACAAOQAET1MvMgAAAagAAAA+AAAAYHqhde9jbWFwAAAB6AAAAFIAAAFa4azkLWN2dCAAAAI8AAAAKAAAACgFgwioZnBnbQAAAmQAAAGxAAACZVO0L6dnYXNwAAAEGAAAAAgAAAAIAAAAEGdseWYAAAQgAAAFDgAACMz7eroHaGVhZAAACTAAAAAwAAAANgWEOEloaGVhAAAJYAAAAB0AAAAkDGEGa2htdHgAAAmAAAAAEwAAADBEgAAQbG9jYQAACZQAAAAaAAAAGgsICJBtYXhwAAAJsAAAACAAAAAgASgBD25hbWUAAAnQAAACZwAABOD4no+3cG9zdAAADDgAAABsAAAAmF+yXM9wcmVwAAAMpAAAAC4AAAAusPIrFAAAAAEAAAAAyYlvMQAAAADLVHQgAAAAAM/u9uZ4nGNgZGBg4ANiCQYQYGJgBEJuIGYB8xgABMMAPgAAAHicY2Bm42OcwMDKwMLSw2LMwMDQBqGZihmiwHycoKCyqJjB4YPDh4NsDP+BfNb3DIuAFCOSEgUGRgAKDgt4AAB4nGNgYGBmgGAZBkYGEAgB8hjBfBYGCyDNxcDBwMTA9MHhQ9SHrA8H//9nYACyQyFs/sP86/kX8HtB9UIBIxsDXICRCUgwMaACRoZhDwA3fxKSAAAAAAHyAHABJQB/AIEAdAFGAOsBIwC/ALgAxACGAGYAugBNACcA/wCIeJxdUbtOW0EQ3Q0PA4HE2CA52hSzmZDGe6EFCcTVjWJkO4XlCGk3cpGLcQEfQIFEDdqvGaChpEibBiEXSHxCPiESM2uIojQ7O7NzzpkzS8qRqnfpa89T5ySQwt0GzTb9Tki1swD3pOvrjYy0gwdabGb0ynX7/gsGm9GUO2oA5T1vKQ8ZTTuBWrSn/tH8Cob7/B/zOxi0NNP01DoJ6SEE5ptxS4PvGc26yw/6gtXhYjAwpJim4i4/plL+tzTnasuwtZHRvIMzEfnJNEBTa20Emv7UIdXzcRRLkMumsTaYmLL+JBPBhcl0VVO1zPjawV2ys+hggyrNgQfYw1Z5DB4ODyYU0rckyiwNEfZiq8QIEZMcCjnl3Mn+pED5SBLGvElKO+OGtQbGkdfAoDZPs/88m01tbx3C+FkcwXe/GUs6+MiG2hgRYjtiKYAJREJGVfmGGs+9LAbkUvvPQJSA5fGPf50ItO7YRDyXtXUOMVYIen7b3PLLirtWuc6LQndvqmqo0inN+17OvscDnh4Lw0FjwZvP+/5Kgfo8LK40aA4EQ3o3ev+iteqIq7wXPrIn07+xWgAAAAABAAH//wAPeJyFlctvG1UUh+/12DPN1B7P3JnYjj2Ox4/MuDHxJH5N3UdaEUQLqBIkfQQioJWQ6AMEQkIqsPGCPwA1otuWSmTBhjtps2ADWbJg3EpIXbGouqSbCraJw7kzNo2dRN1cnXN1ZvT7zuuiMEI7ncizyA0URofRBJpCdbQuIFShYY+GZRrxMDVtih5TwQPHtXDFFSIKoWIbuREBjLH27Ny4MsbVx+uOJThavebgVrNRLAiYx06rXsvhxLgWx9xpfHdrs/ekc2Pl2cpPCVEITQpwbj8VQhfXSq2m+Wxqaq2D73Kne5e3NjHqQNj3CRYlJlgUl/jRNP+2Gs2pNYRQiOnmUaQDqm30KqKiTTWPWjboxnTWpvgxjXo0KrtZXAHt7hwIz0YVcj88JnKlJKi3NPAwLyDwZudSmJSMMJFDYaOkaol6XtESx3Gt1VTytdZJ3DCLeaVhVnCBH1fycHTxFXwPX+l2e3d6H/TufGGmMTLTnbSJUdo00zuBswMO/nl3YLeL/wnu9/limCuD3vC54h5NBVz6Li414AI8Vx3iiosKcQXUbrvhFFiYb++HN4DaF4XzFW0fIN4XDWJ3a3XQoq9V8WiyRmdsatV9xUcHims1JloH0YUa090G3Tro3mC6c01f+YwCPquINr1PTaCP6rVTOOmf0GE2dBc7zWIhji3/5MchSuBHgDbU99RMWt3YUNMZMJmx92YP6NsHx/5/M1yvInpnkIOM3Z8fA3JQ2lW1RFC1KaBPDFXNAHYYvGy73aYZZZ3HifbeuiVZCpwA3oQBs0wGPYJbJfg60xrKEbKiNtTe1adwrpBRwlAuQ3q3VRaX0QmQ9a49BTSCuF1MLfQ6+tinOubRBZuWPNoMevGMT+V41KitO1is3D/tpMcq1JHZqDHGs8DoYGDkxJgKjHROeTCmhZvzPm9pod+ltKm4PN7Dyvvldlpsg8D+4AUJZ3F/JBstZz7cbFRxsaAGV6yX/dkcycWf8eS3QlQea+YLjdm3yrOnrhFpUyKVvFE4lpv4bO3Svx/6F/4xmiDu/RT5iI++lko18mY1oX+5UGKR6kmVjM/Zb76yfHtxy+h/SyQ0lLdpdKy/lWB6szatetQJ8nZ80A2Qt6ift6gJeavU3BO4gtxs/KCtNPVibCtYCWY3SIlSBPKXZALXiIR9oZeJ1AuMyxLpHIy/yO7vSiSE+kZvk0ihJ30HgHfzZtEMmvV58x6dtqns0XTAW7Vdm4HJ04OCp/crOO7rd9SGxQAE/mVA9xRN+kVSMRFF6S9JFGUtthkjBA5tFCWc2l4V43Ex9GmUP3SI37Jjmir9KqlaDJ4S4JB3vuM/jzyH1+8MuoZ+QGzfnvPoJb96cZlWjMcKLfgDwB7E634JTY+asjsPzS5CiVnEWY+KsrsIN5rn3mAPjqmQBxGjcGKB9f9ZxY3mYC2L85CJ2FXIxKKyHk+dg0FHbuEc7D5NzWUX32WxFcWNGRAbvwSx0RmIXVDuYySafluQBmzA/ssqJAMLnli+WIC90Gw4lm85wcp0qjArEDPJJV/sSx4P9ungTpgMw5gVC1XO4uULq0s3v1rqLi0vX/z65vlH50f8T/RHmSPTk5xxWBWOluMT6WiOy+tdvWxlV/XQb3o3c6Ssr+r6I708GsX9/nzp1tKFh0s3v7m4vAy/Hnb/KMOvc1wump6Il48K6mGDy02X9Yd65pa+nQIjk76lWxCkG8NBCP0HQS9IpAAAeJxjYGRgYGBhcCrq214Qz2/zlUGenQEEzr/77oug/zewFbB+AHI5GJhAogBwKQ0qeJxjYGRgYH3/P46BgZ0BBNgKGBgZUAEPAE/7At0AAAB4nGNngAB2IGYjhBsYBAAIYADVAAAAAAAAAAAAAFwAyAEeAaACCgKmAx4DggRmAAAAAQAAAAwAagAEAAAAAAACAAEAAgAWAAABAAChAAAAAHiclZI7bxQxFIWPd/JkUYQChEhIyAVKgdBMskm1QkKrRETpQiLRUczueB/K7HhlOxttg8LvoKPgP9DxFxANDR0tHRWi4NjrPIBEgh1p/dm+vufcawNYFWsQmP6e4jSyQB2fI9cwj++RE9wTjyPP4LYoI89iWbyLPIe6+Bh5Hs9rryMv4GbtW+RF3EhuRa7jbrIbeQkPkjdUETOLnL0Kip4FVvAhco1RXyMnSPEz8gzWxE7kWTwUp5HnsCLeR57HW/El8gJWa58iL+JO7UfkOh4l9yMv4UnyEtvQGGECgwF66MNBooF1bGCL1ELB/TYU+ZBRlvsKQ44Se6jQ4a7hef+fh72Crv25kp+8lNWGmeKoOI5jJLb1aGIGvb6TjfWNLdkqdFvJw4l1amjlXtXRZqRN7lSRylZZyhBqpVFWmTEXgWfUrpi/hZOQXdOd4rKuXOtEWT3k5IArPRzTUU5tHKjecZkTpnVbNOnt6jzN8240GD4xtikvZW56043rPMg/dS+dlOceXoR+WPbJ55Dsekq1lJpnypsMUsYOdCW30o103Ytu/lvh+5RWFLfBjm9/N8hJntPhvx92rnoE/kyHdGasGy754kw36vsVf/lFeBi+0COu+cfgQr42G3CRpeLoZ53gmfe3X6rcKt5oVxnptHR9JS8ehVUd5wvvahN2uqxOOpMXapibI5k7Zwbt4xBSaTfoKBufhAnO/uqNcfK8OTs0OQ6l7JIqFjDhYj5WcjevCnI/1DDiI8j4ndWb/5YzDZWh79yomWXeXj7Nnw70/2TIeFPTrlSh89k1ObOSRVZWZfgF0r/zJQB4nG2JUQuCQBCEd07TTg36fb2IyBaLd3vWaUh/vmSJnvpgmG8YcmS8X3Shf3R7QA4OBUocUKHGER5NNbOOEvwc1txnuWkTRb/aPjimJ5vXabI+3VfOiyS15UWvyezM2xiGOPyuMohOH8O8JiO4Af+FsAGNAEuwCFBYsQEBjlmxRgYrWCGwEFlLsBRSWCGwgFkdsAYrXFhZsBQrAAA=) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>cookbook</title></head><body><article class="markdown-body"><!-- MarkdownTOC -->

<ul>
<li>
<ol>
<li>Структуры данных и алгоритмы</li>
<li>1.1. Распаковка последовательности в отдельные переменные</li>
<li>1.2. Распаковка элементов из последовательностей произвольной длины</li>
<li>1.3. Оставление N последних элементов</li>
<li>1.4. Поиск N максимальных и минимальных элементов</li>
<li>1.5. Имплементация очереди с приоритетом</li>
<li>1.6. Отображение ключей на множественные значения в словаре</li>
<li>1.7. Поддержание порядка в словарях</li>
<li>1.8. Вычисления в словарях</li>
<li>1.9. Поиск общих элементов в двух словарях</li>
<li>1.10. Удаление дубликатов из последовательности с сохранением порядка элементов</li>
<li>1.11. Присваивание имён срезам</li>
<li>1.12. Определение наиболее часто встречающихся элементов в последовательности</li>
<li>1.13. Сортировка списка словарей по общему ключу</li>
<li>1.14. Сортировка объектов, не поддерживающих сравнение</li>
<li>1.15. Группировка записей на основе полей</li>
<li>1.16. Фильтрование элементов последовательности</li>
<li>1.17. Извлечение подмножества из словаря</li>
<li>1.18. Отображение имен на последовательность элементов</li>
<li>1.19. Одновременное преобразование и сокращение данных</li>
<li>1.20. Объединение нескольких отображений в одно</li>
</ol>
</li>
<li>
<ol>
<li>Строки и текст</li>
<li>2.1. Разрезание строк, разделенных различными разделителями</li>
<li>2.2. Поиск текста в начале и в конце строки</li>
<li>2.3. Поиск строк с использованием масок оболочки (shell)</li>
<li>2.4. Поиск совпадений и поиск текстовых паттернов</li>
<li>2.5. Поиск и замена текста</li>
<li>2.6. Поиск и замена текста без учета регистра</li>
<li>2.7. Определение регулярных выражений для поиска кратчайшего совпадения</li>
<li>2.8. Написание регулярного выражения для многострочных шаблонов</li>
<li>2.9. Приведение текста в Unicode к стандартному представлению (нормализация)</li>
<li>2.10. Использование символов Unicode в регулярных выражениях</li>
<li>2.11. Убирание нежелательных символов из строк</li>
<li>2.12. Чистка строк</li>
<li>2.13. Выравнивание текстовых строк</li>
<li>2.14. Объединение и конкатенация строк</li>
<li>2.15. Интерполяция переменных в строках</li>
<li>Задача</li>
<li>2.16. Разбивка текста на фиксированное количество колонок</li>
<li>2.17. Работа с HTML- и XML-сущностями в тексте</li>
<li>2.18. Токенизация текста</li>
<li>2.19. Написание простого парсера на основе метода рекурсивного спуска</li>
<li>2.20. Выполнение текстовых операций над байтовыми строками</li>
</ol>
</li>
<li>
<ol>
<li>Числа, даты и время</li>
<li>3.1. Округление числовых значений</li>
<li>3.2. Выполнение точных десятичных вычислений</li>
<li>3.3. Форматирование чисел для вывода</li>
<li>3.4. Работа с бинарными, восьмеричными и шестнадцатеричными целыми числами</li>
<li>3.5. Упаковка и распаковка больших целых чисел из байтовых строк</li>
<li>3.6. Вычисления с комплексными числами</li>
<li>3.7. Работа с бесконечными значениями и NaN</li>
<li>3.8. Вычисления с дробями</li>
<li>3.9. Вычисления на больших массивах чисел</li>
<li>3.10. Вычисления с матрицами и линейная алгебра</li>
<li>3.11. Случайный выбор</li>
<li>3.12. Перевод дней в секунды и другие базовые методы конвертации времени</li>
<li>3.13. Определение даты последней пятницы</li>
<li>3.14. Поиск диапазона дат для текущего месяца</li>
<li>3.15. Конвертирование строк в даты и время</li>
<li>3.16. Манипулирование датами с учётом таймзон</li>
</ol>
</li>
<li>
<ol>
<li>Итераторы и генераторы</li>
<li>4.1. Ручное прохождение по итератору</li>
<li>4.2. Делегирование итерации</li>
<li>4.3. Создание новых итерационных паттернов с помощью генераторов</li>
<li>4.4. Реализация протокола итератора</li>
<li>4.5. Итерирование в обратном порядке</li>
<li>4.6. Определение генератора с дополнительным состоянием</li>
<li>4.7. Получение среза итератора</li>
<li>Задача</li>
<li>4.9. Итерирование по всем возможным комбинациям и перестановкам</li>
<li>4.10. Итерирование по парам «индекс-значение» последовательности</li>
<li>4.11. Одновременное итерирование по нескольким последовательностям</li>
<li>4.12. Интерирования по элементам, находящимся в отдельных контейнерах</li>
<li>4.13. Создание каналов для обработки данных</li>
<li>4.14. Превращение вложенной последовательности в плоскую</li>
</ol>
</li>
</ul>
<!-- /MarkdownTOC -->

<p><em>Прим. перев.: Комментарии в коде не переведены сознательно, поскольку комментарии в коде всегда должны быть написаны на английском языке.</em></p>
<h1 id="1"><a name="user-content-1" href="#1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1. Структуры данных и алгоритмы</h1>
<p>Python предоставляет широкий спектр встроенных структур данных, таких как списки, множества и словари. Использовать эти структуры по большей части просто. Однако часто возникают общие вопросы, касающиеся поиска, сортировки, изменения порядка элементов и фильтрования. Цель этой главы — обсудить обычные стуктуры данных и алгоритмы. Также будет дано введение в разнообразные структуры данных из модуля <em>collections</em>.</p>
<h2 id="11"><a name="user-content-11" href="#11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.1. Распаковка последовательности в отдельные переменные</h2>
<h3 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Проблема</h3>
<p>У вас есть кортеж из N элементов или последовательность, которую вы хотите распаковать в коллекцию из N переменных.</p>
<h3 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Любая последовательность (или итерируемый объект) могут быть распакованы в переменные с помощью простого присваивания. Единственное обязательное условие заключается в том, чтобы количество и структура переменных совпадали с последовательностью. Например:<br />
<pre><code class="python">&gt;&gt;&gt; p = (4, 5)
&gt;&gt;&gt; x, y = p
&gt;&gt;&gt; x
4
&gt;&gt;&gt; y
5
&gt;&gt;&gt;
</code></pre></p>
<pre><code class="python">&gt;&gt;&gt; data = ['ACME', 50, 91.1, (2012, 12, 21)]
&gt;&gt;&gt; name, shares, price, date = data
&gt;&gt;&gt; name
'ACME'
&gt;&gt;&gt; date
(2012, 12, 21)
</code></pre>

<pre><code class="python">&gt;&gt;&gt; name, shares, price, (year, mon, day) = data
&gt;&gt;&gt; name
'ACME'
&gt;&gt;&gt; year
2012
&gt;&gt;&gt; mon
12
&gt;&gt;&gt; day
21
&gt;&gt;&gt;
</code></pre>

<p>При несовпадении количества элементов вы получите ошибку. Например:<br />
<pre><code class="python">&gt;&gt;&gt; p = (4, 5)
&gt;&gt;&gt; x, y, z = p
Traceback (most recent call last):
   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: need more than 2 values to unpack
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Распаковка работает с любым итерируемым объектом, а не только с кортежами и списками. Это строки, файлы, итераторы и генераторы. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'Hello'
&gt;&gt;&gt; a, b, c, d, e = s
&gt;&gt;&gt; a
'H'
&gt;&gt;&gt; b
'e'
&gt;&gt;&gt; e
'o'
&gt;&gt;&gt;
</code></pre></p>
<p>При распаковке вы иногда можете захотеть отбраковать некоторые значения. Специального синтаксиса для этого в Python нет, но вы можете назначить «выбрасываемые» переменные. Например:<br />
<pre><code class="python">&gt;&gt;&gt; data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
&gt;&gt;&gt; _, shares, price, _ = data
&gt;&gt;&gt; shares
50
&gt;&gt;&gt; price
91.1
&gt;&gt;&gt;
</code></pre></p>
<p>Но убедитесь, что вы уже не использовали где-то эту переменную.</p>
<h2 id="12"><a name="user-content-12" href="#12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.2. Распаковка элементов из последовательностей произвольной длины</h2>
<h3 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Проблема</h3>
<p>Вам нужно распаковать N элементов из итерируемого объекта, но этот объект может содержать больше N элементов, что вызывает исключение &ldquo;too many values to unpack&rdquo; («слишком много значений для распаковки»).</p>
<h3 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для решения этой задачи могут быть использованы «выражения со звёздочкой». Предположим, например, что вы ведете учебный курс и решаете в конце семестра, что вы не будете принимать во внимание оценки за первое и последнее домашние задания, а по остальным оценкам посчитаете среднее значение. Если у вас было четыре задания, то можно просто распаковать все четыре. Но что делать, если их 24? Выражения со звёздочкой позволяют легко решить проблему:<br />
<pre><code class="python">def drop_first_last(grades):
    first, *middle, last = grades
    return avg(middle)
</code></pre></p>
<p>Рассмотрим еще один пример: предположим, что у вас есть записи о юзерах, которые состоят из имени и email, за которыми следует произвольное количество телефонных номеров. Вы можете распаковать записи так:<br />
<pre><code class="python">&gt;&gt;&gt; record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
&gt;&gt;&gt; name, email, *phone_numbers = user_record
&gt;&gt;&gt; name
'Dave'
&gt;&gt;&gt; email
'dave@example.com'
&gt;&gt;&gt; phone_numbers
['773-555-1212', '847-555-1212']
&gt;&gt;&gt;
</code></pre></p>
<p>Стоит отметить, что переменная phone_numbers всегда будет списком, несмотря на то, сколько телефонных номеров распаковано (даже если и ни одного). Любой код, который использует phone_numbers не должен учитывать возможность, что в этой будет не список, или производить дополнительные проверки.</p>
<p>Переменная со звёздочкой также может быть первой в списке. Например, у вас есть последовательность значений, представляющая продажи вашей компании за последние восемь кварталов. Если вы хотите посмотреть, как последний квартал соотносится со средним значением по первым семи, вы можете сделать так:<br />
<pre><code class="python">*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
</code></pre></p>
<p>Интерпретатор Python выдаст:<br />
<pre><code class="python">&gt;&gt;&gt; *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
&gt;&gt;&gt; trailing
[10, 8, 7, 1, 9, 5, 10]
&gt;&gt;&gt; current
3
</code></pre></p>
<h3 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Расширенная распаковка отлично подходит для распаковки итерируемых объектов неизвестной или произвольной длины. Часто эти объекты имеют некоторые известные элементы или паттерны (например, «всё, что после элемента 1, является телефонным номером»), и распаковка со звёздочкой позволяет программисту легко использовать эти паттерны — вместо того, чтобы исполнять акробатические трюки для извлечения нужных элементов из итерируемого объекта.</p>
<p>Стоит отметить, что синтаксис звёздочки может быть особенно полезен при итерировании по последовательности кортежей переменной длины. Например, возможна такая последовательность кортежей с тегами:<br />
<pre><code class="python">records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]

def do_foo(x, y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)
</code></pre></p>
<p>Распаковка со звёздочкой также может быть полезна в комбинации с операциями обработки строк, такими как разрезание. Например:<br />
<pre><code class="python">&gt;&gt;&gt; line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
&gt;&gt;&gt; uname, *fields, homedir, sh = line.split(':')
&gt;&gt;&gt; uname
'nobody'
&gt;&gt;&gt; homedir
'/var/empty'
&gt;&gt;&gt; sh
'/usr/bin/false'
&gt;&gt;&gt;
</code></pre></p>
<p>Иногда вам может быть нужно распаковать значения и выбросить их. Вы не можете просто определить голую * при распаковке, но вы можете использовать обычное для выбрасывания имя переменной, такое как _ или ign (ignored). Например:<br />
<pre><code class="python">&gt;&gt;&gt; record = ('ACME', 50, 123.45, (12, 18, 2012))
&gt;&gt;&gt; name, *_, (*_, year) = record
&gt;&gt;&gt; name
'ACME'
&gt;&gt;&gt; year
2012
&gt;&gt;&gt;
</code></pre></p>
<p>Есть некоторая схожесть между распаковкой со звёздочкой и обработкой списков в функциональных языках. Например, если у вас есть список, то вы можете легко разделить его на «хвост» и «голову»:<br />
<pre><code class="python">&gt;&gt;&gt; items = [1, 10, 7, 4, 5, 9]
&gt;&gt;&gt; head, *tail = items
&gt;&gt;&gt; head
1
&gt;&gt;&gt; tail
[10, 7, 4, 5, 9]
&gt;&gt;&gt;
</code></pre></p>
<p>Можно представить себе функцию, которая произведет такое разрезание с помощью хитрого рекурсивного алгоритма. Например:<br />
<pre><code class="python">&gt;&gt;&gt; def sum(items):
...   head, *tail = items
...   return head + sum(tail) if tail else head
...
&gt;&gt;&gt; sum(items)
36
&gt;&gt;&gt;
</code></pre></p>
<p>Однако вам следует знать, что рекурсия не относится к числу сильных сторон Python из-за внутреннего лимита на рекурсию. Поэтому последний пример на практике оказывается просто любопытным предметом для размышления.</p>
<h2 id="13-n"><a name="user-content-13-n" href="#13-n" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.3. Оставление N последних элементов</h2>
<h3 id="_7"><a name="user-content-_7" href="#_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите хранить ограниченную историю из нескольких последних элементов, полученных в ходе итерации или какого-то другого процесса обработки данных.</p>
<h3 id="_8"><a name="user-content-_8" href="#_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Хранение ограниченной истории — отличный повод применить <em>collections.deque</em>. Например, следующий отрывок кода производит простое сопоставление текста с последовательностью строк и при совпадении выдает совпадающие строки вместе с N предыдущими строками контекста:<br />
<pre><code class="python">from collections import deque
def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
    with open('somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
        print(line, end='')
        print('-'*20)
</code></pre></p>
<h3 id="_9"><a name="user-content-_9" href="#_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>При написании программы для поиска элементов обычно используют функцию-генератор, содержащую <em>yield</em> (как и показано в вышеприведенном примере). Это отделяет процесс поиска от кода, который использует результаты. Если вы новичок в обращении с генераторами, см. <strong>Рецепт 4.3.</strong></p>
<p>Использование <em>deque(maxlen=N)</em> создает очередь фиксированной длины. Когда новые элементы добавлены и очередь заполнена, самый старый элемент автоматически удаляется. Пример:<br />
<pre><code class="python">&gt;&gt;&gt; q = deque(maxlen=3)
&gt;&gt;&gt; q.append(1)
&gt;&gt;&gt; q.append(2)
&gt;&gt;&gt; q.append(3)
&gt;&gt;&gt; q
deque([1, 2, 3], maxlen=3)
&gt;&gt;&gt; q.append(4)
&gt;&gt;&gt; q
deque([2, 3, 4], maxlen=3)
&gt;&gt;&gt; q.append(5)
&gt;&gt;&gt; q
deque([3, 4, 5], maxlen=3)
</code></pre></p>
<p>Хотя вы можете вручную производить такие операции над списком (то есть добавление в конец, удаление и т.п.), решение с использованием очереди элегантнее и работает намного быстрее.</p>
<p>Обобщим: дека может быть использована в любом случае, когда вам нужна простая очередь. Если вы не задатите максимальную длину, вы получите бесконечную очередь, которая позволит вам добавлять и удалять элементы с обоих концов. Например:<br />
<pre><code class="python">&gt;&gt;&gt; q = deque()
&gt;&gt;&gt; q.append(1)
&gt;&gt;&gt; q.append(2)
&gt;&gt;&gt; q.append(3)
&gt;&gt;&gt; q
deque([1, 2, 3])
&gt;&gt;&gt; q.appendleft(4)
&gt;&gt;&gt; q
deque([4, 1, 2, 3])
&gt;&gt;&gt; q.pop()
3
&gt;&gt;&gt; q
deque([4, 1, 2])
&gt;&gt;&gt; q.popleft()
4
</code></pre></p>
<p>Добавление или удаление элементов с любого из концов очереди имеет сложность O(1). А вот добавление или удаление элемента в начало списка имеет сложность O(N).</p>
<h2 id="14-n"><a name="user-content-14-n" href="#14-n" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.4. Поиск N максимальных и минимальных элементов</h2>
<h3 id="_10"><a name="user-content-_10" href="#_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите создать список N максимальных или минимальных элементов коллекции.</p>
<h3 id="_11"><a name="user-content-_11" href="#_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>У модуля <em>heapq</em> есть две функции, nlargest() и nsmallest(), которые делают именно то, что вам нужно. Например:<br />
<pre><code class="python">import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
</code></pre></p>
<p>Обе функции таке принимают параметр key, который позволяет использовать их с более сложными структурами данных. Например:<br />
<pre><code class="python">portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre></p>
<h3 id="_12"><a name="user-content-_12" href="#_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Если вы ищете N наименьших или N наибольших элементов, причем N невелико по сравнению с общим размером коллекции, эти функции покажут великолепную производительность. «Под капотом» они начинают работу с конвертирования данных в список, где данные упорядочены как куча. Например:<br />
<pre><code class="python">&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
&gt;&gt;&gt; import heapq
&gt;&gt;&gt; heap = list(nums)
&gt;&gt;&gt; heapq.heapify(heap)
&gt;&gt;&gt; heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
&gt;&gt;&gt;
</code></pre></p>
<p>Самое важная возможность кучи состоит в том, что heap[0] всегда будет наименьшим элементом. Кроме того, последующие элементы могут быть легко найдены с помощью метода heapq.heappop(), который удаляет первый элемент и заменяет его следующим наименьшим элементом (это требует O(log N) операций, где N — размер кучи). Например, чтобы найти три наименьших элемента, вы могли бы сделать это:<br />
<pre><code class="python">&gt;&gt;&gt; heapq.heappop(heap)
-4
&gt;&gt;&gt; heapq.heappop(heap)
1
&gt;&gt;&gt; heapq.heappop(heap)
2
</code></pre></p>
<p>Функции nlargest() и nsmallest() лучше всего подходят, если вы пытаетесь найти относительно небольшое количество элементов. Если вы просто хотите найти один наибольший или наименьший элемент (N = 1), функции min() и max() будут быстрее. Похожим образом, если N сопоставимо с размером самой коллекции, обычно будет быстрее отсортировать их и взять срез (то есть сделать sorted(items)[:N] или orted(items)[-N:]). Стоит отметить, что реальная имплементация nlargest() и nsmallest() работает гибко и выполняет некоторые из этих оптимизаций самостоятельно (например, использует сортировку, если размер N близок к размеру входящих данных).</p>
<p>Хотя использовать этот рецепт необязательно, имплементация кучи интересна и заслуживает изучения. Информацию об этом можно найти в любой приличной книге по алгоритмам и структурам данных. В документации модуля <em>heapq</em> также обсуждаются детали внутренней имплементации.</p>
<h2 id="15"><a name="user-content-15" href="#15" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.5. Имплементация очереди с приоритетом</h2>
<h3 id="_13"><a name="user-content-_13" href="#_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите реализовать очередь, которая сортирует элементы по заданному приоритету и всегда возвращает элемент с наивысшим приоритетом при каждой операции получения (удаления) элемента.</p>
<h3 id="_14"><a name="user-content-_14" href="#_14" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Приведенный ниже класс использует модуль <em>heapq</em> для реализации простой очереди с приоритетом.</p>
<pre><code class="python">import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>

<p>А вот пример использования:<br />
<pre><code class="python">&gt;&gt;&gt; class Item:
...   def __init__(self, name):
...   self.name = name
...   def __repr__(self):
...   return 'Item({!r})'.format(self.name)
...
&gt;&gt;&gt; q = PriorityQueue()
&gt;&gt;&gt; q.push(Item('foo'), 1)
&gt;&gt;&gt; q.push(Item('bar'), 5)
&gt;&gt;&gt; q.push(Item('spam'), 4)
&gt;&gt;&gt; q.push(Item('grok'), 1)
&gt;&gt;&gt; q.pop()
Item('bar')
&gt;&gt;&gt; q.pop()
Item('spam')
&gt;&gt;&gt; q.pop()
Item('foo')
&gt;&gt;&gt; q.pop()
Item('grok')
&gt;&gt;&gt;
</code></pre></p>
<p>Посмотрите, как первая операция pop() возвращает элемент с наивысшим приоритетом. Также пронаблюдайте, как два элемента с одинаковым приоритетом (foo и grok) были возвращены в том же порядке, в каком они были помещены в очередь.</p>
<h3 id="_15"><a name="user-content-_15" href="#_15" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Суть этого рецепта заключается в использовании модуля <em>heapq</em>. Функции heapq.heappush() и heapq.heappop() вставляют и удаляют элементы из list_queue таким образом, что первый элемент в списке имеет наименьший приоритет (как обсуждалось в <strong>рецепте 1.4.</strong>). Метод heappop() всегда возвращает «наименьший» элемент, что является ключом к тому, чтобы заставить очередь удалять правильные элементы. Кроме того, так как операции вталкивания и снятия имеют сложность O(log N), где N — число элементов в куче, то они являются вполне эффективными даже для весьма больших значений N.</p>
<p>В этом рецепте очередь состоит из кортежей формата <em>(-priority, index, item)</em>. Значение приоритета сделано отрицательным, чтобы заставить очередь сортировать элементы от наибольшего к наименьшему приоритету. Это противоположно обычному порядку сортировки кучи (от наименьшего к наибольшему значению).</p>
<p>Роль переменной <em>index</em> заключается в установлении правильного порядка элементов с одинаковым приоритетом. Поддержание постоянно увеличивающегося индекса позволяет сортировать элементы в соответствии с порядком, в каком они были вставлены. Однако индекс такде выполняет важную роль в выполнении операций сравнения при работе с элементами с одинаковыми значениями приоритета. </p>
<p>Если остановиться на этом подробнее, то отметим, что экземпляры класса <em>Item</em> не могут быть упорядочены. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = Item('foo')
&gt;&gt;&gt; b = Item('bar')
&gt;&gt;&gt; a &lt; b
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы создаете кортежи <em>(priority, item)</em>, то их можно сравнивать до тех пор, пока приоритеты различны. Однако же если сравниваются два кортежа с равными приоритетами, то сравнение не может быть проведено (как и ранее). Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = (1, Item('foo'))
&gt;&gt;&gt; b = (5, Item('bar'))
&gt;&gt;&gt; a &lt; b
True
&gt;&gt;&gt; c = (1, Item('grok'))
&gt;&gt;&gt; a &lt; c
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
&gt;&gt;&gt;
</code></pre></p>
<p>Вводя дополнительный индекс и создавая кортежи <em>(priority, index, item)</em>, вы избегаете этой проблемы полностью, поскольку два кортежа никогда не будут иметь одинаковые значения переменной <em>index</em> (и Python никогда не будет сравнивать остальные значения в кортежах, если результат сравнения уже определен):<br />
<pre><code class="python">&gt;&gt;&gt; a = (1, 0, Item('foo'))
&gt;&gt;&gt; b = (5, 1, Item('bar'))
&gt;&gt;&gt; c = (1, 2, Item('grok'))
&gt;&gt;&gt; a &lt; b
True
&gt;&gt;&gt; a &lt; c
True
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите использовать эту очередь для коммуникации между потоками (тредами), вы должны добавить правильную блокировку и передачу сигналов (cм. <strong>рецепт 12.3.</strong>).  </p>
<p>Документация модуля <em>heapq</em> содержит дополнительные примеры и обсуждения теории и имплементации куч.</p>
<h2 id="16"><a name="user-content-16" href="#16" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.6. Отображение ключей на множественные значения в словаре</h2>
<h3 id="_16"><a name="user-content-_16" href="#_16" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите создать словарь, который отображает ключи на более чем одно значение (так называемый «мультисловарь», multidict).</p>
<h3 id="_17"><a name="user-content-_17" href="#_17" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Словарь — это отображение, где каждый ключ отображен на единственное значение. Если вы хотите отобразить ключи на множественные значения, вам нужно хранить множественные значения в другом контейнере, таком как список или множество. Например, вы можете создавать такие словари:<br />
<pre><code class="python">d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
}

e = {
    'a' : {1, 2, 3},
    'b' : {4, 5}
}
</code></pre></p>
<p>Выбор того, использовать или не использовать списки или множества, зависит от того, как будет использован мультисловарь. Применяйте список, если вы хотите сохранить порядок, в котором добавлены элементы. Применяйте множество, если вы хотите устранить дубликаты (и при этом не беспокоитесь о порядке элементов).</p>
<p>Чтобы легко создавать такие словари, вы можете использовать <em>defaultdict</em> из модуля <em>collections</em>. Фишка <em>defautdict</em> заключается в автоматической инициализации первого значения, так что вы можете сосредоточиться на добавлении элементов. Например:<br />
<pre><code class="python">from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
...

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
...
</code></pre></p>
<p>Одно предупреждение: <em>defaultdict</em> автоматически создаст записи словаря для ключей, к которым позже будет осуществлен доступ (даже если их в данный момент в словаре нет). Если такое поведение нежелательно, вы можете использовать <em>setdefault()</em> на обычном словаре. Например:<br />
<pre><code class="python">d = {}  # A regular dictionary
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)
...
</code></pre></p>
<p>Однако многие программисты находят <em>setdefault()</em> несколько неестественным — и это если не учитывать тот факт, что он всегда создает новый экземпляр первоначального значения при каждом вызове (в примере это пустой список []).</p>
<h3 id="_18"><a name="user-content-_18" href="#_18" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Конструирование словарей с множественными значениями не является чем-то сложным. Однако инициализация первого значения может быть запутанной, если вы пытаетесь сделать это самостоятельно. Например, вы можете написать что-то такое:<br />
<pre><code class="python">d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
</code></pre></p>
<p>Использование <em>defaultdict</em> приводит к намного более чистому коду:<br />
<pre><code class="python">d = defaultdict(list)
for key, value in pairs:
    d[key].append(value)
</code></pre></p>
<p>Этот рецепт сильно связан с проблемой группировки записей в задачах обработки данных. Посмотрите, например, рецепт <strong>1.15.</strong></p>
<h2 id="17"><a name="user-content-17" href="#17" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.7. Поддержание порядка в словарях</h2>
<h3 id="_19"><a name="user-content-_19" href="#_19" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите создать словарь, и вы также хотите контролировать порядок элементов при итерировании или сериализации.</p>
<h3 id="_20"><a name="user-content-_20" href="#_20" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы контролировать порядок элементов в словаре, вы можете использовать <em>OrderedDict</em> из модуля <em>collections</em>. Он в точности сохраняет изначальный порядок добавления данных при итерировании. Например:<br />
<pre><code class="python"> from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

# Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;
for key in d:
    print(key, d[key])
</code></pre></p>
<p><em>OrderedDict</em> особенно полезен, когда вы хотите создать отображение, которое вы в дальнейшем собираетесь сериализовать или закодировать в другой формат. Например, если вы хотите строго контролировать порядок полей, выводимых в JSON, вам нужно просто создать <em>OrderedDict</em> с нужными данными:<br />
<pre><code class="python">&gt;&gt;&gt; import json

&gt;&gt;&gt; json.dumps(d)
'{&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4}'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_21"><a name="user-content-_21" href="#_21" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p><em>OrderedDict</em> внутри себя поддерживает двусвязный список, который упорядочивает ключи в соответствии с порядком добавления. Когда новый элемент вставляется впервые, он помещается в конец этого списка. Последующее связывание значения с существующим ключом не изменяет порядок.</p>
<p>Заметьте, что размер <em>OrderedDict</em> более чем в два раза превышает размер обычного словаря из-за содержащегося внутри дополнительного списка. А если вы собираетесь создать структуру данных, в которой будет большое число экземпляров <em>OrderedDict</em> (например, вы хотите прочитать 100 000 строк CSV-файла в список экземпляров <em>OrderedDict</em>), вам стоит изучить требования вашего приложения, чтобы решить, перевесят ли преимущества использования <em>OrderedDict</em> оверхед на дополнительную память. </p>
<h2 id="18"><a name="user-content-18" href="#18" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.8. Вычисления в словарях</h2>
<h3 id="_22"><a name="user-content-_22" href="#_22" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите проводить различные вычисления (например, поиск минимального и максимального значения, сортировку) в словаре с данными.</p>
<h3 id="_23"><a name="user-content-_23" href="#_23" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Рассмотрим словарь, который отображает тикеры (названия) акций на цены:<br />
<pre><code class="python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
</code></pre></p>
<p>Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно обратить ключи и значения, используя функцию zip(). Например, вот так можно найти минимальную и максимальную цену, а также соответствующий тикер:<br />
<pre><code class="python">min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')

max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
</code></pre></p>
<p>Похожим образом для ранжирования данных можно использовать zip() с sorted(), как показано ниже:<br />
<pre><code class="python">prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
#                   (45.23, 'ACME'), (205.55, 'IBM'),
#                   (612.78, 'AAPL')]
</code></pre></p>
<p>Когда вы производите эти вычисления, обратите внимание, что zip() создает итератор, по которому можно пройти только один раз. Например, следующий фрагмент кода — неправильный:<br />
<pre><code class="python">prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names))  # OK
print(max(prices_and_names))  # ValueError: max() arg is an empty sequence
</code></pre></p>
<h3 id="_24"><a name="user-content-_24" href="#_24" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Если вы попытаетесь выполнить обычные обработки данных на словаре, то вы обнаружите, что они обрабатывают только ключи, но не значения. Например:<br />
<pre><code class="python">min(prices)  # Returns 'AAPL'
max(prices)  # Returns 'IBM'
</code></pre></p>
<p>Вероятно, это не то, чего вы хотели добиться, поскольку вы пытались выполнить вычисления с использованием значений словаря. Вы можете попробовать исправить это, используя метод словаря values():<br />
<pre><code class="python">min(prices.values())  # Returns 10.75
max(prices.values())  # Returns 612.78
</code></pre></p>
<p>К несчастью, это часто тоже не позволит вам добиться желаемого. Например, вы можете хотеть знать соответствующие ключи (т.е., у каких акций самая низкая цена?)</p>
<p>Вы можете получить ключ, соответствующий минимальному или максимальному значению, если вы передадите функцию в функции min() и max(). Например:<br />
<pre><code class="python">min(prices, key=lambda k: prices[k])  # Returns 'FB'
max(prices, key=lambda k: prices[k])  # Returns 'AAPL'
</code></pre></p>
<p>Однако чтобы получить минимальное значение, вам потребуется дополнительное обращение. Например:<br />
<pre><code class="python">min_value = prices[min(prices, key=lambda k: prices[k])]
</code></pre></p>
<p>Решение с использованием функции zip() решает задачу путем «обращения» словаря в последовательность пар (value, key). Когда выполняется сравнение таких кортежей, элемент value сравнивается первым, а key — следующим. Это дает вам то самое поведение, которое вы хотите, и которое позволяет проводить обработки и сортировку словаря с использованием единственного выражения.</p>
<p>Стоит отметить, что в вычислениях с использованием пар (value, key) key будет использован, чтобы определить результат в экземплярах, где множественные записи имеют одинаковые value. Например, в вычислениях min() и max() запись с наименьшим или наибольшим ключом будет возвращена, если найдутся дублированные (одинаковые) значения (value). Например:<br />
<pre><code class="python">&gt;&gt;&gt; prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
&gt;&gt;&gt;
</code></pre></p>
<h2 id="19"><a name="user-content-19" href="#19" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.9. Поиск общих элементов в двух словарях</h2>
<h3 id="_25"><a name="user-content-_25" href="#_25" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас два словаря, и вы хотите выяснить, что у них общего (одинаковые ключи, значения и т.п.)</p>
<h3 id="_26"><a name="user-content-_26" href="#_26" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Рассмотрим два словаря:<br />
<pre><code class="python">a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}

b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
</code></pre></p>
<p>Чтобы найти общие элементы, просто выполните обычный набор операций с использовением методов keys() и items(). Например:<br />
<pre><code class="python"># Find keys in common
a.keys() &amp; b.keys()  # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys()  # { 'z' }
# Find (key,value) pairs in common
a.items() &amp; b.items() # { ('y', 2) }
</code></pre></p>
<p>Операции такого типа также могут быть использованы для изменения или фильтрования содержимого словаря. Предположим, например, что вы хотите создать новый словарь, в котором некоторые ключи удалены. Взгляните на этот пример кода генератора словаря (dictionary comprehension):<br />
<pre><code class="python"># Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
</code></pre></p>
<h3 id="_27"><a name="user-content-_27" href="#_27" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Словарь — это отображение множества ключей на множество значений. Метод словаря keys() возвращает объект просмотра ключей (keys-view object). Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над множествами (объединения, пересечения, разности и т.п.) Так что если вам нужно выполнить этот набор операций над ключами словаря, вы можете использовать объект просмотра напрямую, без предварительного конвертирования в множество.</p>
<p>Метод словаря items() возвращает объект просмотра элементов, состоящий из пар (key, value). Этот объект поддерживает похожий набор операций и может быть использован для выполнения таких операций, как поиск того, какие пары ключ-значение являются общими для двух словарей.</p>
<p>Хотя метод словаря values() похож на предыдущие, он не поддерживает операции над множествами, описанные выше в этом рецепте. Это происходит, в частности, по причине того, что, в отличие от ключей, элементы объекта просмотра значений могут быть и не уникальными. Один этот факт делает применение к ним операций над множествами малополезным. Если же, однако, вы вынуждены выполнить такие операции, этого можно добиться путем простой предварительного конвертирования значений в множество.</p>
<h2 id="110"><a name="user-content-110" href="#110" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.10. Удаление дубликатов из последовательности с сохранением порядка элементов</h2>
<h3 id="_28"><a name="user-content-_28" href="#_28" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите исключить дублирующиеся значения из последовательности, но при этом сохранить порядок следования оставшихся элементов. </p>
<h3 id="_29"><a name="user-content-_29" href="#_29" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если значения в последовательности являются хэшируемыми, задача может быть легко решена с использованием множества и генератора. Например:<br />
<pre><code class="python">def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
</code></pre></p>
<p>Вот пример использования этой функции:<br />
<pre><code class="python">&gt;&gt;&gt; a = [1, 5, 2, 1, 9, 1, 5, 10]
&gt;&gt;&gt; list(dedupe(a))
[1, 5, 2, 9, 10]
&gt;&gt;&gt;
</code></pre></p>
<p>Это будет работать только в том случае, если элементы последовательности хэшируются. Если вы пытаетесь удалить дубликаты в последовательности из нехэшируемых типов (таких как словари), вы можете внести небольшое изменение в этот рецепт. Например, такое:<br />
<pre><code class="python">def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)
</code></pre></p>
<p>Аргумент key здесь нужен для определения функции, которая конвертирует элементы последовательности в хэшируемый тип, подходящий для поиска дубликатов. Вот как это работает:<br />
<pre><code class="python">&gt;&gt;&gt; a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
&gt;&gt;&gt; list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
&gt;&gt;&gt; list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
&gt;&gt;&gt;
</code></pre></p>
<p>Последнее решение также отлично работает, если вам нужно удалить дубликаты, базируясь на значении одного поля или атрибута или более крупной структуры данных.</p>
<h3 id="_30"><a name="user-content-_30" href="#_30" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Если всё, что вы хотите сделать, это просто удалить дубликаты, то часто достаточно создать множество. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a
[1, 5, 2, 1, 9, 1, 5, 10]
&gt;&gt;&gt; set(a)
{1, 2, 10, 5, 9}
&gt;&gt;&gt;
</code></pre></p>
<p>Однако этот поход не сохраняет какой бы то ни было порядок, поэтому результат будет перемешан. Показанный выше решения помогают избежать этого. </p>
<p>Использование функции-генератора в этом рецепте отражает тот факт, что вы наверняка хотите написать функцию максимально широкого назначения, а не напрямую привязанную к обработке списков. Например, если вы хотите читать файл, удаляя дублирующиеся строки, вы можете сделать так:<br />
<pre><code class="python">with open(somefile,'r') as f:
    for line in dedupe(f):
        ...
</code></pre></p>
<p>Передача функции в аргументе key имитирует похожую возможность во встроенных функциях, таких как sorted(), min() и max(). См., например, рецепты <strong>1.8</strong> и <strong>1.13.</strong></p>
<h2 id="111"><a name="user-content-111" href="#111" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.11. Присваивание имён срезам</h2>
<h3 id="_31"><a name="user-content-_31" href="#_31" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Ваша программа превратилась в нечитабельную массу индексов срезов, и вы хотите всё это расчистить.</p>
<h3 id="_32"><a name="user-content-_32" href="#_32" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Предположим, что у вас есть код, который вытаскивает определенные поля с данными из строковых записей с фиксированным набором полей (то есть из файла с плоской структурой или похожего формата):<br />
<pre><code class="python">###### 0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:32]) * float(record[40:48])
</code></pre></p>
<p>Вместо этого вы вполне можете присвоить срезам имена:<br />
<pre><code class="python">SHARES = slice(20,32)
PRICE  = slice(40,48)

cost = int(record[SHARES]) * float(record[PRICE])
</code></pre></p>
<p>В последнем примере вы избежали появления кучи загадочных индексов, и код стал проще и яснее.</p>
<h3 id="_33"><a name="user-content-_33" href="#_33" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Общее правило таково: написание кода с большим количеством неоформленных индексов ведет к проблемам с читабельностью и поддерживаемостью. Например, если вы вернетесь к такому коду через год, то наверняка не сразу вспомните, как и о чём вы думали, когда всё это писали. Приведённое выше решение — простой путь к более ясному обозначению того, что делает ваш код. </p>
<p>В общем, встроенная функция slice() создает объект среза, который может быть использован везде, где можно бы использовать обычные срезы. Например:<br />
<pre><code class="python">&gt;&gt;&gt; items = [0, 1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; a = slice(2, 4)
&gt;&gt;&gt; items[2:4]
[2, 3]
&gt;&gt;&gt; items[a]
[2, 3]
&gt;&gt;&gt; items[a] = [10,11]
&gt;&gt;&gt; items
[0, 1, 10, 11, 4, 5, 6]
&gt;&gt;&gt; del items[a]
&gt;&gt;&gt; items
[0, 1, 4, 5, 6]
</code></pre></p>
<p>Если у вас есть экземпляр <em>slice</em> s, вы можете получить больше информации о нём, если посмотрите на атрибуты s.start, s.stop и s.step. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = slice(10, 50, 2)
&gt;&gt;&gt; a.start
10
&gt;&gt;&gt; a.stop
50
&gt;&gt;&gt; a.step
2
&gt;&gt;&gt;
</code></pre></p>
<p>Также вы можете наложить срез на последовательность определенного размера, используя его метод indices(size). Он возвращает кортеж (start, stop, step), где все значения соответственно ограничены, чтобы вписаться в границы (для избегания исключений IndexError при индексировании). Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'HelloWorld'
&gt;&gt;&gt; a.indices(len(s))
(5, 10, 2)
&gt;&gt;&gt; for i in range(*a.indices(len(s))):
...   print(s[i])
...
W
r
d
&gt;&gt;&gt;
</code></pre></p>
<h2 id="112"><a name="user-content-112" href="#112" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.12. Определение наиболее часто встречающихся элементов в последовательности</h2>
<h3 id="_34"><a name="user-content-_34" href="#_34" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Проблема</h3>
<p>У вас есть последовательность элементов, и вы хотите узнать, какие элементы встречаются в ней чаще всего.</p>
<h3 id="_35"><a name="user-content-_35" href="#_35" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Класс <em>collections.Counter</em> разработан как раз решения для подобных задач. В нем даже есть удобный метод <em>most_common()</em>, который сразу выдаст вам ответ.</p>
<p>Чтобы проиллюстрировать это, предположим, что у вас есть список слов, и вы хотите найти наиболее часто встречающееся. Вот как можно это сделать:<br />
<pre><code class="python">words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', &quot;you're&quot;, 'under'
]

from collections import Counter

word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</code></pre></p>
<h3 id="_36"><a name="user-content-_36" href="#_36" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>На входе объектам класса <em>Counter</em> можно скормить любую последовательность хэшируемых элементов. Под капотом <em>Counter</em> — это словарь, который отображает элементы на количество вхождений. Например:<br />
<pre><code class="python">&gt;&gt;&gt; word_counts['not']
1
&gt;&gt;&gt; word_counts['eyes']
8
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите увеличить счёт вручную, используйте сложение:<br />
<pre><code class="python">&gt;&gt;&gt; morewords = ['why','are','you','not','looking','in','my','eyes']
&gt;&gt;&gt; for word in morewords:
...   word_counts[word] += 1
...
&gt;&gt;&gt; word_counts['eyes']
9
&gt;&gt;&gt;
</code></pre></p>
<p>Или же вы можете использовать метод <em>update()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; word_counts.update(morewords)
&gt;&gt;&gt;
</code></pre></p>
<p>Малоизвестная возможность экземпляров Counter состоит в том, что они могут быть легко скомбинированы с использованием разнообразных математических операций. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = Counter(words)
&gt;&gt;&gt; b = Counter(morewords)
&gt;&gt;&gt; a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
        &quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1, 'not': 1})
&gt;&gt;&gt; b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
        'my': 1, 'why': 1})

&gt;&gt;&gt; # Combine counts
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
        'around': 2, &quot;you're&quot;: 1, &quot;don't&quot;: 1, 'in': 1, 'why': 1,
        'looking': 1, 'are': 1, 'under': 1, 'you': 1})

&gt;&gt;&gt; # Subtract counts
&gt;&gt;&gt; d = a - b
&gt;&gt;&gt; d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
        &quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1})
&gt;&gt;&gt;
</code></pre></p>
<p>Нет смысла упоминать, что объекты Counter — невероятно полезный инструмент для практически любых задач, где вам нужно перевести данные в табличную форму и посчитать их. Рекомендуем использовать этот способ, а не писать вручную решения на основе словарей.</p>
<h2 id="113"><a name="user-content-113" href="#113" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.13. Сортировка списка словарей по общему ключу</h2>
<h3 id="_37"><a name="user-content-_37" href="#_37" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более словарным значениям.</p>
<h3 id="_38"><a name="user-content-_38" href="#_38" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Сортировка структур этого типа легко выполняется с помощью функции <em>itemgetter</em> из модуля <em>operator</em>. Предположим, вы выполнили запрос к таблице базы данных, чтобы получить список зарегистрированных пользователей вашего сайта, и получили в ответ вот такую структуру данных:<br />
<pre><code class="python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
</code></pre></p>
<p>Можно достаточно легко вывести эти строки упорядоченно по любому из полей, общих для всех словарей. Например:<br />
<pre><code class="python">from operator import itemgetter

rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))

print(rows_by_fname)
print(rows_by_uid)
</code></pre></p>
<p>Вышеприведенный код выведет следующее:<br />
<pre><code class="python">[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]

[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
</code></pre></p>
<p>Функция <em>itemgetter()</em> также может принимать несколько ключей. Пример кода:<br />
<pre><code class="python">rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)
</code></pre></p>
<p>Вышеприведенный код выведет:<br />
<pre><code class="python">[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
</code></pre></p>
<h3 id="_39"><a name="user-content-_39" href="#_39" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>В этом примере строки передаются встроенной функции <em>sorted()</em>, которая принимает именованный аргумент <em>key</em>. Этот аргумент должен быть вызываемым объектом, который принимает один элемент из <em>rows</em> и возвращает значение, которое будет использовано в качестве основы для сортировки. Функция <em>itemgetter()</em> создает такой вызываемый объект. <strong>(Прим. пер.: вызываемый объект — это объект, который имеет метод <strong>call</strong>).</strong></p>
<p>Функция <em>operator.itemgetter()</em> принимает в качестве аргументов индексы, которые используются для извлечения желаемых значений из записей в <em>rows</em>. Это может быть ключ словаря, номер элемента в списке или любое другое значение, которое может быть скормлено методу <em><strong>getitem()</strong></em>. Если вы передадите несколько индексов функции <em>itemgetter()</em>, вызываемый объект, который она создаст, вернет кортеж со всеми элементами, и функция <em>sorted()</em> упорядочит выводимые элементы в соответствии с отсортированным порядком кортежей. Это может быть полезно, если вы хотите провести сортировку сразу по нескольким полям (в примере это имя и фамилия):<br />
<pre><code class="python">rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
</code></pre></p>
<p>Это решение в большинстве случаев работает отлично. Однако решение с использованием <em>itemgetter()</em> обычно выполняется быстрее. Так что обратите на него внимание, если производительность в фокусе вашего внимания.</p>
<p>Последнее по порядку, но не по значению: не забудьте, что описанная в этом рецепте техника может быть применена к таким функциям, как <em>min()</em> и <em>max()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
&gt;&gt;&gt; max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
&gt;&gt;&gt;
</code></pre></p>
<h2 id="114"><a name="user-content-114" href="#114" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.14. Сортировка объектов, не поддерживающих сравнение</h2>
<h3 id="_40"><a name="user-content-_40" href="#_40" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите отсортировать объекты одного класса, но они не поддерживают операции сравнения.</p>
<h3 id="_41"><a name="user-content-_41" href="#_41" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Встроенная функция <em>sorted()</em> принимает аргумент <em>key</em>, в котором может быть передан вызываемый объект, который будет возвращать некоторое значение из объектов, которое <em>sorted()</em> будет использовать для сравнения этих объектов. Например, если у вас в приложении есть последовательность экземпляров класса <em>User</em>, и вы хотите отсортировать их по атрибуту <em>user_id</em>, то вы могли бы предоставить вызываемый объект, который принимает экземпляр класса <em>User</em> и возвращает атрибут <em>user_id</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; class User:
...  def __init__(self, user_id):
...     self.user_id = user_id
...  def __repr__(self):
...     return 'User({})'.format(self.user_id)
...
&gt;&gt;&gt; users = [User(23), User(3), User(99)]
&gt;&gt;&gt; users
[User(23), User(3), User(99)]
&gt;&gt;&gt; sorted(users, key=lambda u: u.user_id)
[User(3), User(23), User(99)]
&gt;&gt;&gt;
</code></pre></p>
<p>Вместо лямбды можно применить альтернативный подход с использованием <em>operator.attrgetter()</em>: <br />
<pre><code class="python">&gt;&gt;&gt; from operator import attrgetter
&gt;&gt;&gt; sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_42"><a name="user-content-_42" href="#_42" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Использовать или не использовать лямбду или <em>attrgetter()</em> — вопрос личных предпочтений. Однако <em>attrgetter()</em> часто оказывается немного быстрее, а также добавляет возможность одновременного извлечения нескольких полей. Это аналогично использованию <em>operator.itemgetter()</em> для словарей (см. <strong>рецепт 1.13.</strong>). Например, если экземпляры класса User также имеют атрибуты <em>first_name</em> и <em>last_name</em>, вы можете выполнить вот такую сортировку:<br />
<pre><code class="python">by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
</code></pre></p>
<p>Также стоит отметить, что использованный в этом рецепте приём может быть применён к таким функциям, как <em>min()</em> и <em>max()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; min(users, key=attrgetter('user_id')
User(3)
&gt;&gt;&gt; max(users, key=attrgetter('user_id')
User(99)
&gt;&gt;&gt;
</code></pre></p>
<h2 id="115"><a name="user-content-115" href="#115" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.15. Группировка записей на основе полей</h2>
<h3 id="_43"><a name="user-content-_43" href="#_43" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть последовательность словарей или экземпляров, и вы хотите итерировать по данным в группах, основываясь на значении конкретного поля (например, на дате).</p>
<h3 id="_44"><a name="user-content-_44" href="#_44" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Функция <em>itertools.groupby()</em> особенно полезна для такого типа группировки данных. Предположим, что у вас есть список словарей:<br />
<pre><code class="python">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
</code></pre></p>
<p>Предположим также, что вы хотите проитерировать по данным, причем сгруппированными по дате кусочками. Проведем отсортировку по нужному полю (в данном случае по дате), а потом применим <em>itertools.groupby()</em>:<br />
<pre><code class="python">from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))

# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre></p>
<p>Вывод будет таким:<br />
<pre><code class="python">07/01/2012
    {'date': '07/01/2012', 'address': '5412 N CLARK'}
    {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
    {'date': '07/02/2012', 'address': '5800 E 58TH'}
    {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
    {'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
    {'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
    {'date': '07/04/2012', 'address': '5148 N CLARK'}
    {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
</code></pre></p>
<h3 id="_45"><a name="user-content-_45" href="#_45" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Функция <em>groupby()</em> работает так: сканирует последовательность и ищет последовательные «партии» одинаковых значений (или значений, возвращенных переданной через <em>key</em> функцией). В каждой итерации функции возвращает значение вместе с итератором, который выводит все элементы в группу с одинаковым значением.</p>
<p>Важным предварительным шагом тут является сортировка данных по интересующему нас полю. Поскольку <em>groupby()</em> проверяет только последовательные элементы, без предварительной сортировки группировка записей выполнена не будет.</p>
<p>Если ваша цель — просто сгруппировать данные вместе в крупную структуру данных с произвольным доступом, то вам больше поможет defaultdict(), которая создает «мультисловарь», как описано в <strong>рецепте 1.6</strong>. Например:<br />
<pre><code class="python">from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
</code></pre></p>
<p>Это позволяет легко получить доступ к записям для каждой даты:<br />
<pre><code class="python">&gt;&gt;&gt; for r in rows_by_date['07/01/2012']:
...   print(r)
...
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
&gt;&gt;&gt;
</code></pre></p>
<p>В последнем примере предварительная сортировка записей не обязательна. Но если вы не заботитесь о потреблении памяти, то может оказаться быстрее сделать это с помощью предварительной сортировки и итерированию с использованием <em>groupby()</em>.  </p>
<h2 id="116"><a name="user-content-116" href="#116" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.16. Фильтрование элементов последовательности</h2>
<h3 id="_46"><a name="user-content-_46" href="#_46" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть данные внутри последовательности, и вы хотите извлечь значения или уменьшить последовательность по какому-либо критерию.</p>
<h3 id="_47"><a name="user-content-_47" href="#_47" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Самый простой способ фильтрования последовательности — использовать генератор списка (list comprehension). Например:<br />
<pre><code class="python">&gt;&gt;&gt; mylist = [1, 4, -5, 10, -7, 2, 3, -1]
&gt;&gt;&gt; [n for n in mylist if n &gt; 0]
[1, 4, 10, 2, 3]
&gt;&gt;&gt; [n for n in mylist if n &lt; 0]
[-5, -7, -1]
&gt;&gt;&gt;
</code></pre></p>
<p>Потенциальная проблема с использованием генераторов списоков заключается в том, что они могут создать большой результат, если размер входных данных тоже большой. Если это вас беспокоит, вы можете использовать выражения-генераторы для итеративного возврата отфильтрованных значений. Например:<br />
<pre><code class="python">&gt;&gt;&gt; pos = (n for n in mylist if n &gt; 0)
&gt;&gt;&gt; pos
&lt;generator object &lt;genexpr&gt; at 0x1006a0eb0&gt;
&gt;&gt;&gt; for x in pos:
...   print(x)
...
1
4
10
2
3
&gt;&gt;&gt;
</code></pre><br />
Иногда критерий фильтрования не может быть легко выражен в форме генератора списка или выражения-генератора. Предположим, например, что процесс фильтрования включает обработку исключений или какой-то другой сложный момент. Чтобы справиться с этим, поместите фильтрующий код в функцию и используйте встроенную функцию <em>filter()</em>. Например: <br />
<pre><code class="python">values = ['1', '2', '-3', '-', '4', 'N/A', '5']

def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False

ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
</code></pre></p>
<p><em>filter()</em> создает итератор, так что если вы хотите получить список результатов, не забудьте использовать <em>list()</em>, как показано выше.</p>
<h3 id="_48"><a name="user-content-_48" href="#_48" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Генераторы списков и выражения-генераторы часто являются самым лёгким и прямым способом фильтрования простых данных. Но у них также есть дополнительная способность одновременного изменения данных. Например:<br />
<pre><code class="python">&gt;&gt;&gt; mylist = [1, 4, -5, 10, -7, 2, 3, -1]
&gt;&gt;&gt; import math
&gt;&gt;&gt; [math.sqrt(n) for n in mylist if n &gt; 0]
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
&gt;&gt;&gt;
</code></pre></p>
<p>Одна из разновидностей фильтрования включает замену значений, которые не подходят под определенный критерий, другим значением (вместо отбраковки неподходящих). Например, вместо простого поиска положительных значений, вы также хотите обрезать «плохие» значения, чтобы они попадали в определенный диапазон. В большинстве случаев это легко сделать с помощью перемещения критерия фильтрования в условное выражение:<br />
<pre><code class="python">&gt;&gt;&gt; clip_neg = [n if n &gt; 0 else 0 for n in mylist]
&gt;&gt;&gt; clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
&gt;&gt;&gt; clip_pos = [n if n &lt; 0 else 0 for n in mylist]
&gt;&gt;&gt; clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
&gt;&gt;&gt;
</code></pre></p>
<p>Другой важный инструмент для фильтрации — <em>itertools.compress()</em>, который принимает итерируемый объект вместе с последовательностью-селектором из булевых значений. На выходе функция выдает все элементы итерируемого объекта, для которых совпадающий элемент в селекторе — True. Это может быть полезно, если вы пытаетесь применить результаты фильтрования одной последовательности к другой связанной последовательности. Например, у вас есть две колонки данных:<br />
<pre><code class="python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK'
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]

counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
</code></pre></p>
<p>Теперь предположим, что вы хотите создать список всех адресов, где соответствующие значение из <em>counts</em> больше 5. Вот как это можно сделать:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import compress
&gt;&gt;&gt; more5 = [n &gt; 5 for n in counts]
&gt;&gt;&gt; more5
[False, False, True, False, False, True, True, False]
&gt;&gt;&gt; list(compress(addresses, more5))
['5800 E 58TH', '4801 N BROADWAY', '1039 W GRANVILLE']
&gt;&gt;&gt;
</code></pre></p>
<p>Ключевой момент — сначала создать последовательность булевых значений, которые будут указывать, какие элементы удовлетворяют заданному условию. Далее функция <em>compress()</em> выберет элементы, соответствующие значениям True.</p>
<p>Как и <em>filter()</em>, функция <em>compress()</em> возвращает итератор. Поэтому если вы хотите на выходе получить список, вам придется использовать <em>list()</em>.  </p>
<h2 id="117"><a name="user-content-117" href="#117" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.17. Извлечение подмножества из словаря</h2>
<h3 id="_49"><a name="user-content-_49" href="#_49" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите создать словарь, который будет подмножеством другого словаря.</p>
<h3 id="_50"><a name="user-content-_50" href="#_50" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Эту задачу можно легко решить с помощью генератора словаря (dictionary comprehension). Например:<br />
<pre><code class="python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}

# Make a dictionary of all prices over 200
p1 = { key:value for key, value in prices.items() if value &gt; 200 }

# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:value for key,value in prices.items() if key in tech_names }
</code></pre></p>
<h3 id="_51"><a name="user-content-_51" href="#_51" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Большая часть того, что можно сделать с помощью генераторов словарей, можно осуществить путём создания последовательности кортежей и передачи их в функцию <em>dict()</em>. Например:<br />
<pre><code class="python">p1 = dict((key, value) for key, value in prices.items() if value &gt; 200)
</code></pre></p>
<p>Однако решение на основе генератора словаря немного яснее и работает немного быстрее (в рассмотренном выше примере генератор отработал в два раза быстрее). </p>
<p>Иногда существует множество путей решить задачу. Например, второй пример можно переписать так:<br />
<pre><code class="python"># Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() &amp; tech_names }
</code></pre></p>
<p>Однако подсчет времени выполнения открывает нам, что это решение почти в 1,6 раза медленнее, чем первое. Если производительность для вас важна, обычно стоит потратить немного времени на изучение таких вопросов. См. <strong>рецепт 14.13.</strong>, чтобы получить детальную информацию о подсчете времени и профилировании.</p>
<h2 id="118"><a name="user-content-118" href="#118" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.18. Отображение имен на последовательность элементов</h2>
<h3 id="_52"><a name="user-content-_52" href="#_52" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции, но такой подход часто делает программу нечитабельной. Также вы можете захотеть уменьшить зависимость от позиции в структуре данных путём перехода к доступу к элементам по имени.</p>
<h3 id="_53"><a name="user-content-_53" href="#_53" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p><em>collections.namedtuple()</em> предоставляет такую возможность, добавляя минимальный оверхед по сравнению с использованием обычного кортежа. <em>collections.namedtuple()</em> — это фабричный метод, который возвращает подкласс стандартного пайтоновского типа tuple (кортеж). Вы скармливаете этому методу имя типа и поля, которые он должен иметь, и он возвращает класс, который может порождать экземпляры с полями, которые вы определили, и значениями этих полей, которые вы передадите при порождении. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
&gt;&gt;&gt; sub = Subscriber('jonesy@example.com', '2012-10-19')
&gt;&gt;&gt; sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
&gt;&gt;&gt; sub.addr
'jonesy@example.com'
&gt;&gt;&gt; sub.joined
'2012-10-19'
&gt;&gt;&gt;
</code></pre></p>
<p>Хотя экземпляр <em>namedtuple</em> (именованного кортежа) выглядит так же, как и обычный экземпляр класса, он взаимозаменяем с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка. Например:<br />
<pre><code class="python">&gt;&gt;&gt; len(sub)
2
&gt;&gt;&gt; addr, joined = sub
&gt;&gt;&gt; addr
'jonesy@example.com'
&gt;&gt;&gt; joined
'2012-10-19'
&gt;&gt;&gt;
</code></pre></p>
<p>Самый частый случай использования именованного кортежа — отвязка вашего кода от работы с позициями элементов, которыми он манипулирует. Так что если вы получаете большой список кортежей в ответ на запрос к базе данных, а потом манипулируете ими через позиционное обращение к элементам, ваш код может сломаться, если вы, скажем, добавите новую колонку в таблицу. Этого можно избежать, если вы сначала превратите полученные кортежи в именованные кортежи.</p>
<p>Чтобы проиллюстрировать это, приведём пример кода, использующего обычные кортежи:<br />
<pre><code class="python">def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2]
    return total
</code></pre></p>
<p>Использование позиционного обращения к элементам часто делает код немного менее выразительным и более зависимым от структуры записей. А вот версия с использованием именованного кортежа:<br />
<pre><code class="python">from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total
</code></pre></p>
<p>Естественно, вы можете избежать явной конвертации в именованный кортеж <em>Stock</em>, если последовательность <em>records</em> из примера уже содержит такие экземпляры. </p>
<h3 id="_54"><a name="user-content-_54" href="#_54" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Возможное использование именованного кортежа — замена словаря, который требует больше места для хранения. Так что если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако не забудьте, что именнованные кортежи неизменяемы (в отличие от словарей). Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = Stock('ACME', 100, 123.45)
&gt;&gt;&gt; s
Stock(name='ACME', shares=100, price=123.45)
&gt;&gt;&gt; s.shares = 75
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can't set attribute
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода <em>_replace()</em>, которым обладают экземпляры именованных кортежей. Он создает полностью новый именованный кортеж, в котором указанные значения заменены. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = s._replace(shares=75)
&gt;&gt;&gt; s
Stock(name='ACME', shares=75, price=123.45)
&gt;&gt;&gt;
</code></pre></p>
<p>Тонкость использования метода <em>_replace()</em> заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте <em>_replace()</em> для создания новых экземпляров с замененными значениями. Например:<br />
<pre><code class="python">from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])

# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)

# Function to convert a dictionary to a Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)
</code></pre></p>
<p>Вот пример работы этого кода:<br />
<pre><code class="python">&gt;&gt;&gt; a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
&gt;&gt;&gt; dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
&gt;&gt;&gt; b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
&gt;&gt;&gt; dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
&gt;&gt;&gt;
</code></pre></p>
<p>Последнее, но важное замечание: стоит отметить, что если вашей целью является создание эффективной структуры данных, где вы сможете менять различные атрибуты экземпляров, использование именованных кортежей — не лучший вариант. Вместо них стоит определить класс с использованием __slots__ (см. <strong>рецепт 8.4.</strong>)</p>
<h2 id="119"><a name="user-content-119" href="#119" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.19. Одновременное преобразование и сокращение данных</h2>
<h3 id="_55"><a name="user-content-_55" href="#_55" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно выполнить функцию сокращения (т.е. sum(), min(), max()), но сначала необходимо преобразовать или отфильтровать данные.</p>
<h3 id="_56"><a name="user-content-_56" href="#_56" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Есть весьма элегантное решение для объединения сокращения и преобразования данных — выражение-генератор в аргументе. Например, если вы хотите подсчитать сумму квадратов, попробуйте следующее:<br />
<pre><code class="python">nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
</code></pre></p>
<p>Вот еще несколько примеров:<br />
<pre><code class="python"># Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
    print('There be python!')
else:
    print('Sorry, no python.')

# Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))

# Data reduction across fields of a data structure
portfolio = [
    {'name':'GOOG', 'shares': 50},
    {'name':'YHOO', 'shares': 75},
    {'name':'AOL', 'shares': 20},
    {'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio)
</code></pre></p>
<h3 id="_57"><a name="user-content-_57" href="#_57" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Решение демонстрирует тонкий синтаксический аспект выражений-генераторов, связанный с передачей их как единственного аргумента в функцию — повторяющиеся скобки не нужны. Например, следующие инструкции эквивалентны:<br />
<pre><code class="python">s = sum((x * x for x in nums))  # Pass generator-expr as argument
s = sum(x * x for x in nums)  # More elegant syntax
</code></pre></p>
<p>Использование аргумента-генератора часто будет более эффективным и элегантным, нежели предварительное создание временного списка. Например, если вы не используете выражение-генератор, вы можете поразмыслить над этой альтернативной имплементацией:<br />
<pre><code class="python">nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
</code></pre></p>
<p>Это работает, но вводит лишний шаг и создает лишний список. Для небольшого списка из примера это не имеет значения, но если <em>nums</em> был огромным, вы получите крупную временную структуру данных, которая будет использована только один раз, а потом выброшена. Решение с генератором обрабатывает данные итеративно и потому намного более эффективно с точки зрения использования памяти.</p>
<p>Некоторые функции сокращения, такие как <em>min()</em> и <em>max()</em>, принимают аргумент <em>key</em>, что может оказаться полезным в ситуациях, когда вы склоняетесь к использованию генератора. Например, в этом примере вы можете попробовать альтернативный подход:<br />
<pre><code class="python"># Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)

# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares'])
</code></pre></p>
<h2 id="120"><a name="user-content-120" href="#120" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1.20. Объединение нескольких отображений в одно</h2>
<h3 id="_58"><a name="user-content-_58" href="#_58" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть много словарей или отображений, которые вы хотите логически объединить в одно отображение, чтобы выполнить некоторые операции, такие как поиск значений или проверка существования ключей.</p>
<h3 id="_59"><a name="user-content-_59" href="#_59" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Предположим, у вас есть два словаря:<br />
<pre><code class="python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
</code></pre></p>
<p>А теперь предположим, что вы хотите провести поиски, в которых вы хотите проверить оба словаря (то есть сначала проверить в словаре <em>a</em>, а потом в <em>b</em>, если в первом словаре искомое не найдено). Простой способ сделать это — использовать класс <em>ChainMap</em> из модуля <em>collections</em>. Например:<br />
<pre><code class="python">from collections import ChainMap
c = ChainMap(a,b)
print(c['x'])  # Outputs 1 (from a)
print(c['y'])  # Outputs 2 (from b)
print(c['z'])  # Outputs 3 (from a)
</code></pre></p>
<h3 id="_60"><a name="user-content-_60" href="#_60" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p><em>ChainMap</em> принимает несколько отображений и делает так, что они логически становятся единым целым. Однако в буквальном смысле они не сливаются. Вместо этого <em>ChainMap</em> просто содержит список отображений и переопределяет обычные операции над словарями для сканирования этого списка. Большинство операций работают. Например:<br />
<pre><code class="python">&gt;&gt;&gt; len(c)
3
&gt;&gt;&gt; list(c.keys())
['x', 'y', 'z']
&gt;&gt;&gt; list(c.values())
[1, 2, 3]
&gt;&gt;&gt;
</code></pre></p>
<p>В случае появления одинаковых ключей будут использованы значения из первого словаря. Например, <em>c[&lsquo;z&rsquo;]</em> в примере всегда будет ссылаться на значение из словаря <em>a</em>, а не из <em>b</em>.</p>
<p>Операции, которые изменяют отображение, всегда действуют на первое отображение в списке. Например:<br />
<pre><code class="python">&gt;&gt;&gt; c['z'] = 10
&gt;&gt;&gt; c['w'] = 40
&gt;&gt;&gt; del c['x']
&gt;&gt;&gt; a
{'w': 40, 'z': 10}
&gt;&gt;&gt; del c['y']
Traceback (most recent call last):
...
KeyError: &quot;Key not found in the first mapping: 'y'&quot;
&gt;&gt;&gt;
</code></pre></p>
<p><em>ChainMap</em> особенно полезны для работы с ограниченным набором значений, таких как переменные языка программирования (глобальные, локальные и т.п.) На самом деле даже существуют методы, которые всё упрощают:<br />
<pre><code class="python">&gt;&gt;&gt; values = ChainMap()
&gt;&gt;&gt; values['x'] = 1
&gt;&gt;&gt; # Add a new mapping
&gt;&gt;&gt; values = values.new_child()
&gt;&gt;&gt; values['x'] = 2
&gt;&gt;&gt; # Add a new mapping
&gt;&gt;&gt; values = values.new_child()
&gt;&gt;&gt; values['x'] = 3
&gt;&gt;&gt; values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
&gt;&gt;&gt; values['x']
3
&gt;&gt;&gt; # Discard last mapping
&gt;&gt;&gt; values = values.parents
&gt;&gt;&gt; values['x']
2
&gt;&gt;&gt; # Discard last mapping
&gt;&gt;&gt; values = values.parents
&gt;&gt;&gt; values['x']
1
&gt;&gt;&gt; values
ChainMap({'x': 1})
&gt;&gt;&gt;
</code></pre></p>
<p>В качестве альтернативы <em>ChainMap</em> вы можете обдумать слияние словарей с использованием метода update(). Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = {'x': 1, 'z': 3 }
&gt;&gt;&gt; b = {'y': 2, 'z': 4 }
&gt;&gt;&gt; merged = dict(b)
&gt;&gt;&gt; merged.update(a)
&gt;&gt;&gt; merged['x']
1
&gt;&gt;&gt; merged['y']
2
&gt;&gt;&gt; merged['z']
3
&gt;&gt;&gt;
</code></pre></p>
<p>Это работает, но требует от вас создания полностью нового объекта словаря (или необратимого изменения одного из существующих). В этом случае при изменении одного из первоначальных словарей новый объект объединенного словаря изменения не затронут. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a['x'] = 13
&gt;&gt;&gt; merged['x']
1
</code></pre></p>
<p><em>ChainMap</em> использует первоначальные словари, поэтому не подвержен такому поведению. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = {'x': 1, 'z': 3 }
&gt;&gt;&gt; b = {'y': 2, 'z': 4 }
&gt;&gt;&gt; merged = ChainMap(a, b)
&gt;&gt;&gt; merged['x']
1
&gt;&gt;&gt; a['x'] = 42
&gt;&gt;&gt; merged['x']  # Notice change to merged dicts
42
&gt;&gt;&gt;
</code></pre></p>
<h1 id="2"><a name="user-content-2" href="#2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2. Строки и текст</h1>
<p>Практически любая полезная программа включает тот или иной вид обработки текста: от парсинга данных до генерации вывода. Эта глава рассматривает обычные задачи манипулирования текстом, такие как разбивка строк, поиск, подстановка, лексический анализ и парсинг. Многие из этих задач могут быть легко решены с использованием встроенных строковых методов. Однако более сложные операции могут потребовать использования регулярных выражений ии создания полноценного парсера. Все эти темы разобраны в данной главе. Также мы обратим внимание на несколько хитрых аспектов работы с Unicode.</p>
<h2 id="21"><a name="user-content-21" href="#21" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.1. Разрезание строк, разделенных различными разделителями</h2>
<h3 id="_61"><a name="user-content-_61" href="#_61" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно разделить строку на поля, но разделители (и пробелы вокруг них) внутри строки не одинаковые.</p>
<h3 id="_62"><a name="user-content-_62" href="#_62" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Функция <em>re.split()</em> будет в этом случае весьма полезной, поскольку вы сможете определить многочисленные шаблоны разделителей. Например, как показано в решении, разделитель может быть либо запятой (,), точкой с запятой (;) или пробелом, за которым следует любое количество дополнительных пробелов. Какой бы из этих шаблонов ни был найден, совпадение становится разделителем. Результатом будет просто список полей, точно такой же, какой создает строковый метод <em>str.split()</em>.</p>
<p>При применении re.split() вы должны быть осторожными, если шаблон регулярного выражения использует группу, заключенную в скобки. При использовании групп совпавший с шаблоном текст также включается в результат. Например:<br />
<pre><code class="python">&gt;&gt;&gt; fields = re.split(r'(;|,|\s)\s*', line)
&gt;&gt;&gt; fields
['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
&gt;&gt;&gt;
</code></pre></p>
<p>Получение символов-разделителей может быть полезным в некоторых обстоятельствах. Например, вам могут потребоваться эти символы позже — для переформатирования выводимой строки:<br />
<pre><code class="python">&gt;&gt;&gt; values = fields[::2]
&gt;&gt;&gt; delimiters = fields[1::2] + ['']
&gt;&gt;&gt; values
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
&gt;&gt;&gt; delimiters
[' ', ';', ',', ',', ',', '']

&gt;&gt;&gt; # Reform the line using the same delimiters
&gt;&gt;&gt; ''.join(v+d for v,d in zip(values, delimiters))
'asdf fjdk;afed,fjek,asdf,foo'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы не хотите, чтобы разделители попали в результат, но при этом вам нужно применить группы в шаблоне регулярного выражения, убедитесь, что вы используете незахватывающую (noncapture) группу, которая определяется так: (?:&hellip;). Например:<br />
<pre><code class="python">&gt;&gt;&gt; re.split(r'(?:,|;|\s)\s*', line)
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
&gt;&gt;&gt;
</code></pre></p>
<h2 id="22"><a name="user-content-22" href="#22" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.2. Поиск текста в начале и в конце строки</h2>
<h3 id="_63"><a name="user-content-_63" href="#_63" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно проверить начало или конец строки на содержание неких текстовых шаблонов, таких как расширения файлов, схемы URL и т.д.</p>
<h3 id="_64"><a name="user-content-_64" href="#_64" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Простой способ проверить начало или конец строки — применить методы <em>str.startswith()</em> или <em>str.endswith()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; filename = 'spam.txt'
&gt;&gt;&gt; filename.endswith('.txt')
True
&gt;&gt;&gt; filename.startswith('file:')
False
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; url.startswith('http:')
True
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно проверить несколько вариантов, передайте кортеж с ними в <em>startswith()</em> или <em>endswith()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; filenames = os.listdir('.')
&gt;&gt;&gt; filenames
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ]
&gt;&gt;&gt; [name for name in filenames if name.endswith(('.c', '.h')) ]
['foo.c', 'spam.c', 'spam.h'
&gt;&gt;&gt; any(name.endswith('.py') for name in filenames)
True
&gt;&gt;&gt;
</code></pre></p>
<p>А вот другой пример:<br />
<pre><code class="python">from urllib.request import urlopen

def read_data(name):
    if name.startswith(('http:', 'https:', 'ftp:')):
        return urlopen(name).read()
    else:
        with open(name) as f:
        return f.read()
</code></pre></p>
<p>Любопытно, что в этом случае на вход нужно подавать именно кортеж. Если так случилось, что варианты выбора собраны у вас в списке или множестве, сначала сконвертируйте их с помощью <em>tuple()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; choices = ['http:', 'ftp:']
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; url.startswith(choices)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: startswith first arg must be str or a tuple of str, not list
&gt;&gt;&gt; url.startswith(tuple(choices))
True
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_65"><a name="user-content-_65" href="#_65" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Методы <em>startswith()</em> и <em>endswith()</em> предоставляют весьма удобный способ проверки префиксов и окончаний. Такие же операции можно осуществить с помощью срезов, но это намного менее элегантно. Например:<br />
<pre><code class="python">&gt;&gt;&gt; filename = 'spam.txt'
&gt;&gt;&gt; filename[-4:] == '.txt'
True
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
True
&gt;&gt;&gt;
</code></pre></p>
<p>Вы также можете склониться к использованию регулярных выражений в качестве альтернативы. Например:<br />
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; url = 'http://www.python.org'
&gt;&gt;&gt; re.match('http:|https:|ftp:', url)
&lt;_sre.SRE_Match object at 0x101253098&gt;
&gt;&gt;&gt;
</code></pre></p>
<p>Такой подход работает, но часто это будет огнем из пушки по воробьям. Использование вышеописанного рецепта проще и работает быстрее.</p>
<p>И последнее: методы <em>startswith()</em> и <em>endswith()</em> отлично работают вместе с другими операциями, такими как обычные сокращения данных. Например, это выражение проверяет каталог на присутствие файлов определенных типов:<br />
<pre><code class="python">if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
...
</code></pre></p>
<h2 id="23-shell"><a name="user-content-23-shell" href="#23-shell" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.3. Поиск строк с использованием масок оболочки (shell)</h2>
<h3 id="_66"><a name="user-content-_66" href="#_66" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите найти текст, используя те же маски, которые обычно используются в оболочках Unix (например, <em>.py, Dat[0-9]</em>.csv и т.д.)</p>
<h3 id="_67"><a name="user-content-_67" href="#_67" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Модуль <em>fnmatch</em> предоставляет две функции: <em>fnmatch()</em> и <em>fnmatchcase()</em>, которые можно использовать для такого поиска. Всё просто:<br />
<pre><code class="python">&gt;&gt;&gt; from fnmatch import fnmatch, fnmatchcase
&gt;&gt;&gt; fnmatch('foo.txt', '*.txt')
True
&gt;&gt;&gt; fnmatch('foo.txt', '?oo.txt')
True
&gt;&gt;&gt; fnmatch('Dat45.csv', 'Dat[0-9]*')
True
&gt;&gt;&gt; names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
&gt;&gt;&gt; [name for name in names if fnmatch(name, 'Dat*.csv')]
['Dat1.csv', 'Dat2.csv']
&gt;&gt;&gt;
</code></pre></p>
<p>По умолчанию <em>fnmatch()</em> использует те же чувствительные к регистру правила, как и файловая система текущей операционной системы (то есть правила меняются от системы к системе). Например:<br />
<pre><code class="python">&gt;&gt;&gt; # On OS X (Mac)
&gt;&gt;&gt; fnmatch('foo.txt', '*.TXT')
False

&gt;&gt;&gt; # On Windows
&gt;&gt;&gt; fnmatch('foo.txt', '*.TXT')
True
&gt;&gt;&gt;
</code></pre></p>
<p>Если это различие важно, используйте метод <em>fnmatchcase()</em>. Он ищет именно такие совпадения заглавных и строчных букв, которые вы предоставите:<br />
<pre><code class="python">&gt;&gt;&gt; fnmatchcase('foo.txt', '*.TXT')
False
&gt;&gt;&gt;
</code></pre></p>
<p>Часто упускается из вида возможность использования этих функций на строках, получаемых при обработке данных, или на строках, не являющихся именами файлов. Например, у вас есть список адресов:<br />
<pre><code class="python">addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY',
]
</code></pre></p>
<p>Вы можете написать такой генератор списка (list comprehension):<br />
<pre><code class="python">&gt;&gt;&gt; from fnmatch import fnmatchcase
&gt;&gt;&gt; [addr for addr in addresses if fnmatchcase(addr, '* ST')]
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
&gt;&gt;&gt; [addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')]
['5412 N CLARK ST']
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_68"><a name="user-content-_68" href="#_68" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Поиск совпадений с использованием <em>fnmatch</em> занимает нишу между возможностями простых строковых методов и полной мощью регулярных выражений. Если вы просто хотите простой механизм для применения масок в обработке данных, он часто является подходящим решением.</p>
<p>Если же вы пишете код для поиска имён файлов, используйте модуль <em>glob</em> (см. <strong>рецепт 5.13.</strong>)</p>
<h2 id="24"><a name="user-content-24" href="#24" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.4. Поиск совпадений и поиск текстовых паттернов</h2>
<h3 id="_69"><a name="user-content-_69" href="#_69" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите отыскать совпадение или провести поиск по определенному шаблону.</p>
<h3 id="_70"><a name="user-content-_70" href="#_70" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если текст, который вы хотите найти, является простым литералом, в большинстве случаев вам подойдут базовые строковые методы, такие как <em>str.find()</em>, <em>str.endswith()</em>, <em>str.startwith()</em> и другие подобные. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'yeah, but no, but yeah, but no, but yeah'

&gt;&gt;&gt; # Exact match
&gt;&gt;&gt; text == 'yeah'
False

&gt;&gt;&gt; # Match at start or end
&gt;&gt;&gt; text.startswith('yeah')
True
&gt;&gt;&gt; text.endswith('no')
False

&gt;&gt;&gt; # Search for the location of the first occurrence
&gt;&gt;&gt; text.find('no')
10
&gt;&gt;&gt;
</code></pre></p>
<p>Для более сложного поиска совпадений используйте регулярные выражения и модуль <em>re</em>. Чтобы проиллюстрировать базовые механики использования регулярных выражений, предположим, что вы хотите найти даты, определенные цифрами, такие как «11/27/2012.» Вот пример того, как вы можете это сделать:<br />
<pre><code class="python">&gt;&gt;&gt; text1 = '11/27/2012'
&gt;&gt;&gt; text2 = 'Nov 27, 2012'
&gt;&gt;&gt;
&gt;&gt;&gt; import re
&gt;&gt;&gt; # Simple matching: \d+ means match one or more digits
&gt;&gt;&gt; if re.match(r'\d+/\d+/\d+', text1):
...   print('yes')
... else:
...   print('no')
...
yes
&gt;&gt;&gt; if re.match(r'\d+/\d+/\d+', text2):
...   print('yes')
... else:
...   print('no')
...
no
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы собираетесь много раз искать по одному и тому же шаблону, часто окупается предварительная компиляция шаблона регулярного выражения в объект шаблона. Например:<br />
<pre><code class="python">&gt;&gt;&gt; datepat = re.compile(r'\d+/\d+/\d+')
&gt;&gt;&gt; if datepat.match(text1):
...   print('yes')
... else:
...   print('no')
...
yes
&gt;&gt;&gt; if datepat.match(text2):
...   print('yes')
... else:
...   print('no')
...
no
&gt;&gt;&gt;
</code></pre></p>
<p><em>match()</em> всегда пытается найти совпадения в начале строки. Если вы хотите провести поиск по всем случаям соответствия шаблону, используйте метод <em>findall()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
&gt;&gt;&gt; datepat.findall(text)
['11/27/2012', '3/13/2013']
&gt;&gt;&gt;
</code></pre></p>
<p>При составлении регулярных выражений, часто нужно использовать захватывающие группы, заключая части шаблона в скобки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
&gt;&gt;&gt;
</code></pre></p>
<p>Захватывающие группы часто упрощают последующую обработку найденного текста, поскольку содержимое каждой группы может быть извлечено отдельно. Например:<br />
<pre><code class="python">&gt;&gt;&gt; m = datepat.match('11/27/2012')
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object at 0x1005d2750&gt;

&gt;&gt;&gt; # Extract the contents of each group
&gt;&gt;&gt; m.group(0)
'11/27/2012'
&gt;&gt;&gt; m.group(1)
'11'
&gt;&gt;&gt; m.group(2)
'27'
&gt;&gt;&gt; m.group(3)
'2012'
&gt;&gt;&gt; m.groups()
('11', '27', '2012')
&gt;&gt;&gt; month, day, year = m.groups()
&gt;&gt;&gt;

&gt;&gt;&gt; # Find all matches (notice splitting into tuples)
&gt;&gt;&gt; text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
&gt;&gt;&gt; datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
&gt;&gt;&gt; for month, day, year in datepat.findall(text):
...   print('{}-{}-{}'.format(year, month, day))
...
2012-11-27
2013-3-13
&gt;&gt;&gt;
</code></pre></p>
<p>Метод <em>findall()</em> проходит по тексту и находит все совпадения, возвращая их в списке. Если вы хотите искать совпадения итеративно, используйте метод <em>finditer()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; for m in datepat.finditer(text):
...   print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_71"><a name="user-content-_71" href="#_71" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Вводного курса в теорию регулярных выражений в этой книге вы не найдете. Однако этот рецепт демонстрирует простейшие примеры использования модуля re для поиска совпадений в тексте. Самые основные приёмы — компилирование шаблонов с использованием <em>re.compile()</em> и последующее использование таких методов как <em>match()</em>, <em>findall()</em> или <em>finditer()</em>.  </p>
<p>При составлении шаблонов часто нужно использовать «сырые» (raw) строки, такие как r&rsquo;(\d+)/(\d+)/(\d+)&rsquo;. Такие строки оставляют символы обратных слэшей необработанными, что может быть полезно в контесте применения регулярных выражений. С другой стороны, вы можете использовать двойные обратные слэши: &lsquo;(\d+)/(\d+)/(\d+)&rsquo;. </p>
<p>Учтите, что метод <em>match()</em> проверяет только начало строки. Возможно, что он найдет вещи, которые вы не ожидаете. Например:<br />
<pre><code class="python">&gt;&gt;&gt; m = datepat.match('11/27/2012abcdef')
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object at 0x1005d27e8&gt;
&gt;&gt;&gt; m.group()
'11/27/2012'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно точное совпадение, убедитесь, что шаблон включает символ завершения ($), как в примере ниже:<br />
<pre><code class="python">&gt;&gt;&gt; datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
&gt;&gt;&gt; datepat.match('11/27/2012abcdef')
&gt;&gt;&gt; datepat.match('11/27/2012')
&lt;_sre.SRE_Match object at 0x1005d2750&gt;
&gt;&gt;&gt;
</code></pre></p>
<p>И последнее: если вы просто проводите простые операции поиска, вы часто можете пропустить шаг компиляции и использовать функции уровня модуля из модуля <em>re</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; re.findall(r'(\d+)/(\d+)/(\d+)', text)
[('11', '27', '2012'), ('3', '13', '2013')]
&gt;&gt;&gt;
</code></pre></p>
<p>Обратите внимание, что если вы проводите много операций поиска совпадений, часто окупается компилирование шаблона и многократное его использование. Функции уровня модуля поддерживают кэш недавно скомпилированных паттернов, так что вы не получите огромного выигрыша в производительности, но вы сэкономите несколько обращений и избежите лишней обработки, используя ваш собственный скомпилированный шаблон.</p>
<h2 id="25"><a name="user-content-25" href="#25" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.5. Поиск и замена текста</h2>
<h3 id="_72"><a name="user-content-_72" href="#_72" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите найти в строке и заменить текст, соответствующий некому шаблону. </p>
<h3 id="_73"><a name="user-content-_73" href="#_73" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для простых литеральных шаблонов используйте метод <em>str.replace()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'yeah, but no, but yeah, but no, but yeah'

&gt;&gt;&gt; text.replace('yeah', 'yep')
'yep, but no, but yep, but no, but yep'
&gt;&gt;&gt;
</code></pre></p>
<p>Для более сложных шаблонов используйте функции/методы <em>sub()</em> из модуля <em>re</em>. Предположим, вы хотите перезаписать даты, чтобы перевести из их формата “11/27/2012” в “2012-11-27.” Вот пример того, как это можно сделать:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
&gt;&gt;&gt;
</code></pre></p>
<p>Первый аргумент, передаваемый в <em>sub()</em>, это шаблон для поиска, а второй — шаблон, которым нужно заменять найденное. Цифры, перед которыми поставлен обратный слэш (такие как \3), ссылаются на номера захватывающих групп в шаблоне.</p>
<p>Если вы собираетесь многократно выполнять подстановку по одному и тому же шаблону, рекомендуем скомпилировать его для увеличения производительности. Например:<br />
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
&gt;&gt;&gt; datepat.sub(r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
&gt;&gt;&gt;
</code></pre></p>
<p>В случае более сложных подстановок можно определить подстановочную функцию с обратным вызовом (callback function). Например:<br />
<pre><code class="python">&gt;&gt;&gt; from calendar import month_abbr
&gt;&gt;&gt; def change_date(m):
...   mon_name = month_abbr[int(m.group(1))]
...   return '{} {} {}'.format(m.group(2), mon_name, m.group(3))
...
&gt;&gt;&gt; datepat.sub(change_date, text)
'Today is 27 Nov 2012. PyCon starts 13 Mar 2013.'
&gt;&gt;&gt;
</code></pre></p>
<p>На вход подстановочному коллбэку в аргументе передается объект поиска совпадений, возвращенный функцией <em>match()</em> или <em>find()</em>. Используйте метод <em>.group()</em> для извлечения определенных частей совпадения. Функция должна возвращать текст замены (replacement text). </p>
<p>Если вы хотите знать, сколько подстановок было сделано в дополнение к получению текста замены (replacement text), используйте <em>re.subn()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; newtext, n = datepat.subn(r'\3-\1-\2', text)
&gt;&gt;&gt; newtext
'Today is 2012-11-27. PyCon starts 2013-3-13.'
&gt;&gt;&gt; n
2
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_74"><a name="user-content-_74" href="#_74" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>В поиске совпадений с помощью регулярных выражений не особо много чего-то дополнительного к показанному примеру с использованием метода <em>sub()</em>. Самое сложное — это составление шаблона регулярного выражения, и это мы оставляем читателю в качестве упражнений.</p>
<h2 id="26"><a name="user-content-26" href="#26" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.6. Поиск и замена текста без учета регистра</h2>
<h3 id="_75"><a name="user-content-_75" href="#_75" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам необходимо найти и, возможно, заменить текст, не обращая внимания на регистр букв.</p>
<h3 id="_76"><a name="user-content-_76" href="#_76" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для выполнения действий над текстом без учёта регистра вам понадобится модуль <em>re</em> и флаг <em>re.IGNORECASE</em>, который можно применять в различных операциях. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'UPPER PYTHON, lower python, Mixed Python'
&gt;&gt;&gt; re.findall('python', text, flags=re.IGNORECASE)
['PYTHON', 'python', 'Python']
&gt;&gt;&gt; re.sub('python', 'snake', text, flags=re.IGNORECASE)
'UPPER snake, lower snake, Mixed snake'
&gt;&gt;&gt;
</code></pre></p>
<p>Последний пример раскрывает ограничение: текст замены не будет совпадать по регистру с заменяемым текстом. Если вам нужно исправить такое поведение, используйте поддерживающую функцию:<br />
<pre><code class="python">def matchcase(word):
    def replace(m):
        text = m.group()
        if text.isupper():
            return word.upper()
        elif text.islower():
            return word.lower()
        elif text[0].isupper():
            return word.capitalize()
        else:
            return word
    return replace
</code></pre></p>
<p>А вот пример использования этой функции:<br />
<pre><code class="python">&gt;&gt;&gt; re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE)
'UPPER SNAKE, lower snake, Mixed Snake'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_77"><a name="user-content-_77" href="#_77" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>В простых случаях простого использования <em>re.INGNORECASE</em> достаточно для поиска совпадений без учёта регистра. Однако обратите внимание, что этого может оказаться недостаточно для некоторых случаев работы с Unicode, использующих выравнивание регистров (case folding). См. <strong>рецепт 2.10.</strong></p>
<h2 id="27"><a name="user-content-27" href="#27" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.7. Определение регулярных выражений для поиска кратчайшего совпадения</h2>
<h3 id="_78"><a name="user-content-_78" href="#_78" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы пытаетесь найти совпадение по текстовому шаблону, используя регулярное выражение, но оно находит самое длинное из всех возможных совпадений. Вы же хотите найти самое короткое из всех возможных.</p>
<h3 id="_79"><a name="user-content-_79" href="#_79" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Эта проблема часто возникает в шаблонах, которые пытаются найти текст, заключенный в пару открывающих и закрывающих разделителей (например, строка в кавычках). Рассмотрим следующий пример:<br />
<pre><code class="python">&gt;&gt;&gt; str_pat = re.compile(r'\&quot;(.*)\&quot;')
&gt;&gt;&gt; text1 = 'Computer says &quot;no.&quot;'
&gt;&gt;&gt; str_pat.findall(text1)
['no.']
&gt;&gt;&gt; text2 = 'Computer says &quot;no.&quot; Phone says &quot;yes.&quot;'
&gt;&gt;&gt; str_pat.findall(text2)
['no.&quot; Phone says &quot;yes.']
&gt;&gt;&gt;
</code></pre></p>
<p>В этом примере шаблон r&rsquo;"(.*)"&lsquo; пытается найти текст, заключенный в кавычки. Однако оператор * в регулярном выражении является жадным, поэтому поиск получается поиском самого длинного из возможных совпадений. Поэтому во втором примере с переменной <em>text2</em> неверно выполняется сопоставление двух строк в кавычках.</p>
<p>Чтобы исправить это, добавьте модификатор ? после оператора * в шаблоне:<br />
<pre><code class="python">&gt;&gt;&gt; str_pat = re.compile(r'\&quot;(.*?)\&quot;')
&gt;&gt;&gt; str_pat.findall(text2)
['no.', 'yes.']
&gt;&gt;&gt;
</code></pre><br />
Это делает поиск совпадений нежадным и выводит кратчайшее из найденных совпадений.</p>
<h3 id="_80"><a name="user-content-_80" href="#_80" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Этот рецепт решает одну из часто встречающихся при написании регулярных выражений с символом точки (.) задач. В шаблоне точка соотвествует любому символу за исключением символа новой строки. Однако если вы окружите точку открывающим и закрывающим текстом (таким как кавычки), поиск будет пытаться найти самое длинное из возможных совпадений. Это вызывает многочисленные случаи пропуска открывающего и закрывающего текста и включения в результаты самого длинного совпадения. Добавление ? сразу после таких операторов как * или + заставляет алгоритм поиска искать самое короткое совпадение.</p>
<h2 id="28"><a name="user-content-28" href="#28" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.8. Написание регулярного выражения для многострочных шаблонов</h2>
<h3 id="_81"><a name="user-content-_81" href="#_81" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Вы пытаетесь провести поиск по блоку текстов с использованием регулярного выражения, но вам нужно, чтобы совпадение охватывало несколько строк.</h3>
<h3 id="_82"><a name="user-content-_82" href="#_82" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Эта проблема обычно возникает в шаблонах, которые используют точку (.) для поиска совпадения с любым символом. Многие забывают, что точка не может совпадать с символом новой строки. Например, вы пытаетесь найти совпадения в комментариях в стиле языка С:<br />
<pre><code class="python">&gt;&gt;&gt; comment = re.compile(r'/\*(.*?)\*/')
&gt;&gt;&gt; text1 = '/* this is a comment */'
&gt;&gt;&gt; text2 = '''/* this is a
... multiline comment */
... '''
&gt;&gt;&gt;
&gt;&gt;&gt; comment.findall(text1)
[' this is a comment ']
&gt;&gt;&gt; comment.findall(text2)
[]
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы исправить проблему, вам нужно добавить поддержку символов новой строки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; comment = re.compile(r'/\*((?:.|\n)*?)\*/')
&gt;&gt;&gt; comment.findall(text2)
[' this is a\n multiline comment ']
&gt;&gt;&gt;
</code></pre></p>
<p>В этом шаблоне (?:.|\n) определяет незахватывающую группу (то есть выражение определяет группу для целей поиска совпадений, но эта группа не захватывается и не подсчитывается).</p>
<h3 id="_83"><a name="user-content-_83" href="#_83" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Функция <em>re.compile()</em> принимает полезный в данном случае флаг <em>re.DOTALL</em>. Он заставляет . в регулярном выражении совпадать с любыми символами, включая символ новой строки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)
&gt;&gt;&gt; comment.findall(text2)
[' this is a\n multiline comment ']
</code></pre></p>
<p>Использование флага <em>re.DOTALL</em> отличное работает в простых случаях, но это может быть проблематично при работе с очень сложными шаблонами или сочетанием отдельных регулярных выражений, которые должны объединяться друг с другом для токенизации (как описано в <strong>рецепте 2.18.</strong>) Если у вас есть выбор, обычно лучше определить шаблон регулярного выражения так, чтобы он работал правильно без необходимости в дополнительных флагах.</p>
<h2 id="29-unicode"><a name="user-content-29-unicode" href="#29-unicode" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.9. Приведение текста в Unicode к стандартному представлению (нормализация)</h2>
<h3 id="_84"><a name="user-content-_84" href="#_84" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы работате со строками Unicode и хотите убедиться, что все эти строки имеют одинаковое внутреннее представление.</p>
<h3 id="_85"><a name="user-content-_85" href="#_85" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В Unicode некоторые символы могут быть представлены несколькими допустимыми кодирующими последовательностями. Рассмотрим пример:<br />
<pre><code class="python">&gt;&gt;&gt; s1 = 'Spicy Jalape\u00f1o'
&gt;&gt;&gt; s2 = 'Spicy Jalapen\u0303o'
&gt;&gt;&gt; s1
'Spicy Jalapeño'
&gt;&gt;&gt; s2
'Spicy Jalapeño'
&gt;&gt;&gt; s1 == s2
False
&gt;&gt;&gt; len(s1)
14
&gt;&gt;&gt; len(s2)
15
&gt;&gt;&gt;
</code></pre></p>
<p>Здесь текст “Spicy Jalapeño” представлен в двух формах. Первая использует полноценный символ “ñ” (U+00F1). Второй использует латинскую букву “n”, за которой следует дополняющий символ “~” (U+0303).</p>
<p>Такие множественные представления становятся проблемой для программ, которые занимаются сравнением строк. Чтобы это исправить, вы должны сначала нормализовать текст, то есть привести его к стандартному представлению с помощью модуля <em>unicodedata</em>:<br />
<pre><code class="python">&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; t1 = unicodedata.normalize('NFC', s1)
&gt;&gt;&gt; t2 = unicodedata.normalize('NFC', s2)
&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; print(ascii(t1))
'Spicy Jalape\xf1o'

&gt;&gt;&gt; t3 = unicodedata.normalize('NFD', s1)
&gt;&gt;&gt; t4 = unicodedata.normalize('NFD', s2)
&gt;&gt;&gt; t3 == t4
True
&gt;&gt;&gt; print(ascii(t3))
'Spicy Jalapen\u0303o'
&gt;&gt;&gt;
</code></pre></p>
<p>Первый аргумент, передаваемый в <em>normalize()</em>, определяет режим нормализации текста. NFC означает, что символы должны быть полноценными (то есть по возможности использовать только одну кодирующую последовательность). NFD означает, что символы должны быть декомпозированными, то есть разделенными на комбинирующиеся символы. </p>
<p>Python также поддерживает режимы нормализации NFKC и NFKD, которые добавляют возможности совместимости, которые позволяют работать с определенными типами символов. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = '\ufb01'  # A single character
&gt;&gt;&gt; s
'ﬁ'
&gt;&gt;&gt; unicodedata.normalize('NFD', s)
'ﬁ'

# Notice how the combined letters are broken apart here
&gt;&gt;&gt; unicodedata.normalize('NFKD', s)
'fi'
&gt;&gt;&gt; unicodedata.normalize('NFKC', s)
'fi'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_86"><a name="user-content-_86" href="#_86" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Нормализация — это важная часть любой программы, в которой присутствует необходимость обработки текста в Unicode разумным и единообразным способом. Это особенно важно, когда обрабатываемые строки поступают из пользовательского ввода, кодировку которого вы практически никак не контролируете.</p>
<p>Нормализация (приведение) также может быть важной частью чистки и фильтрации текста. Предположим, например, что вы хотите удалить из текста диакритические знаки (возможно, для цели поиска совпадений):<br />
<pre><code class="python">&gt;&gt;&gt; t1 = unicodedata.normalize('NFD', s1)
&gt;&gt;&gt; ''.join(c for c in t1 if not unicodedata.combining(c))
'Spicy Jalapeno'
&gt;&gt;&gt;
</code></pre></p>
<p>Последний пример демонстрирует еще один важный аспект модуля <em>unicodedata</em>, а именно полезные функции для проверки принадлежности символов к определенным классам символов. Функция <em>combining()</em> проверяет, является ли символ объединяющимся. В этом модуле есть и другие функции для поиска символов определенных категорий, проверки цифр и так далее.</p>
<p>Unicode — весьма обширная тема. Для более подробной информации о нормализации посетите <a href="http://www.unicode.org/faq/normalization.html">соответствующую страницу</a> на сайте Unicode. Нед Батчелдер также разместил на своем сайте <a href="http://nedbatchelder.com/text/unipain.html">отличную презентацию</a> о решении проблем, связанных с Unicode в Python.  </p>
<h2 id="210-unicode"><a name="user-content-210-unicode" href="#210-unicode" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.10. Использование символов Unicode в регулярных выражениях</h2>
<h3 id="_87"><a name="user-content-_87" href="#_87" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы используете регулярные выражения для обработки текста, однако беспокоитесь о правильном взаимодействии с символами Unicode.</p>
<h3 id="_88"><a name="user-content-_88" href="#_88" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>По умолчанию модуль <em>re</em> уже имеет некоторые зачаточные представления о некоторых типах символов Unicode. Например, \d совпадает с любым цифровым символом Unicode:<br />
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; num = re.compile('\d+')
&gt;&gt;&gt; # ASCII digits
&gt;&gt;&gt; num.match('123')
&lt;_sre.SRE_Match object at 0x1007d9ed0&gt;

&gt;&gt;&gt; # Arabic digits
&gt;&gt;&gt; num.match('\u0661\u0662\u0663')
&lt;_sre.SRE_Match object at 0x101234030&gt;
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно включить специфические символы Unicode в шаблоны, вы можете использовать обычные последовательности для экранирования символов Unicode (например, \uFFFF или \UFFFFFFF). Например, вот регексп, который найдет совпадения со всеми символами в нескольких разных арабских страницах:<br />
<pre><code class="python">&gt;&gt;&gt; arabic = re.compile('[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+')
&gt;&gt;&gt;
</code></pre></p>
<p>При выполнении поиска совпадений следует нормализовывать и по возможноости чистить текст, приводя его к стандартной форме (см. <strong>рецепт 2.9.</strong>) Также нужно знать о некоторых специальных случаях. Например, рассмотрим поведение нечувствительного к регистру поиска совпадений при объединении с приведением к одному регистру:<br />
<pre><code class="python">&gt;&gt;&gt; pat = re.compile('stra\u00dfe', re.IGNORECASE)
&gt;&gt;&gt; s = 'straße'
&gt;&gt;&gt; pat.match(s)  # Matches
&lt;_sre.SRE_Match object at 0x10069d370&gt;
&gt;&gt;&gt; pat.match(s.upper())  # Doesn't match
&gt;&gt;&gt; s.upper()  # Case folds
'STRASSE'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_89"><a name="user-content-_89" href="#_89" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Смешивание Unicode и регулярных выражений — отличный способ взорвать себе голову. Если вы собираетесь серьезно в это погрузиться, установите не включенную в стандартную поставку Python библиотеку <a href="https://pypi.python.org/pypi/regex">regex</a>, в которой есть полная поддержка приведения текстов в Unicode к одному регистру, а также множество других интересных возможностей, включая аппроксимирующий поиск совпадений.</p>
<h2 id="211"><a name="user-content-211" href="#211" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.11. Убирание нежелательных символов из строк</h2>
<h3 id="_90"><a name="user-content-_90" href="#_90" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите убрать ненужные символы, такие как пробелы в начале, конце или середине текстовой строки.</p>
<h3 id="_91"><a name="user-content-_91" href="#_91" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Метод <em>strip()</em> можно использовать для срезания символов в начале или конце строки. <em>lstrip()</em> и <em>rstrip()</em> выполняют срезание слева и справа соответственно. По умолчанию они срезают пробел, однако им можно передать и другие символы. Например:<br />
<pre><code class="python">&gt;&gt;&gt; # Whitespace stripping
&gt;&gt;&gt; s = ' hello world  \n'
&gt;&gt;&gt; s.strip()
'hello world'
&gt;&gt;&gt; s.lstrip()
'hello world \n'
&gt;&gt;&gt; s.rstrip()
' hello world'

&gt;&gt;&gt;
&gt;&gt;&gt; # Character stripping
&gt;&gt;&gt; t = '-----hello====='
&gt;&gt;&gt; t.lstrip('-')
'hello====='
&gt;&gt;&gt; t.strip('-=')
'hello'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_92"><a name="user-content-_92" href="#_92" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Различные методы <em>strip()</em> часто используются при чтении и чистке данных для последующей обработки. Например, вы можете использовать их, чтобы избавиться от пробелов, удалить кавычки и т.д.</p>
<p>Обратите внимание, что срезание символов нельзя применить к тексту в середине строки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = ' hello world  \n'
&gt;&gt;&gt; s = s.strip()
&gt;&gt;&gt; s
'hello world'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно что-то сделать с внутренним пробелом, вам нужно применить другой приём, такой как использование метода <em>replace()</em> или подстановку с использованием регулярного выражения. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s.replace(' ', '')
'helloworld'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub('\s+', ' ', s)
'hello world'
&gt;&gt;&gt;
</code></pre></p>
<p>Часто вам нужно сочетать срезание символов с другими видами итерационной обработки, таким как чтением строк данных из файла. Если это так, то стоит применить выражение-генератор:<br />
<pre><code class="python">with open(filename) as f:
    lines = (line.strip() for line in f)
    for line in lines:
        ...
</code></pre></p>
<p>Здесь выражение <em>lines = (line.strip() for line in f)</em> работает как преобразователь данных. Это эффективно, потому что оно не читает данные из какого-либо временного списка. Оно просто создает итератор, где ко всем производимым строкам применена операция срезания символов.</p>
<p>Для более продвинутого срезания вам стоит обратиться к методу <em>translate()</em>. Детали вы найдете в следующем рецепте, где описана чистка строк.</p>
<h2 id="212"><a name="user-content-212" href="#212" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.12. Чистка строк</h2>
<h3 id="_93"><a name="user-content-_93" href="#_93" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Некий деятель ввел текст “pýtĥöñ” в форму на вашей веб-странице, и вы хотите как-то почистить эту строку.</p>
<h3 id="_94"><a name="user-content-_94" href="#_94" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Проблема чистки текста применяется к широкому спектру задач с использованием парсинга текста и обработки данных. На самом простом уровне вы можете использовать простые строковые функции (например, <em>str.upper()</em> и <em>str.lower()</em> для приведения текста к стандартному регистру). Простые замены с использованием <em>str.replace()</em> или <em>re.sub()</em> помогут справиться с удалением или изменением некоторых специфических последовательностей символов. Вы также можете нормализовать текст, используя функцию <em>unicodedata.normalize()</em>, как показано в <strong>рецепте 2.9.</strong></p>
<p>Однако вы можете пожелать сделать следующий шаг в процессе чистки. Предположим, например, что вы хотите удалить целые диапазоны символов или удалить диакритические знаки. Для этого вы можете обратиться к методу <em>str.translate()</em>. Предположим, у вас есть вот такая замусоренная строка:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'pýtĥöñ\fis\tawesome\r\n'
&gt;&gt;&gt; s
'pýtĥöñ\x0cis\tawesome\r\n'
&gt;&gt;&gt;
</code></pre></p>
<p>Первый шаг — удалить пробел. Сделаем небольшую таблицу перевода и задействуем <em>translate()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; remap = {
...   ord('\t') : ' ',
...   ord('\f') : ' ',
...   ord('\r') : None  # Deleted
... }
&gt;&gt;&gt; a = s.translate(remap)
&gt;&gt;&gt; a
'pýtĥöñ is awesome\n'
&gt;&gt;&gt;
</code></pre></p>
<p>Как вы можете увидеть, символы пробелов, такие как \t и \f, были приведены к единой форме. Символ возврата каретки \r был удален. </p>
<p>Вы можете продолжить идею и создать намного более крупные таблицы перевода. Например, давайте удалим все комбинирующиеся символы:<br />
<pre><code class="python">&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; import sys
&gt;&gt;&gt; cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode)
...   if unicodedata.combining(chr(c)))
...
&gt;&gt;&gt; b = unicodedata.normalize('NFD', a)
&gt;&gt;&gt; b
'pýtĥöñ is awesome\n'
&gt;&gt;&gt; b.translate(cmb_chrs)
'python is awesome\n'
&gt;&gt;&gt;
</code></pre></p>
<p>В последнем примере с помощью <em>dict.fromkeys()</em> был создан словарь, отображающий все комбинирующиеся символы Unicode на None. </p>
<p>Первоначальные вводные данные затем были нормализованы в декомпозированную форму с использованием <em>unicodedata.normalize()</em>. Далее функция <em>translate()</em> используется для удаления значков. Похожие приёмы могут быть использованы для удаления символов другого типа (например, управляющих символов). </p>
<p>Ещё один пример — таблица перевода, которая отображает все десятичные цифры Unicode на их эквиваленты в ASCII:<br />
<pre><code class="python">&gt;&gt;&gt; digitmap = { c: ord('0') + unicodedata.digit(chr(c))
...   for c in range(sys.maxunicode)
...   if unicodedata.category(chr(c)) == 'Nd' }
...
&gt;&gt;&gt; len(digitmap)
460
&gt;&gt;&gt; # Arabic digits
&gt;&gt;&gt; x = '\u0661\u0662\u0663'
&gt;&gt;&gt; x.translate(digitmap)
'123'
&gt;&gt;&gt;
</code></pre></p>
<p>Ещё один приём для чистки текста использует функции кодирования и декодирования ввода-вывода. Идея состоит в выполнении некоторой первичной очистки текста, а затем пропускании его через encode() и decode() для срезания символов или изменения. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a
'pýtĥöñ is awesome\n'
&gt;&gt;&gt; b = unicodedata.normalize('NFD', a)
&gt;&gt;&gt; b.encode('ascii', 'ignore').decode('ascii')
'python is awesome\n'
&gt;&gt;&gt;
</code></pre></p>
<p>Здесь процесс нормализации разложил исходный текст на символы вместе с отдельными комбинирующимися символами. Последовательное кодирование и декодирование в ASCII просто удаляет все эти эти символы. Естественно, это сработает только в том случае, если нашей целью было получение ASCII-представления.</p>
<h3 id="_95"><a name="user-content-_95" href="#_95" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Большой проблемой с чисткой текста может стать производительность. Общее правило: чем проще обработка, тем быстрее она работает. Для простых замен метод <em>str.replace()</em> часто оказывается самым быстрым способом — даже если вызывать его несколько раз. Например, чтобы вычистить пробелы, вы можете использовать такую программу:<br />
<pre><code class="python">def clean_spaces(s):
s = s.replace('\r', '')
s = s.replace('\t', ' ')
s = s.replace('\f', ' ')
return s
</code></pre></p>
<p>Если вы попробуете это, то обнаружите, что метод немного быстрее использования <em>translate()</em> или регулярных выражений.</p>
<p>С другой стороны, метод <em>translate()</em> очень быстр, если вам нужно выполнить любую нетривиальную операцию замены символов на другие символы или удаления символов.</p>
<p>Производительность — это нечто, что вам придется изучать в каждом конкретном приложении. К несчастью, невозможно предложить один приём, который будет работать лучше всего во всех возможных ситуациях, поэтому пробуйте разные подходы и измеряйте результы.</p>
<p>Хотя этот рецепт делает акцент на работе с текстом, похожие приёмы могут быть применены к последовательностям байтов.   </p>
<h2 id="213"><a name="user-content-213" href="#213" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.13. Выравнивание текстовых строк</h2>
<h3 id="_96"><a name="user-content-_96" href="#_96" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно отформатировать текст с применением некого выравнивания.</p>
<h3 id="_97"><a name="user-content-_97" href="#_97" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для базового выравнивания строк можно использовать методы <em>ljust()</em>, <em>rjust()</em> и <em>center()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text = 'Hello World'
&gt;&gt;&gt; text.ljust(20)
'Hello World '
&gt;&gt;&gt; text.rjust(20)
' Hello World'
&gt;&gt;&gt; text.center(20)
' Hello World '
&gt;&gt;&gt;
</code></pre></p>
<p>Все эти методы могут принимать опциональный символ заполнения. Например:<br />
<pre><code class="python">&gt;&gt;&gt; text.rjust(20,'=')
'=========Hello World'
&gt;&gt;&gt; text.center(20,'*')
'****Hello World*****'
&gt;&gt;&gt;
</code></pre></p>
<p>Функция <em>format()</em> также может быть использована для выравнивания. Вам нужно просто использовать символы &lt;, &gt; или ^ вместе с желаемой шириной. Например:<br />
<pre><code class="python">&gt;&gt;&gt; format(text, '&gt;20')
' Hello World'
&gt;&gt;&gt; format(text, '&lt;20')
'Hello World '
&gt;&gt;&gt; format(text, '^20')
' Hello World '
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите использовать в качестве заполняющего символа не пробел, определите его перед символом выравнивания:<br />
<pre><code class="python">&gt;&gt;&gt; format(text, '=&gt;20s')
'=========Hello World'
&gt;&gt;&gt; format(text, '*^20s')
'****Hello World*****'
&gt;&gt;&gt;
</code></pre></p>
<p>Эти коды форматирования могут быть также использованы с методом <em>format()</em> при обработке нескольких значений. Например:<br />
<pre><code class="python">&gt;&gt;&gt; '{:&gt;10s} {:&gt;10s}'.format('Hello', 'World')
' Hello World'
&gt;&gt;&gt;
</code></pre></p>
<p>У <em>format()</em> есть преимущество — он работает не только со строками. Он работает с любыми значениями, что делает его назначение очень широким. Например, вы можете использовать его с числами:<br />
<pre><code class="python">&gt;&gt;&gt; x = 1.2345
&gt;&gt;&gt; format(x, '&gt;10')
' 1.2345'
&gt;&gt;&gt; format(x, '^10.2f')
' 1.23 '
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_98"><a name="user-content-_98" href="#_98" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>В старых программах вы также можете увидеть, как для форматирования текста использовался оператор %. Например:<br />
<pre><code class="python">&gt;&gt;&gt; '%-20s' % text
'Hello World '
&gt;&gt;&gt; '%20s' % text
' Hello World'
&gt;&gt;&gt;
</code></pre></p>
<p>Однако в новых программах вы должны предпочитать функцию или метод <em>format()</em>. Онам намного мощнее оператора %. Более того, <em>format()</em> может применяться более широко, нежели строковые методы <em>ljlust()</em>, <em>rjust()</em> или <em>center()</em>, поскольку работает с любыми объектами. </p>
<p>За полным списком возможностей функции <em>format()</em> обратитесь к <a href="https://docs.python.org/3/library/string.html#formatspec">документации Python</a>.</p>
<h2 id="214"><a name="user-content-214" href="#214" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.14. Объединение и конкатенация строк</h2>
<h3 id="_99"><a name="user-content-_99" href="#_99" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно объединить много небольших строк в большую строку. </p>
<h3 id="_100"><a name="user-content-_100" href="#_100" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если строки, которые вы хотите объединить, находятся в последовательности или итерируемом объекте, самый быстрый способ — использовать метод <em>join()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; parts = ['Is', 'Chicago', 'Not', 'Chicago?']
&gt;&gt;&gt; ' '.join(parts)
'Is Chicago Not Chicago?'
&gt;&gt;&gt; ','.join(parts)
'Is,Chicago,Not,Chicago?'
&gt;&gt;&gt; ''.join(parts)
'IsChicagoNotChicago?'
&gt;&gt;&gt;
</code></pre></p>
<p>На первый взгляд синтаксис может показаться странным, однако операция <em>join()</em> относится к строковым методам. Объекты, которые вы хотите объединить, могут приходить из разнообразных последовательностей данных: (списки, кортежи, словари, файлы, множества или генераторы), поэтому было бы избыточным имплементировать метод <em>join()</em> для всех этих объектов. Поэтому вы просто задаете нужную строку-разделитель, а затем применяете метод <em>join()</em> для склеивания текстовых фрагментов.</p>
<p>Если вы просто объединяете несколько строк, неплохо сработает +:<br />
<pre><code class="python">&gt;&gt;&gt; a = 'Is Chicago'
&gt;&gt;&gt; b = 'Not Chicago?'
&gt;&gt;&gt; a + ' ' + b
'Is Chicago Not Chicago?'
&gt;&gt;&gt;
</code></pre></p>
<p>Оператор + также отлично работает в качестве замены более сложным операциям форматирования строк. Например:<br />
<pre><code class="python">&gt;&gt;&gt; print('{} {}'.format(a,b))
Is Chicago Not Chicago?
&gt;&gt;&gt; print(a + ' ' + b)
Is Chicago Not Chicago?
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы пытаетесь объединить строковые литералы в исходном коде, вы можете просто разместить их рядом без использования оператора +. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = 'Hello' 'World'
&gt;&gt;&gt; a
'HelloWorld'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_101"><a name="user-content-_101" href="#_101" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Объединение строк может показаться недостаточно сложным, чтобы писать про него целый рецепт, но часто эта область является критически важной для производительности. </p>
<p>Важно знать, что использование оператора + для объединения большого количества строк крайне неэффективно, посколько в памяти создаются копии, что прибавляет работы сборщику мусора. Никогда не пишите такой код для объединения строк:<br />
<pre><code class="python">s = ''
for p in parts:
    s += p
</code></pre></p>
<p>Это работает заметно медленнее метода <em>join()</em>, главным образом потому, что каждая += операция создает новый строковый объект. Намного лучше собрать все части и только затем объединить.</p>
<p>Еще один классный фокус из этой области — преобразование данных в строки и конкатенация с одновременным использованием выражения-генератора, как описано в <strong>рецепте 1.19.</strong> Например:<br />
<pre><code class="python">&gt;&gt;&gt; data = ['ACME', 50, 91.1]
&gt;&gt;&gt; ','.join(str(d) for d in data)
'ACME,50,91.1'
&gt;&gt;&gt;
</code></pre></p>
<p>Берегитесь ненужной конкатенации. Иногда программисты применяют конкатенацию там, где это не нужно. Например:<br />
<pre><code class="python">print(a + ':' + b + ':' + c)  # Ugly
print(':'.join([a, b, c]))  # Still ugly

print(a, b, c, sep=':')  # Better
</code></pre></p>
<p>Смешивание операций ввода-вывода и конкатенации строк — момент, с которым нужно быть очень внимательными. Наример, рассмотрим два фрагмента кода:<br />
<pre><code class="python"># Version 1 (string concatenation)
f.write(chunk1 + chunk2)

# Version 2 (separate I/O operations)
f.write(chunk1)
f.write(chunk2)
</code></pre></p>
<p>Если две строки невелики, первая может предложить намного большую производительность благодаря дороговизне системного вызова ввода-вывода. Однако если строки велики, вторая версия может быть более эффективной, поскольку в это случае не создается огромный промежуточный результат и не происходит копирования больших блоков памяти. Пробуйте на своих данных и выясняйте, что работает быстрее в вашем конкретном случае.</p>
<p>И последнее: если вы пишите код, который формирует результат из множества небольших строк, подумайте о том, чтобы оформить его как генератор, используя <em>yield</em> для производства фрагментов. Например:<br />
<pre><code class="python">def sample():
yield 'Is'
yield 'Chicago'
yield 'Not'
yield 'Chicago?'
</code></pre></p>
<p>Интересно, что этот подход не делает предположений по поводу того, как фрагменты будут собираться вместе. Например, вы можете просто объединить фрагменты с помощью <em>join()</em>:<br />
<pre><code class="python">text = ''.join(sample())
</code></pre></p>
<p>Или же вы можете перенаправить фрагменты на вывод:<br />
<pre><code class="python">for part in sample():
    f.write(part)
</code></pre></p>
<p>Или же вы можете создать некую гибридную схему, что умно с точки зрения операций ввода-вывода:<br />
<pre><code class="python">def combine(source, maxsize):
    parts = []
    size = 0
    for part in source:
        parts.append(part)
        size += len(part)
        if size &gt; maxsize:
            yield ''.join(parts)
            parts = []
            size = 0
    yield ''.join(parts)

for part in combine(sample(), 32768):
    f.write(part)
</code></pre></p>
<p>Ключевой момент в том, что первоначальный генератор не обязан знать деталей: он просто выдает части.</p>
<h2 id="215"><a name="user-content-215" href="#215" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.15. Интерполяция переменных в строках</h2>
<h2 id="_102"><a name="user-content-_102" href="#_102" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h2>
<p>Вы хотите создать строку, в которой на место переменных будут подставляться строковые представления значений этих переменных.</p>
<h3 id="_103"><a name="user-content-_103" href="#_103" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В Python нет прямой поддержки простой подстановки значений переменных в строках. Однако строковый метод <em>format()</em> предоставляет приближенную по смыслу возможность: Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = '{name} has {n} messages.'
&gt;&gt;&gt; s.format(name='Guido', n=37)
'Guido has 37 messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Если значения, которые должны быть подставлены, на самом деле находятся в переменных, вы можете использовать сочетание <em>format_map()</em> и <em>vars()</em>, как показано тут:<br />
<pre><code class="python">&gt;&gt;&gt; name = 'Guido'
&gt;&gt;&gt; n = 37
&gt;&gt;&gt; s.format_map(vars())
'Guido has 37 messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Стоит отметить, что <em>vars()</em> также работает с экземплярами. Например:<br />
<pre><code class="python">&gt;&gt;&gt; class Info:
...   def __init__(self, name, n):
...   self.name = name
...   self.n = n
...
&gt;&gt;&gt; a = Info('Guido',37)
&gt;&gt;&gt; s.format_map(vars(a))
'Guido has 37 messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Недостаток <em>format()</em> и <em>format(map)</em> в том, что они не могут аккуратно справиться с отсутствующими значениями. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s.format(name='Guido')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: 'n'
&gt;&gt;&gt;
</code></pre></p>
<p>Этого можно избежать путём определения альтернативный класс словаря с методом <em><strong>missing</strong>()</em>, как показано ниже:<br />
<pre><code class="python">class safesub(dict):
    def __missing__(self, key):
        return '{' + key + '}'
</code></pre></p>
<p>Теперь этот класс можно использовать, чтобы обернуть значения, которые подаются на вход в <em>format_map()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; del n  # Make sure n is undefined
&gt;&gt;&gt; s.format_map(safesub(vars()))
'Guido has {n} messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы обнаружите, что часто делаете такие вещи в своей программе, вы можете спрятать процесс подстановки переменных в небольшую функцию, которая использует так называемый “frame hack”. Например:<br />
<pre><code class="python">import sys
def sub(text):
    return text.format_map(safesub(sys._getframe(1).f_locals))
</code></pre></p>
<p>Теперь вы можете делать вот так:<br />
<pre><code class="python">&gt;&gt;&gt; name = 'Guido'
&gt;&gt;&gt; n = 37
&gt;&gt;&gt; print(sub('Hello {name}'))
Hello Guido
&gt;&gt;&gt; print(sub('You have {n} messages.'))
You have 37 messages.
&gt;&gt;&gt; print(sub('Your favorite color is {color}'))
Your favorite color is {color}
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_104"><a name="user-content-_104" href="#_104" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Отсутствие настоящей интерполяции переменных в Python привело к созданию разнообразных решений. В качестве альтернативы описанным выше решениям, вы иногда можете увидеть такой подход к форматированию строк:<br />
<pre><code class="python">&gt;&gt;&gt; name = 'Guido'
&gt;&gt;&gt; n = 37
&gt;&gt;&gt; '%(name) has %(n) messages.' % vars()
'Guido has 37 messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Или же вам могут попасться строки-темплейты:<br />
<pre><code class="python">&gt;&gt;&gt; import string
&gt;&gt;&gt; s = string.Template('$name has $n messages.')
&gt;&gt;&gt; s.substitute(vars())
'Guido has 37 messages.'
&gt;&gt;&gt;
</code></pre></p>
<p>Однако методы <em>format()</em> и <em>format_map()</em> являеются более современными, нежели эти альтернативы, и отдавать предпочтение нужно им. Преимущество использования <em>format()</em> заключается в том, что вы также получаете все возможности форматирования строк (выравнивание, отступы, нумерация и т.п.), что недоступно для альтернативных решений, таких как строковые объекты <em>Template</em>.</p>
<p>В этом рецепте нам также удалось показать несколько интересных продвинутых возможностей. Малоизвестный метод классов словарей и отображений <em><strong>missing()</strong></em> позволяет вам определить подход для работы с отсутствующими значениями. В классе <em>safesub</em> этот метод был определен таким образом, чтобы возвращать отсутствующие значения в форме заглушки (плейсхолдера). Вместо того, чтобы получить исключение <em>KeyException</em>, вы увидите отсутствующие значения появляющимися в строке-результате (что может оказаться полезным для дебаггинга).</p>
<p>Функция <em>sub()</em> использует <em>sys._getframe(1)</em> чтобы вернуть фрейм стека вызывающего. Отсюда атрибут <em>f_locals</em> доступен, чтобы получить локальные переменные. Стоит отметить, что игр с фреймами стека стоит избегать. Однако для утилитарных функций типа строковой подстановки это может оказаться полезным. Отдельно заметим, что <em>f_locals</em> — это словарь, который является копией локальных переменных в вызывающей функции. Хотя вы можете изменить содержимое <em>f_locals</em>, эти изменения не станут постоянными. Поэтому, хотя доступ другому фрейму стека и может показаться адским злом, невозможно случайно переписать переменные или изменить локальное окружение вызывающей функции (caller).   </p>
<h2 id="216"><a name="user-content-216" href="#216" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.16. Разбивка текста на фиксированное количество колонок</h2>
<h3 id="_105"><a name="user-content-_105" href="#_105" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть длинные строки, которые вы хотите переформатировать таким образом, чтобы они распределились по заданному пользователем количеству колонок.</p>
<h3 id="_106"><a name="user-content-_106" href="#_106" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Используйте модуль <em>textwrap</em> для переформатирования выводимого текста. Предположим, например, что у вас есть такая длинная строка:<br />
<pre><code class="python">s = &quot;Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under.&quot;
</code></pre></p>
<p>Вот как вы можете использовать модуль <em>textwrap</em> чтобы переформатировать её различным образом:<br />
<pre><code class="python">&gt;&gt;&gt; import textwrap
&gt;&gt;&gt; print(textwrap.fill(s, 70))
Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
not around the eyes, don't look around the eyes, look into my eyes,
you're under.

&gt;&gt;&gt; print(textwrap.fill(s, 40))
Look into my eyes, look into my eyes,
the eyes, the eyes, the eyes, not around
the eyes, don't look around the eyes,
look into my eyes, you're under.

&gt;&gt;&gt; print(textwrap.fill(s, 40, initial_indent=' '))
Look into my eyes, look into my
eyes, the eyes, the eyes, the eyes, not
around the eyes, don't look around the
eyes, look into my eyes, you're under.

&gt;&gt;&gt; print(textwrap.fill(s, 40, subsequent_indent=' '))
Look into my eyes, look into my eyes,
the eyes, the eyes, the eyes, not
around the eyes, don't look around
the eyes, look into my eyes, you're
under.
</code></pre></p>
<h3 id="_107"><a name="user-content-_107" href="#_107" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Модуль <em>textwrap</em> — это простой способ очистить текст — особенно если вы хотите, чтобы вывод соответствовал размерам терминала. К вопросу о размере терминала: вы можете получить его, используя <em>os.get_terminal_size()</em>. Например: <br />
<pre><code class="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.get_terminal_size().columns
80
&gt;&gt;&gt;
</code></pre></p>
<p>У метода <em>fill()</em> есть неколько дополнительных параметров, которые контролируют то, как он обращается с табуляцией, окончаниями предложений и т.д. За подробностями обратитесь к <a href="https://docs.python.org/3.3/library/textwrap.html#textwrap.TextWrapper">документации класса textwrap.TextWrapper</a>.</p>
<h2 id="217-html-xml-"><a name="user-content-217-html-xml-" href="#217-html-xml-" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.17. Работа с HTML- и XML-сущностями в тексте</h2>
<h3 id="_108"><a name="user-content-_108" href="#_108" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите заменить HTML- и XML-сущности, такие как <em>&entity;</em> или <em>&amp;#code;</em>, соответствующим текстом. Или же вам нужно произвести текст, но экранировать некоторые символы (например, &lt;, &gt; или &amp;).</p>
<h3 id="_109"><a name="user-content-_109" href="#_109" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если вы производите текст, довольно просто заменить спецсимволы типа &lt; или &gt; с помощью функции <em>html.escape()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.'
&gt;&gt;&gt; import html
&gt;&gt;&gt; print(s)
Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.
&gt;&gt;&gt; print(html.escape(s))
Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.

&gt;&gt;&gt; # Disable escaping of quotes
&gt;&gt;&gt; print(html.escape(s, quote=False))
Elements are written as &quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&quot;.
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите произвести текст в кодировке ASCII и вставить коды символов вместо отсутствующих в ASCII символов, вы можете использовать аргумент <em>errors=&rsquo;xmlcharrefreplace&rsquo;</em> с различными функциями ввода-вывода. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'Spicy Jalapeño'
&gt;&gt;&gt; s.encode('ascii', errors='xmlcharrefreplace')
b'Spicy Jalape&amp;#241;o'
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы заменить сущности в тексте, нужен другой подход. Если обрабатываете HTML или XML, попробуйте для начала настоящий парсер HTML или XML. Обычно эти инструменты автоматически позаботятся о замене значений во время парсинга, и вам не придётся об этом беспокоиться. </p>
<p>Если же по каким-то причинам вы получили голый текст с включением сущностей, и вы хотите заменить их вручную, вы сможете сделать это с помощью различных функций и методов, связанных с парсерами HTML и XML. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = 'Spicy &amp;quot;Jalape&amp;#241;o&amp;quot.'
&gt;&gt;&gt; from html.parser import HTMLParser
&gt;&gt;&gt; p = HTMLParser()
&gt;&gt;&gt; p.unescape(s)
'Spicy &quot;Jalapeño&quot;.'
&gt;&gt;&gt;

&gt;&gt;&gt; t = 'The prompt is &amp;gt;&amp;gt;&amp;gt;'
&gt;&gt;&gt; from xml.sax.saxutils import unescape
&gt;&gt;&gt; unescape(t)
'The prompt is &gt;&gt;&gt;'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_110"><a name="user-content-_110" href="#_110" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>О правильном экранировании спецсимволов при генерировании HTML или XML легко забыть. Это особенно верно, если вы генерируете вывод самостоятельно, используя <em>print()</em> или другую базовую функцию строкового форматирования. Есть простое решение — использовать функции типа <em>html.escape()</em>.</p>
<p>Если вам нужно произвести обратное преобразование текста, к вашим услугам различные фукции типа <em>xml.sax.saxutils.unescape()</em>. Однако мы все же рекомендуем использовать парсер. Например, если при обработке HTML и XML использовать такие парсеры как <em>html.parser</em> или <em>xml.etree.ElementTree</em>, они самостоятельно позаботятся о замене сущностей в тексте.</p>
<h2 id="218"><a name="user-content-218" href="#218" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.18. Токенизация текста</h2>
<h3 id="_111"><a name="user-content-_111" href="#_111" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть строка, которую вы хотите распарсить в поток токенов слева направо.</p>
<h3 id="_112"><a name="user-content-_112" href="#_112" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Предположим, у вас есть вот такая строка:<br />
<pre><code class="python">text = 'foo = 23 + 42 * 10'
</code></pre></p>
<p>Чтобы токенизировать строку, вам нужно нечто большее, чем простой поиск по шаблонам. Вам также нужен способ определить тип шаблона. Например, вы можете захотеть превратить строку в последовательность пар:<br />
<pre><code class="python">tokens = [('NAME', 'foo'), ('EQ','='), ('NUM', '23'), ('PLUS','+'),
('NUM', '42'), ('TIMES', '*'), ('NUM', 10')]
</code></pre></p>
<p>Для разрезания такого типа первым шагом должно быть определение всех возможных токенов, включая пробелы, с помошью шаблонов регулярных выражений, использующих именованные захватывающие группы:<br />
<pre><code class="python">import re
NAME = r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'
NUM  = r'(?P&lt;NUM&gt;\d+)'
PLUS = r'(?P&lt;PLUS&gt;\+)'
TIMES = r'(?P&lt;TIMES&gt;\*)'
EQ  = r'(?P&lt;EQ&gt;=)'
WS  = r'(?P&lt;WS&gt;\s+)'

master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))
</code></pre></p>
<p>В этих шаблонах условие <em>?P<TOKENNAME></em> используется для присваивания имени шаблону. Это мы используем позже.</p>
<p>Далее, для собственно токенизации, используем малоизвестный метод объектов шаблонов <em>scanner()</em>. Этот метод создает объект сканера, в котором повторно вызывается шаг <em>match()</em> для предоставленного текста, выполняя один поиск совпадения за раз. Вот интерактивный пример работы объекта сканера:<br />
<pre><code class="python">&gt;&gt;&gt; scanner = master_pat.scanner('foo = 42')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object at 0x100677738&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('NAME', 'foo')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object at 0x100677738&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('WS', ' ')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object at 0x100677738&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('EQ', '=')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object at 0x100677738&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('WS', ' ')
&gt;&gt;&gt; scanner.match()
&lt;_sre.SRE_Match object at 0x100677738&gt;
&gt;&gt;&gt; _.lastgroup, _.group()
('NUM', '42')
&gt;&gt;&gt; scanner.match()
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы взять это приём и использовать в программе, он должен быть очищен и упакован в генератор:<br />
<pre><code class="python">from collections import namedtuple

Token = namedtuple('Token', ['type','value'])

def generate_tokens(pat, text):
    scanner = pat.scanner(text)
        for m in iter(scanner.match, None):
            yield Token(m.lastgroup, m.group())

# Example use
for tok in generate_tokens(master_pat, 'foo = 42'):
    print(tok)

# Produces output
# Token(type='NAME', value='foo')
# Token(type='WS', value=' ')
# Token(type='EQ', value='=')
# Token(type='WS', value=' ')
# Token(type='NUM', value='42')
</code></pre></p>
<p>Если вы хотите как-то отфильтровать поток токенов, вы можете либо определить больше генераторов, либо использовать выражение-генератор. Например, вот так можно отфильтровать все токены-пробелы:<br />
<pre><code class="python">tokens = (tok for tok in generate_tokens(master_pat, text)
    if tok.type != 'WS')
for tok in tokens:
    print(tok)
</code></pre></p>
<h3 id="_113"><a name="user-content-_113" href="#_113" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Токенизация часто является первым шагом более продвинутого парсинга и обработки текста. Чтобы использовать показанные приёмы сканирования, нужно держать в уме несколько важных моментов. Во-первых, вы должны убедиться, что вы определили соответствующие шаблоны регулярных выражений для всех возможных текстовых последовательностей, которые могут встретиться во входных данных. Если встретится текст, для которого нельзя найти совпадение, сканирование просто остановится. Вот почему необходимо было определить токен пробела (WS) в примере выше.</p>
<p>Порядок токенов в главном регулярном выражении также важен. При поиске совпадений регулярное выражение пытается отыскать совпадения с шаблонами в заданном порядке. Поэтому если шаблон окажется подстрокой более длинного шаблона, вы должны убедиться, что более длинный шаблон вписан в выражение первым. Например:<br />
<pre><code class="python">LT = r'(?P&lt;LT&gt;&lt;)'
LE = r'(?P&lt;LE&gt;&lt;=)'
EQ = r'(?P&lt;EQ&gt;=)'

master_pat = re.compile('|'.join([LE, LT, EQ]))  # Correct
# master_pat = re.compile('|'.join([LT, LE, EQ])) # Incorrect
</code></pre></p>
<p>Второй шаблон неправильный, потому что он будет отыскивать совпадение с &lt;=, поскольку за токеном LT следует токен EQ, а не LE.</p>
<p>И последнее: вы должны следить за шаблонами, формирующими подстроки. Предположим, например, что у вас есть два шаблона:<br />
<pre><code class="python">PRINT = r'(P&lt;PRINT&gt;print)'
NAME  = r'(P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'

master_pat = re.compile('|'.join([PRINT, NAME]))

for tok in generate_tokens(master_pat, 'printer'):
    print(tok)

# Outputs :
# Token(type='PRINT', value='print')
# Token(type='NAME', value='er')
</code></pre></p>
<p>Для более продвинутого токенизирования вы можете обратиться к пакетам <a href="http://pyparsing.wikispaces.com/">PyParsing</a> или <a href="http://www.dabeaz.com/ply/index.html">PLY</a>. Пример использования PLY вы найдете в следующем рецепте.</p>
<h2 id="219"><a name="user-content-219" href="#219" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.19. Написание простого парсера на основе метода рекурсивного спуска</h2>
<h3 id="_114"><a name="user-content-_114" href="#_114" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно распарсить текст в соответствии с грамматическими правилами и выполнить действия или построить абстрактное синтаксическое дерево, представляющее входные данные.</p>
<h3 id="_115"><a name="user-content-_115" href="#_115" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В этой задаче мы сосредоточены на парсинге текста в соответствии с некоторой определенной грамматикой. Чтобы это сделать, вы должны начать с формальной спецификации грамматики в форме BNF (БНФ, форма Бэкуса — Наура) или EBNF (РБНФ, расширенная форма Бэкуса — Наура). Например, грамматика для простых арифметических выражений может выглядеть так:</p>
<pre><code>expr ::= expr + term
    | expr - term
    | term

term ::= term * factor
    | term / factor
    | factor

factor ::= ( expr )
    | NUM
</code></pre>
<p>А вот альтернативная форма РБНФ:</p>
<pre><code>expr ::= term { (+|-) term }*

term ::= factor { (*|/) factor }*

factor ::= ( expr )
    | NUM
</code></pre>
<p>В РБНФ части правил, заключенные в { &hellip; }* являются необязательными. * означает ноль и более повторений (то есть имеет такое значение, как и в регулярных выражениях).</p>
<p>Теперь, если вы незнакомы с механизмом работы БНФ, думайте о ней как об определении правил замены или подстановки, где символы слева могут быть заменены символами справа (или наоборот). В общем, во время парсинга вы пытаетесь сопоставить входящий текст с грамматикой, делая различные подстановки и расширения с использованием БНФ. Чтобы проиллюстрировать это, предположим, что вы парсите выражение 3 + 4 * 5. Это выражение должно быть сначала разбито на поток токенов с использованием описанных в <strong>рецепте 2.18.</strong> приёмов. Результатом будет последовательность токенов:</p>
<pre><code>NUM + NUM * NUM
</code></pre>
<p>С этого момента парсинг начинает пытаться сопоставить грамматику с входящими токенами, делая подстановки:</p>
<pre><code>expr
expr ::= term { (+|-) term }*
expr ::= factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM { (*|/) factor }* { (+|-) term }*
expr ::= NUM { (+|-) term }*
expr ::= NUM + term { (+|-) term }*
expr ::= NUM + factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM { (*|/) factor}* { (+|-) term }*
expr ::= NUM + NUM * factor { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM * NUM { (*|/) factor }* { (+|-) term }*
expr ::= NUM + NUM * NUM { (+|-) term }*
expr ::= NUM + NUM * NUM
</code></pre>
<p>Чтобы пройти по всем шагам подстановки и разобраться, придётся потратить время, но в целом они работают так: смотрят на входящие данные и пытаются сопоставить их с правилами грамматики. Первый входящий токен — это NUM, поэтому подстановки сначала сосредотачиваются на поиске совпадений с этой частью. Когда совпадение найдено, внимание переходит к следующему токену + и т.д. Некоторые части правой стороны (например, { (*/) factor }*) иcчезают, когда определено, что они не совпадают со следующим токеном. Парсинг проходит успешно, если правая сторона достаточно полна, чтобы охватить все входящие токены. </p>
<p>Со всей вышеизложенной вводной информацией перейдем к простому рецепту построения «выполнителя» выражений, работающего по методу рекурсивного спуска:<br />
<pre><code class="python">import re
import collections

# Token specification
NUM  = r'(?P&lt;NUM&gt;\d+)'
PLUS  = r'(?P&lt;PLUS&gt;\+)'
MINUS  = r'(?P&lt;MINUS&gt;-)'
TIMES  = r'(?P&lt;TIMES&gt;\*)'
DIVIDE = r'(?P&lt;DIVIDE&gt;/)'
LPAREN = r'(?P&lt;LPAREN&gt;\()'
RPAREN = r'(?P&lt;RPAREN&gt;\))'
WS  = r'(?P&lt;WS&gt;\s+)'

master_pat = re.compile('|'.join([NUM, PLUS, MINUS, TIMES,
                                  DIVIDE, LPAREN, RPAREN, WS]))

# Tokenizer
Token = collections.namedtuple('Token', ['type','value'])

def generate_tokens(text):
    scanner = master_pat.scanner(text)
    for m in iter(scanner.match, None):
        tok = Token(m.lastgroup, m.group())
        if tok.type != 'WS':
            yield tok

# Parser
class ExpressionEvaluator:
    '''
    Implementation of a recursive descent parser. Each method
    implements a single grammar rule. Use the ._accept() method
    to test and accept the current lookahead token. Use the ._expect()
    method to exactly match and discard the next token on on the input
    (or raise a SyntaxError if it doesn't match).
    '''

    def parse(self,text):
        self.tokens = generate_tokens(text)
        self.tok = None  # Last symbol consumed
        self.nexttok = None  # Next symbol tokenized
        self._advance()  # Load first lookahead token
        return self.expr()

    def _advance(self):
        'Advance one token ahead'
        self.tok, self.nexttok = self.nexttok, next(self.tokens, None)

    def _accept(self,toktype):
        'Test and consume the next token if it matches toktype'
        if self.nexttok and self.nexttok.type == toktype:
            self._advance()
            return True
        else:
            return False

    def _expect(self,toktype):
        'Consume next token if it matches toktype or raise SyntaxError'
        if not self._accept(toktype):
            raise SyntaxError('Expected ' + toktype)

    # Grammar rules follow

    def expr(self):
        &quot;expression ::= term { ('+'|'-') term }*&quot;

        exprval = self.term()
        while self._accept('PLUS') or self._accept('MINUS'):
            op = self.tok.type
            right = self.term()
            if op == 'PLUS':
                exprval += right
            elif op == 'MINUS':
                exprval -= right
            return exprval

    def term(self):
        &quot;term ::= factor { ('*'|'/') factor }*&quot;

        termval = self.factor()
        while self._accept('TIMES') or self._accept('DIVIDE'):
            op = self.tok.type
            right = self.factor()
            if op == 'TIMES':
                termval *= right
            elif op == 'DIVIDE':
                termval /= right
        return termval

    def factor(self):
        &quot;factor ::= NUM | ( expr )&quot;

        if self._accept('NUM'):
            return int(self.tok.value)
        elif self._accept('LPAREN'):
            exprval = self.expr()
            self._expect('RPAREN')
            return exprval
        else:
            raise SyntaxError('Expected NUMBER or LPAREN')
</code></pre></p>
<p>Вот пример интерактивного использования класса ExpressionEvaluator:<br />
<pre><code class="python">&gt;&gt;&gt; e = ExpressionEvaluator()
&gt;&gt;&gt; e.parse('2')
2
&gt;&gt;&gt; e.parse('2 + 3')
5
&gt;&gt;&gt; e.parse('2 + 3 * 4')
14
&gt;&gt;&gt; e.parse('2 + (3 + 4) * 5')
37
&gt;&gt;&gt; e.parse('2 + (3 + * 4)')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;exprparse.py&quot;, line 40, in parse
        return self.expr()
    File &quot;exprparse.py&quot;, line 67, in expr
        right = self.term()
    File &quot;exprparse.py&quot;, line 77, in term
        termval = self.factor()
    File &quot;exprparse.py&quot;, line 93, in factor
        exprval = self.expr()
    File &quot;exprparse.py&quot;, line 67, in expr
        right = self.term()
    File &quot;exprparse.py&quot;, line 77, in term
        termval = self.factor()
    File &quot;exprparse.py&quot;, line 97, in factor
        raise SyntaxError(&quot;Expected NUMBER or LPAREN&quot;)
SyntaxError: Expected NUMBER or LPAREN
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите сделать что-то другое, а не только простое вычисление, вам нужно изменить класс ExpressionEvaluator. Например, вот альтернативная имплементация, которая конструирует простое дерево разбора (парсинга):<br />
<pre><code class="python">class ExpressionTreeBuilder(ExpressionEvaluator):
    def expr(self):
        &quot;expression ::= term { ('+'|'-') term }&quot;

        exprval = self.term()
        while self._accept('PLUS') or self._accept('MINUS'):
            op = self.tok.type
            right = self.term()
            if op == 'PLUS':
                exprval = ('+', exprval, right)
            elif op == 'MINUS':
                exprval = ('-', exprval, right)
        return exprval

    def term(self):
        &quot;term ::= factor { ('*'|'/') factor }&quot;

        termval = self.factor()
        while self._accept('TIMES') or self._accept('DIVIDE'):
            op = self.tok.type
            right = self.factor()
            if op == 'TIMES':
                termval = ('*', termval, right)
            elif op == 'DIVIDE':
                termval = ('/', termval, right)
        return termval

    def factor(self):
        'factor ::= NUM | ( expr )'

        if self._accept('NUM'):
            return int(self.tok.value)
        elif self._accept('LPAREN'):
            exprval = self.expr()
            self._expect('RPAREN')
            return exprval
        else:
            raise SyntaxError('Expected NUMBER or LPAREN')
</code></pre></p>
<p>Вот как это работает:<br />
<pre><code class="python">&gt;&gt;&gt; e = ExpressionTreeBuilder()
&gt;&gt;&gt; e.parse('2 + 3')
('+', 2, 3)
&gt;&gt;&gt; e.parse('2 + 3 * 4')
('+', 2, ('*', 3, 4))
&gt;&gt;&gt; e.parse('2 + (3 + 4) * 5')
('+', 2, ('*', ('+', 3, 4), 5))
&gt;&gt;&gt; e.parse('2 + 3 + 4')
('+', ('+', 2, 3), 4)
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_116"><a name="user-content-_116" href="#_116" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Парсинг — это обширная тема, освоение которой обычно занимает у студентов первые три недели курса изучения компиляторов. Если вы ищите, где бы почерпнуть знания о грамматиках, алгоритмах разбор и прочую подобную информацию, обратитесь к книгам о компиляторах. Нет нужды говорить, что всё это втиснуть в эту книгу просто невозможно.</p>
<p>Тем не менее, общая идея парсера на основе рекурсивного спуска проста. Для начала вы берете каждое правило грамматики и превращаете его в функцию или метод. Если ваша грамматика выглядит так:</p>
<pre><code>expr ::= term { ('+'|'-') term }*
term ::= factor { ('*'|'/') factor }*
factor ::= '(' expr ')'
| NUM
</code></pre>
<p>То вы начинаете с превращения её в такой набор методов:<br />
<pre><code class="python">class ExpressionEvaluator:
    ...
    def expr(self):
        ...
    def term(self):
        ...
    def factor(self):
        ...
</code></pre></p>
<p>Задача каждого метода проста: он должен пройти слева направо по каждой части грамматического правила, потребляя токены в процессе. Цель метода — либо потребить правило, либо сгенерировать синтаксическую ошибку в случае застревания. Чтобы реализовать это, применяются следующие приёмы:</p>
<ul>
<li>Если следующий символ в правиле является именем другого грамматического правила (например, term или factor), вы просто вызываете метод с этим именем. Это  «спуск» алгоритма — управление спускается в другое грамматическое правило. Иногда правила могут использовать вызовы методов, которые уже выполняются (например, вызов expr в правиле factor ::= &lsquo;(&lsquo; expr &lsquo;)&rsquo;). Это «рекурсивность» алгоритма.  </li>
<li>Если следующий символ в правиле должен быть конкретным символом (например, (), вы смотрите на следующий токен и проверяете на точное совпадение. Если он не совпадает, то это синтаксическая ошибка. В этом рецепте для выполнения этих шагов используется метод <em>_expect()</em>.</li>
<li>Если следующий символ в правиле может соответствовать нескольким возможным выборам (например, + или -), вы должны проверить следующий токен на каждую из этих возможностей и продвигаться вперед только в том случае, если совпадение найдено. В этом рецепте за это отвечает метод <em>_accept()</em>. Он похож на более слабую версию метода <em>_expect()</em> — в том отношении, что он продвинется вперед только если совпадение найдено, но если нет, то он просто отступает, не возбуждая ошибку (что позволяет сделать другие проверки).</li>
<li>Для грамматических правил с повторяющимися частями (как, например, в правиле expr ::= term { (&lsquo;+&lsquo;|&rsquo;-&lsquo;) term }*), повторение имплементируется циклом <em>while</em>. Тело цикла будет в общем собирать или обрабатывать все повторяющиеся значения, пока они не закончатся.</li>
<li>Если грамматическое правило потреблено, каждый метод возвращает некий результат тому, кто его вызывал. Так значения передаются во время парсинга. Например, в «вычислителе» выражений возвращаемые значения будут представлять частичные результаты разбираемого выражения. В конце концов они все объединятся в высшем методе грамматического правила, который будет выполнен.</li>
</ul>
<p>Хотя здесь мы показали простой пример, парсеры на основе рекурсивного спуска могут быть использованы для создания весьма сложных парсеров. Например, код самого Python интерпретируется парсером на основе метода рекурсивного спуска. Если вы заинтересовались, вы можете залезть в файл Grammar/Grammar в исходном коде Python и взглянуть на грамматику под капотом. При всём при этом, конечно, в ручном создании парсеров множество ограничений и ловушек.</p>
<p>Одно из таких ограничений парсеров на основе рекурсивного спуска заключается в том, что они не могут быть написаны для грамматических правил, использующих левую рекурсию. Предположим, например, что вам нужно перевести такое правило:</p>
<pre><code>items ::= items ',' item
| item
</code></pre>
<p>Чтобы сделать это, вы могли бы использовать метод items():<br />
<pre><code class="python">def items(self):
    itemsval = self.items()
    if itemsval and self._accept(','):
        itemsval.append(self.item())
    else:
        itemsval = [ self.item() ]
</code></pre></p>
<p>Единственная проблема в том, что это не работает. Такой код вылетит с ошибкой бесконечной рекурсии. </p>
<p>Вы можете также столкнуться с хитрыми проблемами, касающимися самих грамматических правил. Например, вы можете поразмышлять над тем, могут ли выражения быть описаны вот такой более простой грамматикой:</p>
<pre><code>expr ::= factor { ('+'|'-'|'*'|'/') factor }*

factor ::= '(' expression ')'
| NUM
</code></pre>
<p>Эта грамматика технически «работает», но она не соблюдает стандартные правила порядка вычисления арифметических выражений. Например, для выражения “3 + 4 * 5” оно выдаст результат 35 вместо правильного 23. Чтобы решить эту проблему, нужно использовать отдельные правила expr и term.</p>
<p>Для по-настоящему сложных грамматик лучше использовать инструменты парсинга типа <a href="http://pyparsing.wikispaces.com/">PyParsing</a> или <a href="http://www.dabeaz.com/ply/index.html">PLY</a>. Вот как выглядит код «вычислителя» выражений, созданный с применением PLY:<br />
<pre><code class="python">from ply.lex import lex
from ply.yacc import yacc

# Token list
tokens = [ 'NUM', 'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'LPAREN', 'RPAREN' ]

# Ignored characters
t_ignore = ' \t\n'

# Token specifications (as regexs)
t_PLUS  = r'\+'
t_MINUS  = r'-'
t_TIMES  = r'\*'
t_DIVIDE = r'/'
t_LPAREN = r'\('
t_RPAREN = r'\)'

# Token processing functions
def t_NUM(t):
    r'\d+'
    t.value = int(t.value)
    return t

# Error handler
def t_error(t):
    print('Bad character: {!r}'.format(t.value[0]))
    t.skip(1)

# Build the lexer
lexer = lex()

# Grammar rules and handler functions
def p_expr(p):
    '''
    expr : expr PLUS term
    | expr MINUS term
    '''
    if p[2] == '+':
        p[0] = p[1] + p[3]
    elif p[2] == '-':
        p[0] = p[1] - p[3]

def p_expr_term(p):
    '''
    expr : term
    '''
    p[0] = p[1]


def p_term(p):
    '''
    term : term TIMES factor
    | term DIVIDE factor
    '''
    if p[2] == '*':
        p[0] = p[1] * p[3]
    elif p[2] == '/':
        p[0] = p[1] / p[3]

def p_term_factor(p):
    '''
    term : factor
    '''
    p[0] = p[1]

def p_factor(p):
    '''
    factor : NUM
    '''
    p[0] = p[1]


def p_factor_group(p):
    '''
    factor : LPAREN expr RPAREN
    '''
    p[0] = p[2]

def p_error(p):
    print('Syntax error')

parser = yacc()
</code></pre></p>
<p>В этой программе вы найдете, что всё определено так же, как и ранее написанном парсере, но на намного более высоком уровне. Вы просто пишете регулярные выражения для токенов и высокоуровневые функции-обработчики, которые выполняются, когда возникают совпадения по различным правилам грамматики. А вся механика работы парсера, приёма токенов и так далее полностью реализована в библиотеке. </p>
<p>Вот пример использования созданного объекта парсера:<br />
<pre><code class="python">&gt;&gt;&gt; parser.parse('2')
2
&gt;&gt;&gt; parser.parse('2+3')
5
&gt;&gt;&gt; parser.parse('2+(3+4)*5')
37
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите сделать свою программерскую жизнь более захватывающей, начните писать парсеры и компиляторы. Повторимся, книги про компиляторы предлагают кучу низкоуровневых подробностей и теории. Множество полезных ресурсов и всякой информации вы также найдете в сети. А в Python есть модуль <em>ast</em>, на который также стоит посмотреть.</p>
<h2 id="220"><a name="user-content-220" href="#220" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2.20. Выполнение текстовых операций над байтовыми строками</h2>
<h3 id="_117"><a name="user-content-_117" href="#_117" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите выполнить стандартные текстовые операции (срезание символов, поиск, замену) над строками байтов.</p>
<h3 id="_118"><a name="user-content-_118" href="#_118" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Байтовые строки поддерживают большую часть тех же встроенных операций, что и текстовые строки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; data = b'Hello World'
&gt;&gt;&gt; data[0:5]
b'Hello'
&gt;&gt;&gt; data.startswith(b'Hello')
True
&gt;&gt;&gt; data.split()
[b'Hello', b'World']
&gt;&gt;&gt; data.replace(b'Hello', b'Hello Cruel')
b'Hello Cruel World'
&gt;&gt;&gt;
</code></pre></p>
<p>Такие операции можно проделать и над байтовыми массивами:<br />
<pre><code class="python">&gt;&gt;&gt; data = bytearray(b'Hello World')
&gt;&gt;&gt; data[0:5]
bytearray(b'Hello')
&gt;&gt;&gt; data.startswith(b'Hello')
True
&gt;&gt;&gt; data.split()
[bytearray(b'Hello'), bytearray(b'World')]
&gt;&gt;&gt; data.replace(b'Hello', b'Hello Cruel')
bytearray(b'Hello Cruel World')
&gt;&gt;&gt;
</code></pre></p>
<p>Вы можете просто применить к байтовым строкам поиск совпадений с помощью регулярных выражений, но сами шаблоны должны быть определены как байты. Например:<br />
<pre><code class="python">&gt;&gt;&gt;
&gt;&gt;&gt; data = b'FOO:BAR,SPAM'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.split('[:,]',data)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;/usr/local/lib/python3.3/re.py&quot;, line 191, in split
        return _compile(pattern, flags).split(string, maxsplit)
TypeError: can't use a string pattern on a bytes-like object

&gt;&gt;&gt; re.split(b'[:,]',data)  # Notice: pattern as bytes
[b'FOO', b'BAR', b'SPAM']
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_119"><a name="user-content-_119" href="#_119" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Практически все доступные для текстовых строк операции будут работать и на байтовых строках. Однако есть несколько заметных отличий, о которых нужно знать. Во-первых, при индексировании байтовых строк мы получаем целые числа, а не символы. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = 'Hello World'  # Text string
&gt;&gt;&gt; a[0]
'H'
&gt;&gt;&gt; a[1]
'e'
&gt;&gt;&gt; b = b'Hello World'  # Byte string
&gt;&gt;&gt; b[0]
72
&gt;&gt;&gt; b[1]
101
&gt;&gt;&gt;
</code></pre></p>
<p>Эта разница в семантике может воздействовать на программы, которые пытаются обработать байтовые данные так же, как и текстовые.</p>
<p>Во-вторых, байтовые строки не предоставляют красивые строковые представления и не выводятся в симпатичном виде, если сначала не проведено декодирование в текстовую строку. Например:<br />
<pre><code class="python">&gt;&gt;&gt; s = b'Hello World'
&gt;&gt;&gt; print(s)
b'Hello World' # Observe b'...'
&gt;&gt;&gt; print(s.decode('ascii'))
Hello World
&gt;&gt;&gt;
</code></pre></p>
<p>Строковые операции форматирования также недоступны для байтовых строк.<br />
<pre><code class="python">&gt;&gt;&gt; b'%10s %10d %10.2f' % (b'ACME', 100, 490.1)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for %: 'bytes' and 'tuple'

&gt;&gt;&gt; b'{} {} {}'.format(b'ACME', 100, 490.1)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'bytes' object has no attribute 'format'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите применить какое-то форматирование к байтовой строке, это должно быть проделано с помощью обычных текстовых строк и последующего кодирования. Например:<br />
<pre><code class="python">&gt;&gt;&gt; '{:10s} {:10d} {:10.2f}'.format('ACME', 100, 490.1).encode('ascii')
b'ACME 100 490.10'
&gt;&gt;&gt;
</code></pre></p>
<p>И, наконец, вы должны знать, что использование байтовых строк может изменить семантику некоторых операций — особенно тех, что относятся к файловой системе. Например, если вы предоставляете имя файла закодированным в байтовую строку, а не в текстовую, это обычно отключает кодирование и декодирование имени файла. Например:<br />
<pre><code class="python">&gt;&gt;&gt; # Write a UTF-8 filename
&gt;&gt;&gt; with open('jalape\xf1o.txt', 'w') as f:
...   f.write('spicy')
...

&gt;&gt;&gt; # Get a directory listing
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.listdir('.')  # Text string (names are decoded)
['jalapeño.txt']

&gt;&gt;&gt; os.listdir(b'.')  # Byte string (names left as bytes)
[b'jalapen\xcc\x83o.txt']
&gt;&gt;&gt;
</code></pre></p>
<p>Посмотрите, как в последней части этого примера передача имени каталога в виде байтовой строки вызывает возврат имен файлов в виде недекодированных байтов. Имя файла, показанное в списке содержимого каталога, содержит «сырую» кодировку UTF-8. См. <strong>рецепт 5.15.</strong>, в нем обсуждается вопрос работы с именами файлов, имеющий отношение к этому случаю.</p>
<p>Некоторые программисты могут склоняться к использованию байтовых строк в качестве альтернативы текстовым из-за возможного выигрыша в производительности. Да, операции над байтами могут быть немного более эффективными, чем работа с текстом (из-за оверхеда на Unicode), однако такой подход приводит к грязному и неидиоматическому году. Вы будете часто сталкиваться с тем, что байтовые строки не очень хорошо сочетаются с другими частями Python, и вы закончите тем, что будете вручную выполнять всевозможные операции кодирования-декодирования, чтобы всё работало. Так что если вы работаете с текстом, используйте обычные текстовые строки, а не байтовые.</p>
<h1 id="3"><a name="user-content-3" href="#3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3. Числа, даты и время</h1>
<p>В Python легко выполненять математические вычисления с целыми числами и числами с плавающей точкой. Однако если вам нужно работать с дробями, массивами или датами и временем, придется приложить больше усилий. Эта глава фокусируется как раз на таких темах.</p>
<h2 id="31"><a name="user-content-31" href="#31" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.1. Округление числовых значений</h2>
<h3 id="_120"><a name="user-content-_120" href="#_120" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите округлить число с плавающей точкой до заданного количества знаков после точки.</p>
<h3 id="_121"><a name="user-content-_121" href="#_121" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для простого округления используйте встроенную функцию <em>round(value, ndigits)</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; round(1.23, 1)
1.2
&gt;&gt;&gt; round(1.27, 1)
1.3
&gt;&gt;&gt; round(-1.27, 1)
-1.3
&gt;&gt;&gt; round(1.25361,3)
1.254
&gt;&gt;&gt;
</code></pre></p>
<p>Когда значение попадает точно между двух возможных выборов для округления, эта функция будет округлять к ближайшему чётному значению. То есть 1.5 или 2.5 будут округлены до 2.</p>
<p>Количество знаков, которое передается функции <em>round()</em>, может быть отрицательным. В этом случае округление будет идти до десятков, сотен, тысяч и т.д. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = 1627731
&gt;&gt;&gt; round(a, -1)
1627730
&gt;&gt;&gt; round(a, -2)
1627700
&gt;&gt;&gt; round(a, -3)
1628000
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_122"><a name="user-content-_122" href="#_122" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Не перепутайте округление с форматированием значения для вывода. Если вы хотите просто вывести число с некоторым определенным количеством знаков после точки, обычно вам не требуется <em>round()</em>. Вместо этого просто задайте при форматировании, скоро знаков выводить. Пример:<br />
<pre><code class="python">&gt;&gt;&gt; x = 1.23456
&gt;&gt;&gt; format(x, '0.2f')
'1.23'
&gt;&gt;&gt; format(x, '0.3f')
'1.235'
&gt;&gt;&gt; 'value is {:0.3f}'.format(x)
'value is 1.235'
&gt;&gt;&gt;
</code></pre></p>
<p>Сопротивляйтесь желанию округлить числа с плавающей точкой, чтобы исправить проблемы с точностью вычислений. Например, вы можете склоняться поступить так:<br />
<pre><code class="python">&gt;&gt;&gt; a = 2.1
&gt;&gt;&gt; b = 4.2
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
6.300000000000001
&gt;&gt;&gt; c = round(c, 2)  # &quot;Fix&quot; result (???)
&gt;&gt;&gt; c
6.3
&gt;&gt;&gt;
</code></pre></p>
<p>Для большинства программ, работающих с числами с плавающей точкой, просто не нужно (и не рекомендуется) этого делать. Хотя есть незначительные ошибки в вычислениях, поведение этих ошибок понятно и терпимо. Если необходимо избежать таких ошибок (например, это может быть важно для финансовых приложений), попробуйте модуль <em>decimal</em>, который обсуждается в следующем рецепте.</p>
<h2 id="32"><a name="user-content-32" href="#32" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.2. Выполнение точных десятичных вычислений</h2>
<h3 id="_123"><a name="user-content-_123" href="#_123" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно выполнить точные вычисления с десятичными числами, и вы хотите избавиться от небольших ошибок, которые обычно возникают при работе с числами с плавающей точкой.</p>
<h3 id="_124"><a name="user-content-_124" href="#_124" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Широко известный недостаток чисел с плавающей точкой в том, что они не могут точно представить все 10 базовых десятичных цифр. Более того, даже простые математические вычисления приводят к появлению небольших ошибок. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = 4.2
&gt;&gt;&gt; b = 2.1
&gt;&gt;&gt; a + b
6.300000000000001
&gt;&gt;&gt; (a + b) == 6.3
False
&gt;&gt;&gt;
</code></pre></p>
<p>Эти ошибки — не «бага, а фича» процессора и стандарта представления чисел с плавающей точкой IEEE 754, на основе которого работает модуль процессора для выполнения вычислений с плавающей точкой. Поскольку тип данных «числа с плавающей точкой» Python хранит данные, используя нативное представление, вы ничего не можете сделать, чтобы избавиться от ошибок при использовании экземпляров <em>float</em>. </p>
<p>Если вам нужна большая точность (и вы готовы в некоторой степени поступиться производительностью), вы можете использовать модуль <em>decimal</em>:<br />
<pre><code class="python">&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; a = Decimal('4.2')
&gt;&gt;&gt; b = Decimal('2.1')
&gt;&gt;&gt; a + b
Decimal('6.3')
&gt;&gt;&gt; print(a + b)
6.3
&gt;&gt;&gt; (a + b) == Decimal('6.3')
True
&gt;&gt;&gt;
</code></pre></p>
<p>На первый взгляд он может показаться странным (например, определение чисел как строк). Однако объекты <em>Decimal</em> работают именно так, как вы можете ожидать (поддерживают все обычные математические операции и т.д.) Если вы выводите их или используете функциях форматирования строк, они выглядят как обычные числа.</p>
<p>Главное преимущество <em>decimal</em> в том, что он позволяет контролировать различные аспекты вычислений, такие как число знаков после точки и округление. Чтобы это сделать, вы создаете локальный контекст и меняете его установки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from decimal import localcontext
&gt;&gt;&gt; a = Decimal('1.3')
&gt;&gt;&gt; b = Decimal('1.7')
&gt;&gt;&gt; print(a / b)
0.7647058823529411764705882353
&gt;&gt;&gt; with localcontext() as ctx:
...   ctx.prec = 3
...   print(a / b)
...
0.765
&gt;&gt;&gt; with localcontext() as ctx:
...   ctx.prec = 50
...   print(a / b)
...
0.76470588235294117647058823529411764705882352941176
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_125"><a name="user-content-_125" href="#_125" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Модуль <em>decimal</em> реализует «Общую спецификацию десятичной арифметики» компании IBM (“General Decimal Arithmetic Specification”). Нет нужды упоминать, что у него есть очень много различных опций для конфигурирования, описание которых лежит за пределами возможностей этой книги.</p>
<p>Новички в Python могут склоняться к повсеместному использованию модуля <em>decimal</em> для решения проблемы неточности, которая неизбежна при работе с типом данных <em>float</em>. Однако важно понимать область применения вашего приложения. Если вы работаете с научными или инженерными данными, компьютерной графикой, то вполне нормально использовать обычный тип данных чисел с плавающей точкой. В общем-то очень немногие вещи в реальном мире измеряются с точностью до 17-го знака после точки, которую предоставляет <em>float</em>. Так что небольшие ошибки не так уж важны. А производительность нативных чисел с плавающей точкой заметно выше, а это важно при выполнении большого количества вычислений.</p>
<p>Но вы не должны просто полностью игнорировать ошибки. Математики проводят немало времени, изучая различные алгоритмы, и некоторые обрабатывают ошибки лучше других. Вы также должны быть осторожными с эффектами таких штук как вычитательная потеря точности и сложение больших и маленьких чисел. Например:<br />
<pre><code class="python">&gt;&gt;&gt; nums = [1.23e+18, 1, -1.23e+18]
&gt;&gt;&gt; sum(nums)  # Notice how 1 disappears
0.0
&gt;&gt;&gt;
</code></pre></p>
<p>Ошибка из последнего примера может быть решена путем использования <em>math.fsum()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; import math
&gt;&gt;&gt; math.fsum(nums)
1.0
&gt;&gt;&gt;
</code></pre></p>
<p>Однако для других алгоритмов вам придется изучить реализацию и понять, как он работает с точки зрения подобных ошибок. </p>
<p>Подведем итог: модуль <em>decimal</em> используется в основном в финансовых и им подобных приложениях. В таких программах небольшие ошибки в вычислениях ужасно мешают, а <em>decimal</em> позволяет от них избавиться. Также часто можно встретить объекты класса <em>Decimal</em> в интерфейсах Python к базам данных — опять же, особенно часто их используют для доступа к финансовым данным.</p>
<h2 id="33"><a name="user-content-33" href="#33" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.3. Форматирование чисел для вывода</h2>
<h3 id="_126"><a name="user-content-_126" href="#_126" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно отформатировать число для вывода, контролируя количество знаков, выравнивание, включение разделителя для разрядов и т.д.</p>
<h3 id="_127"><a name="user-content-_127" href="#_127" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы отформатировать одно число для вывода, используйте встроенную функцию <em>format()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; x = 1234.56789

&gt;&gt;&gt; # Two decimal places of accuracy
&gt;&gt;&gt; format(x, '0.2f')
'1234.57'

&gt;&gt;&gt; # Right justified in 10 chars, one-digit accuracy
&gt;&gt;&gt; format(x, '&gt;10.1f')
' 1234.6'

&gt;&gt;&gt; # Left justified
&gt;&gt;&gt; format(x, '&lt;10.1f')
'1234.6 '

&gt;&gt;&gt; # Centered
&gt;&gt;&gt; format(x, '^10.1f')
' 1234.6 '

&gt;&gt;&gt; # Inclusion of thousands separator
&gt;&gt;&gt; format(x, ',')
'1,234.56789'
&gt;&gt;&gt; format(x, '0,.1f')
'1,234.6'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите использовать экспоненциальную нотацию, измените f на e или E (в зависимости от регистра, который вы хотите использовать для обозначения экспоненты). Например:<br />
<pre><code class="python">&gt;&gt;&gt; format(x, 'e')
'1.234568e+03'
&gt;&gt;&gt; format(x, '0.2E')
'1.23E+03'
&gt;&gt;&gt;
</code></pre></p>
<p>Общая форма ширины и точности в обоих случаях такова: &lsquo;[&lt;&gt;^]?width[,]?(.digits)?&rsquo;, где width и digits — целые числа, а ? обозначает необязательные части. Тот же формат используется в строковом методе <em>format()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; 'The value is {:0,.2f}'.format(x)
'The value is 1,234.57'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_128"><a name="user-content-_128" href="#_128" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Форматирование чисел для вывода обычно является прямолинейным. Приём, показанный выше, работает и для чисел с плавающей точкой, и для экземпляров <em>Decimal</em> из модуля <em>decimal</em>. </p>
<p>Когда количество знаков ограничено, значения округляются таким же образом, как и при использовании функции <em>round()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; x
1234.56789
&gt;&gt;&gt; format(x, '0.1f')
'1234.6'
&gt;&gt;&gt; format(-x, '0.1f')
'-1234.6'
&gt;&gt;&gt;
</code></pre></p>
<p>Обычное форматирование значений с добавлением разделителя разрядов ничего не знает о принятых в конкретных странах традициях форматирования тысячных разрядов. Если вам нужно принять во внимание эти традиции, обратите внимание на функции модуля <em>locale</em>. Вы также можете заменить символ разделителя разрядов, используя строковый метод translate(). Например:<br />
<pre><code class="python">&gt;&gt;&gt; swap_separators = { ord('.'):',', ord(','):'.' }
&gt;&gt;&gt; format(x, ',').translate(swap_separators)
'1.234,56789'
&gt;&gt;&gt;
</code></pre></p>
<p>В мире всё ещё очень много кода, использующего форматирование чисел на основе оператора %. Например:<br />
<pre><code class="python">&gt;&gt;&gt; '%0.2f' % x
'1234.57'
&gt;&gt;&gt; '%10.1f' % x
' 1234.6'
&gt;&gt;&gt; '%-10.1f' % x
'1234.6 '
&gt;&gt;&gt;
</code></pre></p>
<p>Это форматирование всё еще приемлемо, но обладает меньшими возможностями, нежели современный метод <em>format()</em>. Например, форматирование с помощью оператора % не поддерживает добавление разделителя разрядов.</p>
<h2 id="34"><a name="user-content-34" href="#34" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.4. Работа с бинарными, восьмеричными и шестнадцатеричными целыми числами</h2>
<h3 id="_129"><a name="user-content-_129" href="#_129" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно преобразовать выводимые целые числа в бинарное, восьмеричное или шестнадцатеричное представление.</p>
<h3 id="_130"><a name="user-content-_130" href="#_130" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы преобразовать целое число в бинарное, восьмеричное или шестнадцатеричное представление, используйте функции <em>bin()</em>, <em>oct()</em> или <em>hex()</em> соответственно:<br />
<pre><code class="python">&gt;&gt;&gt; x = 1234
&gt;&gt;&gt; bin(x)
'0b10011010010'
&gt;&gt;&gt; oct(x)
'0o2322'
&gt;&gt;&gt; hex(x)
'0x4d2'
&gt;&gt;&gt;
</code></pre></p>
<p>Или же вы можете использовать функцию <em>format()</em>, если не хотите, чтобы появлялись префиксы 0b, 0o или 0x. Например:<br />
<pre><code class="python">&gt;&gt;&gt; format(x, 'b')
'10011010010'
&gt;&gt;&gt; format(x, 'o')
'2322'
&gt;&gt;&gt; format(x, 'x')
'4d2'
&gt;&gt;&gt;
</code></pre></p>
<p>Целые числа имеют знак, поэтому если вы работаете с отрицательными значениями, то вывод тоже будет включать знак. Например:<br />
<pre><code class="python">&gt;&gt;&gt; x = -1234
&gt;&gt;&gt; format(x, 'b')
'-10011010010'
&gt;&gt;&gt; format(x, 'x')
'-4d2'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите вывести значение без знака, вам нужно добавить максимальное значение, чтобы установить длину бита. Например, чтобы вывести 32-битное значение, можно поступить так:<br />
<pre><code class="python">&gt;&gt;&gt; x = -1234
&gt;&gt;&gt; format(2**32 + x, 'b')
'11111111111111111111101100101110'
&gt;&gt;&gt; format(2**32 + x, 'x')
'fffffb2e'
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы преобразовать строки с целыми числами в числа с разными основаниями, используйте функцию <em>int()</em>, указав нужное основание. Например:<br />
<pre><code class="python">&gt;&gt;&gt; int('4d2', 16)
1234
&gt;&gt;&gt; int('10011010010', 2)
1234
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_131"><a name="user-content-_131" href="#_131" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>По большей части работа с бинарными, восьмеричными и шестнадцатеричными целыми числами прямолинейна. Просто запомните, что эти преобразования относятся только выводу разных текстовых представлений чисел. «Под капотом» это один и тот же тип целых чисел.</p>
<p>Предупреждение для программистов, работающих с восьмеричными числами: синтаксис Python для определения восьмеричных значений немного отличается от реализованного в большинстве других языков. Если вы попробуете сделать это так, то получите синтаксическую ошибку:<br />
<pre><code class="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.chmod('script.py', 0755)
    File &quot;&lt;stdin&gt;&quot;, line 1
        os.chmod('script.py', 0755)
                               ^
SyntaxError: invalid token
&gt;&gt;
</code></pre></p>
<p>Убедитесь, что вы вводите восьмеричное значение с префиксом 0o, как показано тут:<br />
<pre><code class="python">&gt;&gt;&gt; os.chmod('script.py', 0o755)
&gt;&gt;&gt;
</code></pre></p>
<h2 id="35"><a name="user-content-35" href="#35" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.5. Упаковка и распаковка больших целых чисел из байтовых строк</h2>
<h3 id="_132"><a name="user-content-_132" href="#_132" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть строка байтов, и вам нужно распаковать ее в целочисленное значение. Или же вам нужно конвертировать большое целое число в байтовую строку.</p>
<h3 id="_133"><a name="user-content-_133" href="#_133" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Предположим, ваша программа должна работать с 16-тиэлементной байтовой строкой, которая содержит 128-битное целочисленное значение. Например:<br />
<pre><code class="python">data = b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
</code></pre></p>
<p>Чтобы перевести байты в целое число, используйте <em>int.from_bytes()</em>, определив порядок следования байтов таким образом:<br />
<pre><code class="python">&gt;&gt;&gt; len(data)
16
&gt;&gt;&gt; int.from_bytes(data, 'little')
69120565665751139577663547927094891008
&gt;&gt;&gt; int.from_bytes(data, 'big')
94522842520747284487117727783387188
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы преобразовать большое целочисленное значение обратно в байтовую строку, используйте метод <em>int.to_bytes()</em>, определив количество байтов и порядок их следования. Например:<br />
<pre><code class="python">&gt;&gt;&gt; x = 94522842520747284487117727783387188
&gt;&gt;&gt; x.to_bytes(16, 'big')
b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
&gt;&gt;&gt; x.to_bytes(16, 'little')
b'4\x00#\x00\x01\xef\xcd\x00\xab\x90x\x00V4\x12\x00'
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_134"><a name="user-content-_134" href="#_134" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Преобразование больших целочисленных значений из и в байтовые строки — не самая обычная операция. Однако иногда такая задача возникает в некоторых областях, каких как криптография или работа с сетью. Например, сетевые адреса IPv6 представлены 128-битными целыми числами. Если вы пишете программу, в которой нужно вытягивать такие значения из данных, вы можете столкнуться с этой задачей. </p>
<p>В качестве альтернативы вы можете попытаться распаковывать значения, используя модуль <em>struct</em>, как описано в <strong>рецепте 6.11.</strong> Это работает, но размер целых чисел, которые могут быть распакованы с помощью <em>struct</em>, ограничен. Поэтому вам понадобится распаковывать несколько значений и объединять их для создания итогового значения. Например:<br />
<pre><code class="python">&gt;&gt;&gt; data
b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
&gt;&gt;&gt; import struct
&gt;&gt;&gt; hi, lo = struct.unpack('&gt;QQ', data)
&gt;&gt;&gt; (hi &lt;&lt; 64) + lo
94522842520747284487117727783387188
&gt;&gt;&gt;
</code></pre></p>
<p>Определение порядка следования байтов (<em>little</em> или <em>big</em>), просто указывает, записаны ли байты, из которых составляется целое число, в порядке от старшего к младшему или наоборот. Это легко понять, рассмотрев пример такого специально составленного шестнадцатеричного значения:<br />
<pre><code class="python">&gt;&gt;&gt; x = 0x01020304
&gt;&gt;&gt; x.to_bytes(4, 'big')
b'\x01\x02\x03\x04'
&gt;&gt;&gt; x.to_bytes(4, 'little')
b'\x04\x03\x02\x01'
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите упаковать целое число в строку байтов, но оно не поместится, вы получите ошибку. При необходимости вы можете использовать метод <em>int.bit_length()</em>, чтобы определить, сколько байтов потребуется для хранения значения:<br />
<pre><code class="python">&gt;&gt;&gt; x = 523 ** 23
&gt;&gt;&gt; x
335381300113661875107536852714019056160355655333978849017944067
&gt;&gt;&gt; x.to_bytes(16, 'little')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
OverflowError: int too big to convert
&gt;&gt;&gt; x.bit_length()
208
&gt;&gt;&gt; nbytes, rem = divmod(x.bit_length(), 8)
&gt;&gt;&gt; if rem:
...   nbytes += 1
...
&gt;&gt;&gt;
&gt;&gt;&gt; x.to_bytes(nbytes, 'little')
b'\x03X\xf1\x82iT\x96\xac\xc7c\x16\xf3\xb9\xcf...\xd0'
&gt;&gt;&gt;
</code></pre></p>
<h2 id="36"><a name="user-content-36" href="#36" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.6. Вычисления с комплексными числами</h2>
<h3 id="_135"><a name="user-content-_135" href="#_135" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Возможно, ваша программа для взаимодействия с веб-сервисом для аутентификации последнего поколения столкнулась с сингулярностью, и ваш единственный способ обойти это лежит через комплексную плоскость&hellip; Или же вам просто нужно выполнить какие-то вычисления с использованием комплексных чисел.</p>
<h3 id="_136"><a name="user-content-_136" href="#_136" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Комплексные числа могут быть определены с использованием функции <em>complex(real, imag)</em> или добавлением окончания j к числу с плавающей точкой. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = complex(2, 4)
&gt;&gt;&gt; b = 3 - 5j
&gt;&gt;&gt; a
(2+4j)
&gt;&gt;&gt; b
(3-5j)
&gt;&gt;&gt;
</code></pre></p>
<p>Реальное, мнимое и объединенное значения можно легко получить:<br />
<pre><code class="python">&gt;&gt;&gt; a.real
2.0
&gt;&gt;&gt; a.imag
4.0
&gt;&gt;&gt; a.conjugate()
(2-4j)
&gt;&gt;&gt;
</code></pre></p>
<p>Работают все обычные математические операторы:<br />
<pre><code class="python">&gt;&gt;&gt; a + b
(5-1j)
&gt;&gt;&gt; a * b
(26+2j)
&gt;&gt;&gt; a / b
(-0.4117647058823529+0.6470588235294118j)
&gt;&gt;&gt; abs(a)
4.47213595499958
&gt;&gt;&gt;
</code></pre></p>
<p>Для специальных операций с комплексными числами, таких как синусы, косинусы или квадратные корни, используйте модуль <em>cmath</em>:<br />
<pre><code class="python">&gt;&gt;&gt; import cmath
&gt;&gt;&gt; cmath.sin(a)
(24.83130584894638-11.356612711218174j)
&gt;&gt;&gt; cmath.cos(a)
(-11.36423470640106-24.814651485634187j)
&gt;&gt;&gt; cmath.exp(a)
(-4.829809383269385-5.5920560936409816j)
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_137"><a name="user-content-_137" href="#_137" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Большинство связанных с математикой модулей Python умеют работать с комплексными числами. Например, если вы используете numpy, то сможете применить прямолинейный подход к созданию массивов комплексных чисел и операций над ними:<br />
<pre><code class="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([2+3j, 4+5j, 6-7j, 8+9j])
&gt;&gt;&gt; a
array([ 2.+3.j, 4.+5.j, 6.-7.j, 8.+9.j])
&gt;&gt;&gt; a + 2
array([ 4.+3.j, 6.+5.j, 8.-7.j, 10.+9.j])
&gt;&gt;&gt; np.sin(a)
array([ 9.15449915 -4.16890696j, -56.16227422 -48.50245524j,
-153.20827755-526.47684926j, 4008.42651446-589.49948373j])
&gt;&gt;&gt;
</code></pre></p>
<p>Стандартные математические функции, включенные в Python, не производят комплексные значения по умолчанию, так что они вряд ли случайно возникнут в вашем коде. Например:<br />
<pre><code class="python">&gt;&gt;&gt; import math
&gt;&gt;&gt; math.sqrt(-1)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: math domain error
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите получать в результате вычислений комплексные числа, вы должны явно использовать cmath или соответствующим образом объявить это библиотекам, которые умеют с ними работать. Например:<br />
<pre><code class="python">&gt;&gt;&gt; import cmath
&gt;&gt;&gt; cmath.sqrt(-1)
1j
&gt;&gt;&gt;
</code></pre></p>
<h2 id="37-nan"><a name="user-content-37-nan" href="#37-nan" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.7. Работа с бесконечными значениями и NaN</h2>
<h3 id="_138"><a name="user-content-_138" href="#_138" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно создать создать или протестировать такие значения с плавающей точкой: бесконечность, минус бесконечность, NaN (not a number, «не число»).</p>
<h3 id="_139"><a name="user-content-_139" href="#_139" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В Python нет специального синтаксиса для представления таких специальных значений с плавающей точкой, но они могут быть созданы с помощью <em>float()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = float('inf')
&gt;&gt;&gt; b = float('-inf')
&gt;&gt;&gt; c = float('nan')
&gt;&gt;&gt; a
inf
&gt;&gt;&gt; b
-inf
&gt;&gt;&gt; c
nan
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы проверить, не является ли значение таким, используйте функции <em>math.isinf()</em> и <em>math.isnan()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; math.isinf(a)
True
&gt;&gt;&gt; math.isnan(c)
True
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_140"><a name="user-content-_140" href="#_140" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>За подробностями об этих специальных значениях с плавающей точкой вы можете обратиться к спецификации IEEE 754. Однако здесь есть несколько хитрых деталей, о которых нужно знать, особенно связанные со сравнениями и операторами.</p>
<p>Бесконечные значения распространяются в вычислениях согласно математическим правилам. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = float('inf')
&gt;&gt;&gt; a + 45
inf
&gt;&gt;&gt; a * 10
inf
&gt;&gt;&gt; 10 / a
0.0
&gt;&gt;&gt;
</code></pre></p>
<p>Однако некоторые операции неопределены и выдают NaN. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = float('inf')
&gt;&gt;&gt; a/a
nan
&gt;&gt;&gt; b = float('-inf')
&gt;&gt;&gt; a + b
nan
&gt;&gt;&gt;
</code></pre></p>
<p>Значения NaN распространяются через все операции, не возбуждая исключений. Например:<br />
<pre><code class="python">&gt;&gt;&gt; c = float('nan')
&gt;&gt;&gt; c + 23
nan
&gt;&gt;&gt; c / 2
nan
&gt;&gt;&gt; c * 2
nan
&gt;&gt;&gt; math.sqrt(c)
nan
&gt;&gt;&gt;
</code></pre></p>
<p>Тонкость с NaN заключается в том, что они никогда будут равны друг другу. Например:<br />
<pre><code class="python">&gt;&gt;&gt; c = float('nan')
&gt;&gt;&gt; d = float('nan')
&gt;&gt;&gt; c == d
False
&gt;&gt;&gt; c is d
False
&gt;&gt;&gt;
</code></pre></p>
<p>По причине этого единственный безопасный способ проверить значение на NaN — это использовать <em>math.isnan()</em>, как показано в этом рецепте.</p>
<p>Иногда программисты хотят изменить поведение Python таким образом, чтобы при возникновении в ходе вычислений бесконечностей или NaN возбуждались исключения. Для такого изменения поведения может быть использован модуль <em>fpectl</em>, но он не включен в стандартную поставку Python, является платформозависимым и на самом деле предназначен только программистов-экспертов. За деталями обратитесь к <a href="https://docs.python.org/3/library/fpectl.html">онлайн-документации Python</a>.</p>
<h2 id="38"><a name="user-content-38" href="#38" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.8. Вычисления с дробями</h2>
<h3 id="_141"><a name="user-content-_141" href="#_141" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы вошли в машину времени и внезапно обнаружили себя делающим домашку по математике с задачками про дроби. Или же вы просто пишете код, который будет обсчитывать измерения, сделанные в вашей столярной мастерской&hellip;</p>
<h3 id="_142"><a name="user-content-_142" href="#_142" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Модуль <em>fractions</em> может быть использован для выполнения математических операций с дробями. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; a = Fraction(5, 4)
&gt;&gt;&gt; b = Fraction(7, 16)
&gt;&gt;&gt; print(a + b)
27/16
&gt;&gt;&gt; print(a * b)
35/64

&gt;&gt;&gt; # Getting numerator/denominator
&gt;&gt;&gt; c = a * b
&gt;&gt;&gt; c.numerator
35
&gt;&gt;&gt; c.denominator
64

&gt;&gt;&gt; # Converting to a float
&gt;&gt;&gt; float(c)
0.546875
&gt;&gt;&gt; # Limiting the denominator of a value
&gt;&gt;&gt; print(c.limit_denominator(8))
4/7

&gt;&gt;&gt; # Converting a float to a fraction
&gt;&gt;&gt; x = 3.75
&gt;&gt;&gt; y = Fraction(*x.as_integer_ratio())
&gt;&gt;&gt; y
Fraction(15, 4)
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_143"><a name="user-content-_143" href="#_143" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Вычисления с дробями нечасто возникают в обычных программах, но иногда имеет смысл ими воспользоваться. Например, если данные каких-то измерений поступают в виде дробей, то можно работать прямо с ними, что снимает необходимость конвертирования в десятичные дроби или числа с плавающей точкой.</p>
<h2 id="39"><a name="user-content-39" href="#39" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.9. Вычисления на больших массивах чисел</h2>
<h3 id="_144"><a name="user-content-_144" href="#_144" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно произвести вычисления на больших объемах числовых данных, таких как массивы или решетки.</p>
<h3 id="_145"><a name="user-content-_145" href="#_145" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для любых объемных вычислений с использованием массивов используйте библиотеку <a href="http://www.numpy.org/">NumPy</a>. Ее главное преимущество в том, что она предоставляет Python объект массива, который намного эффективнее и лучше подходит для математических вычислений, нежели стандартный список Python. Вот короткий пример, иллюстрирующий важные различия между обычными списками и массивами NumPy:<br />
<pre><code class="python">&gt;&gt;&gt; # Python lists
&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; y = [5, 6, 7, 8]
&gt;&gt;&gt; x * 2
[1, 2, 3, 4, 1, 2, 3, 4]
&gt;&gt;&gt; x + 10
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: can only concatenate list (not &quot;int&quot;) to list
&gt;&gt;&gt; x + y
[1, 2, 3, 4, 5, 6, 7, 8]

&gt;&gt;&gt; # Numpy arrays
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; ax = np.array([1, 2, 3, 4])
&gt;&gt;&gt; ay = np.array([5, 6, 7, 8])
&gt;&gt;&gt; ax * 2
array([2, 4, 6, 8])
&gt;&gt;&gt; ax + 10
array([11, 12, 13, 14])
&gt;&gt;&gt; ax + ay
array([ 6, 8, 10, 12])
&gt;&gt;&gt; ax * ay
array([ 5, 12, 21, 32])
&gt;&gt;&gt;
</code></pre></p>
<p>Как вы можете увидеть, базовые математические операции с использованием массивов выполняются по-разному. Конкретно скалярные операции (например, ax * 2 или ax + 10) применяют операцию элемент за элементом. Также отметим, что выполнение таких математических операций, где каждый из операндов является массивом, применяет операцию ко всем элементам и создает новый массив.</p>
<p>Тот факт, что математические операции применяются одновременно ко всем элементам, позволяет очень просто и быстро применить функции к всему массиву. Например, если вы хотите вычислить значение многочлена:<br />
<pre><code class="python">&gt;&gt;&gt; def f(x):
...   return 3*x**2 - 2*x + 7
...
&gt;&gt;&gt; f(ax)
array([ 8, 15, 28, 47])
&gt;&gt;&gt;
</code></pre></p>
<p>NumPy предоставляет набор «универсальных функций», которые также работают для операций над массивами. Они подменяют похожие функции, доступные в модуле <em>math</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; np.sqrt(ax)
array([ 1. , 1.41421356, 1.73205081, 2. ])
&gt;&gt;&gt; np.cos(ax)
array([ 0.54030231, -0.41614684, -0.9899925 , -0.65364362])
&gt;&gt;&gt;
</code></pre></p>
<p>Использование универсальных функций позволяет выполнить вычисление в сотни раз быстрее, чем проход по массиву и применение функций из <em>math</em> к каждому элементу. Так что используйте их при любой возможности.</p>
<p>«Под капотом» массивы NumPy устроены похоже на массивы C или Fortran. А именно они представляют собой большие смежные области памяти, состоящие из однородных типов данных. Это позволяет делать массивы намного большими, чем позволяет обычный список Python. Например, если вы хотите создать двумерную решетку размером 10 000 на 10 000 чисел с плавающей точкой, это не проблема:<br />
<pre><code class="python">&gt;&gt;&gt; grid = np.zeros(shape=(10000,10000), dtype=float)
&gt;&gt;&gt; grid
array([[ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       ...,
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.]])
&gt;&gt;&gt;
</code></pre></p>
<p>Все обычные операции все еще применяются к элементам одновременно:<br />
<pre><code class="python">&gt;&gt;&gt; grid += 10
&gt;&gt;&gt; grid
array([[ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       ...,
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.]])
&gt;&gt;&gt; np.sin(grid)
array([[-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       ...,
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111]])
&gt;&gt;&gt;
</code></pre></p>
<p>Важнейший момент в использовании NumPy — это способ, которым она расширяет функциональность индексирования списков Python (особенно для многомерных массивов). Чтобы проиллюстрировать это, создадим простой двумерный массив и поэкспериментируем:<br />
<pre><code class="python">&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
&gt;&gt;&gt; a
array([[ 1, 2, 3, 4],
       [ 5, 6, 7, 8],
       [ 9, 10, 11, 12]])

&gt;&gt;&gt; # Select row 1
&gt;&gt;&gt; a[1]
array([5, 6, 7, 8])

&gt;&gt;&gt; # Select column 1
&gt;&gt;&gt; a[:,1]
array([ 2, 6, 10])

&gt;&gt;&gt; # Select a subregion and change it
&gt;&gt;&gt; a[1:3, 1:3]
array([[ 6, 7],
       [10, 11]])
&gt;&gt;&gt; a[1:3, 1:3] += 10
&gt;&gt;&gt; a
array([[ 1, 2, 3, 4],
       [ 5, 16, 17, 8],
       [ 9, 20, 21, 12]])

&gt;&gt;&gt; # Broadcast a row vector across an operation on all rows
&gt;&gt;&gt; a + [100, 101, 102, 103]
array([[101, 103, 105, 107],
       [105, 117, 119, 111],
       [109, 121, 123, 115]])
&gt;&gt;&gt; a
array([[ 1, 2, 3, 4],
       [ 5, 16, 17, 8],
       [ 9, 20, 21, 12]])

&gt;&gt;&gt; # Conditional assignment on an array
&gt;&gt;&gt; np.where(a &lt; 10, a, 10)
array([[ 1, 2, 3, 4],
       [ 5, 10, 10, 8],
       [ 9, 10, 10, 10]])
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_146"><a name="user-content-_146" href="#_146" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>NumPy — это основа огромного количества научных и инженерных библиотек для Python. Это также один из крупнейших и самых сложных модулей (из тех, что широко используются). При этом можно делать полезные вещи с помощью NumPy, начинав экспериментировать с простыми примерами.</p>
<p>Стоит отметить, что часто используется конструкция <em>import numpy as np</em>, как и показано в нашем примере. Это сокращает название, чтобы было удобно вводить его снова и снова в вашей программе. </p>
<p>Прочую информацию вы найдёте на <a href="http://www.numpy.org"><a href="http://www.numpy.org"><a href="http://www.numpy.org">http://www.numpy.org</a></a></a>.</p>
<h2 id="310"><a name="user-content-310" href="#310" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.10. Вычисления с матрицами и линейная алгебра</h2>
<h3 id="_147"><a name="user-content-_147" href="#_147" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно произвести матричные операции и операции линейной алгебры, такие как умножение матриц, поиск определителей, решение линейных уравнений и т.д.</p>
<h3 id="_148"><a name="user-content-_148" href="#_148" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Библиотека <a href="http://www.numpy.org">NumPy</a> содержит объект <em>matrix</em>. Матрицы — это нечто похожее на объекты массивов, описанные в <strong>рецепте 3.9.</strong>, но в вычисления над ними следуют законам линейной алгебры. Вот несколько примеров их основных возможностей:<br />
<pre><code class="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; m = np.matrix([[1,-2,3],[0,4,5],[7,8,-9]])
&gt;&gt;&gt; m
matrix([[ 1, -2, 3],
        [ 0, 4, 5],
        [ 7, 8, -9]])

&gt;&gt;&gt; # Return transpose
&gt;&gt;&gt; m.T
matrix([[ 1, 0, 7],
        [-2, 4, 8],
        [ 3, 5, -9]])

&gt;&gt;&gt; # Return inverse
&gt;&gt;&gt; m.I
matrix([[ 0.33043478, -0.02608696, 0.09565217],
        [-0.15217391, 0.13043478, 0.02173913],
        [ 0.12173913, 0.09565217, -0.0173913 ]])

&gt;&gt;&gt; # Create a vector and multiply
&gt;&gt;&gt; v = np.matrix([[2],[3],[4]])
&gt;&gt;&gt; v
matrix([[2],
        [3],
        [4]])
&gt;&gt;&gt; m * v
matrix([[ 8],
        [32],
        [ 2]])
&gt;&gt;&gt;
</code></pre></p>
<p>Другие операции можно найти в субпакете <em>numpy.linalg</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; import numpy.linalg

&gt;&gt;&gt; # Determinant
&gt;&gt;&gt; numpy.linalg.det(m)
-229.99999999999983

&gt;&gt;&gt; # Eigenvalues
&gt;&gt;&gt; numpy.linalg.eigvals(m)
array([-13.11474312, 2.75956154, 6.35518158])

&gt;&gt;&gt; # Solve for x in mx = v
&gt;&gt;&gt; x = numpy.linalg.solve(m, v)
&gt;&gt;&gt; x
matrix([[ 0.96521739],
        [ 0.17391304],
        [ 0.46086957]])
&gt;&gt;&gt; m * x
matrix([[ 2.],
        [ 3.],
        [ 4.]])
&gt;&gt;&gt; v
matrix([[2],
        [3],
        [4]])
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_149"><a name="user-content-_149" href="#_149" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Линейная алгебра, очевидно, является слишком обширной темой, чтобы обсуждать ее в этом сборнике рецептов. Однако если вам нужно работать с матрицами и векторами, начните именно с NumPy. За информацией о библиотеке обращайтесь на <a href="http://www.numpy.org"><a href="http://www.numpy.org"><a href="http://www.numpy.org">http://www.numpy.org</a></a></a>.</p>
<h2 id="311"><a name="user-content-311" href="#311" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.11. Случайный выбор</h2>
<h3 id="_150"><a name="user-content-_150" href="#_150" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите выбрать случайные элементы из последовательности или сгенерировать случайные числа.</p>
<h3 id="_151"><a name="user-content-_151" href="#_151" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Модуль random содержит разнообразные функции для генерации случайных чисел и выбора случайных элементов. Например, чтобы выбрать случайный элемент последовательности используйте <em>random.choice()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; import random
&gt;&gt;&gt; values = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; random.choice(values)
2
&gt;&gt;&gt; random.choice(values)
3
&gt;&gt;&gt; random.choice(values)
1
&gt;&gt;&gt; random.choice(values)
4
&gt;&gt;&gt; random.choice(values)
6
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы получить выборку из N элементов, используйте <em>random.sample()</em>. Каждый элемент выбирается один раз, так что если значения в полученной выборке повторяются, то это разные элементы оригинальной последовательности, имеющие одинаковое значение:<br />
<pre><code class="python">&gt;&gt;&gt; random.sample(values, 2)
[6, 2]
&gt;&gt;&gt; random.sample(values, 2)
[4, 3]
&gt;&gt;&gt; random.sample(values, 3)
[4, 3, 1]
&gt;&gt;&gt; random.sample(values, 3)
[5, 4, 1]
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите перемешать элементы в последовательности, используйте <em>random.shuffle()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; random.shuffle(values)
&gt;&gt;&gt; values
[2, 4, 6, 5, 3, 1]
&gt;&gt;&gt; random.shuffle(values)
&gt;&gt;&gt; values
[3, 5, 2, 1, 6, 4]
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы сгенерировать случайные целые числа, используйте <em>random.randint()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; random.randint(0,10)
2
&gt;&gt;&gt; random.randint(0,10)
5
&gt;&gt;&gt; random.randint(0,10)
0
&gt;&gt;&gt; random.randint(0,10)
7
&gt;&gt;&gt; random.randint(0,10)
10
&gt;&gt;&gt; random.randint(0,10)
3
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы сгенерировать одинаковые по формату числа с плавающей точкой в диапазоне от 0 до 1, используйте <em>random.random()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; random.random()
0.9406677561675867
&gt;&gt;&gt; random.random()
0.133129581343897
&gt;&gt;&gt; random.random()
0.4144991136919316
&gt;&gt;&gt;
</code></pre></p>
<p>Чтобы получить целое число из N случайных битов, используйте <em>random.getrandbits()</em>:<br />
<pre><code class="python">&gt;&gt;&gt; random.getrandbits(200)
335837000776573622800628485064121869519521710558559406913275
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_152"><a name="user-content-_152" href="#_152" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Модуль <em>random</em> вычисляет случайные числа, используя алгоритм «вихрь Мерсенна» (Mersenne twister, MT). Это детерминистский алгоритм, но вы можете изменить начальную инциализацию с помощью функции random.seed():<br />
<pre><code class="python">random.seed() # Seed based on system time or os.urandom()
random.seed(12345) # Seed based on integer given
random.seed(b'bytedata') # Seed based on byte data
</code></pre></p>
<p>Вдобавок к уже продемонстрированной функциональности, <em>random</em> включает функции для равномерного, гауссового и других распределений вероятности. Например, <em>random.uniform()</em> вычисляет равномерно распределенные числа, а <em>random.gauss()</em> — нормально распределенные. За описанием других поддерживаемых распределений обратитесь к документации.</p>
<p>Функции в <em>random</em> не должны быть использованы в криптографических программах. Если вам нужна такая функциональность, обратитесь к функциям из модуля <em>ssl</em>. Например, <em>ssl.RAND_bytes()</em> может быть использована для генерации криптографически безопасных последовательностей случайных байтов.</p>
<h2 id="312"><a name="user-content-312" href="#312" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.12. Перевод дней в секунды и другие базовые методы конвертации времени</h2>
<h3 id="_153"><a name="user-content-_153" href="#_153" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вашей программе требуется производить простые преобразования времени, такие как выражение дней в секундах, часов в минутах и т.д.</p>
<h3 id="_154"><a name="user-content-_154" href="#_154" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы производить конвертирование и арифметические операции над различными единицами времени, используйте модуль <em>datetime</em>. Например, чтобы представить интервал времени, создайте экземпляр <em>timedelta</em>:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; a = timedelta(days=2, hours=6)
&gt;&gt;&gt; b = timedelta(hours=4.5)
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c.days
2
&gt;&gt;&gt; c.seconds
37800
&gt;&gt;&gt; c.seconds / 3600
10.5
&gt;&gt;&gt; c.total_seconds() / 3600
58.5
&gt;&gt;&gt;
</code></pre></p>
<p>Если вам нужно представить определенные даты и определенное время, создайте экземпляры <em>datetime</em> и проводите над ними обычные арифметические операции. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; a = datetime(2012, 9, 23)
&gt;&gt;&gt; print(a + timedelta(days=10))
2012-10-03 00:00:00
&gt;&gt;&gt;
&gt;&gt;&gt; b = datetime(2012, 12, 21)
&gt;&gt;&gt; d = b - a
&gt;&gt;&gt; d.days
89
&gt;&gt;&gt; now = datetime.today()
&gt;&gt;&gt; print(now)
2012-12-21 14:54:43.094063
&gt;&gt;&gt; print(now + timedelta(minutes=10))
2012-12-21 15:04:43.094063
&gt;&gt;&gt;
</code></pre></p>
<p>Стоит отметить, что <em>datetime</em> знает о существовании високосных годов. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = datetime(2012, 3, 1)
&gt;&gt;&gt; b = datetime(2012, 2, 28)
&gt;&gt;&gt; a - b
datetime.timedelta(2)
&gt;&gt;&gt; (a - b).days
2
&gt;&gt;&gt; c = datetime(2013, 3, 1)
&gt;&gt;&gt; d = datetime(2013, 2, 28)
&gt;&gt;&gt; (c - d).days
1
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_155"><a name="user-content-_155" href="#_155" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Для самых базовых операций над датой и временем модуля <em>datetime</em> достаточно. Если перед вами стоят более сложные задачи, такие как работа с временными зонами, нечеткими интервалами времени, подсчет дат выходных дней и так далее, посмотрите на модуль <a href="https://pypi.python.org/pypi/python-dateutil">dateutil</a>.</p>
<p>Например, множество похожих вычислений над временем может быть выполнено с помощью функции <em>dateutil.relativedelta()</em>. Одна важная возможность заключается в том, что она заполняет разрывы, которые возникают при работе с месяцами (и отличающимся количеством дней в них). Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = datetime(2012, 9, 23)
&gt;&gt;&gt; a + timedelta(months=1)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'months' is an invalid keyword argument for this function
&gt;&gt;&gt;

&gt;&gt;&gt; from dateutil.relativedelta import relativedelta
&gt;&gt;&gt; a + relativedelta(months=+1)
datetime.datetime(2012, 10, 23, 0, 0)
&gt;&gt;&gt; a + relativedelta(months=+4)
datetime.datetime(2013, 1, 23, 0, 0)
&gt;&gt;&gt;

&gt;&gt;&gt; # Time between two dates
&gt;&gt;&gt; b = datetime(2012, 12, 21)
&gt;&gt;&gt; d = b - a
&gt;&gt;&gt; d
datetime.timedelta(89)
&gt;&gt;&gt; d = relativedelta(b, a)
&gt;&gt;&gt; d
relativedelta(months=+2, days=+28)
&gt;&gt;&gt; d.months
2
&gt;&gt;&gt; d.days
28
&gt;&gt;&gt;
</code></pre></p>
<h2 id="313"><a name="user-content-313" href="#313" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.13. Определение даты последней пятницы</h2>
<h3 id="_156"><a name="user-content-_156" href="#_156" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите создать общее решение для нахождения даты ближайшего прошедшего дня недели — например, последней прошедшей пятницы.</p>
<h3 id="_157"><a name="user-content-_157" href="#_157" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В модуле <em>datetime</em> есть полезные функции и классы, которые помогают проводить такого рода вычисления. Хорошее обобщенное решение этой задачи выглядит как-то так:<br />
<pre><code class="python">from datetime import datetime, timedelta

weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
            'Friday', 'Saturday', 'Sunday']

def get_previous_byday(dayname, start_date=None):
    if start_date is None:
        start_date = datetime.today()
    day_num = start_date.weekday()
    day_num_target = weekdays.index(dayname)
    days_ago = (7 + day_num - day_num_target) % 7
    if days_ago == 0:
        days_ago = 7
    target_date = start_date - timedelta(days=days_ago)
    return target_date
</code></pre></p>
<p>Использование этой функции в строке интерпретатора выглядит так:<br />
<pre><code class="python">&gt;&gt;&gt; datetime.today()  # For reference
datetime.datetime(2012, 8, 28, 22, 4, 30, 263076)
&gt;&gt;&gt; get_previous_byday('Monday')
datetime.datetime(2012, 8, 27, 22, 3, 57, 29045)
&gt;&gt;&gt; get_previous_byday('Tuesday') # Previous week, not today
datetime.datetime(2012, 8, 21, 22, 4, 12, 629771)
&gt;&gt;&gt; get_previous_byday('Friday')
datetime.datetime(2012, 8, 24, 22, 5, 9, 911393)
&gt;&gt;&gt;
</code></pre></p>
<p>Необязательный параметр <em>start_date</em> может быть предоставлен с использованием другого экземпляра <em>datetime</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; get_previous_byday('Sunday', datetime(2012, 12, 21))
datetime.datetime(2012, 12, 16, 0, 0)
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_158"><a name="user-content-_158" href="#_158" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Этот рецепт работает путем отображения стартовой и нужной даты на номера их позиций в неделе (где понедельник — это 0). Далее используется модульная арифметика, с её помощью мы вычисляем, сколько дней назад была нужная дата. Далее нужная дата высчитывается от стартовой даты путем вычитания соответствующего экземпляра <em>timedelta</em>.</p>
<p>Если вы выполняете много подобных вычислений, рекомендуем установить пакет <a href="https://pypi.python.org/pypi/python-dateutil">python-dateutil</a>. Например, вот так можно выполнить аналогичную работу с использованием функции <em>relativedata()</em> из модуля <em>dateutil</em>:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from dateutil.relativedelta import relativedelta
&gt;&gt;&gt; from dateutil.rrule import *
&gt;&gt;&gt; d = datetime.now()
&gt;&gt;&gt; print(d)
2012-12-23 16:31:52.718111
&gt;&gt;&gt; # Next Friday
&gt;&gt;&gt; print(d + relativedelta(weekday=FR))
2012-12-28 16:31:52.718111
&gt;&gt;&gt;
&gt;&gt;&gt; # Last Friday
&gt;&gt;&gt; print(d + relativedelta(weekday=FR(-1)))
2012-12-21 16:31:52.718111
&gt;&gt;&gt;
</code></pre></p>
<h2 id="314"><a name="user-content-314" href="#314" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.14. Поиск диапазона дат для текущего месяца</h2>
<h3 id="_159"><a name="user-content-_159" href="#_159" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть код, которому необходимо пройти в цикле по каждой дате текущего месяца, и вы хотите узнать эффективный способ поиска диапазонов дат.</p>
<h3 id="_160"><a name="user-content-_160" href="#_160" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Прохождение в цикле по датам не требует предварительного создания списка всех дат. Вы можете просто вычислить стартовую и конечную дату в диапазоне, а затем использовать объекты <em>datetime.timedelta</em>, инкрементируя дату.</p>
<p>Вот функция, которая принимает любой объект <em>datetime</em> и возвращает кортеж, содержащий первую дату месяца и начальную дату следующего месяца:<br />
<pre><code class="python">from datetime import datetime, date, timedelta
import calendar

def get_month_range(start_date=None):
    if start_date is None:
    start_date = date.today().replace(day=1)
_, days_in_month = calendar.monthrange(start_date.year, start_date.month)
end_date = start_date + timedelta(days=days_in_month)
return (start_date, end_date)
</code></pre></p>
<p>Получив эти данные, очень просто пройти в цикле по диапазону дат:<br />
<pre><code class="python">&gt;&gt;&gt; a_day = timedelta(days=1)
&gt;&gt;&gt; first_day, last_day = get_month_range()
&gt;&gt;&gt; while first_day &lt; last_day:
...  print(first_day)
...  first_day += a_day
...
2012-08-01
2012-08-02
2012-08-03
2012-08-04
2012-08-05
2012-08-06
2012-08-07
2012-08-08
2012-08-09
#... and so on...
</code></pre></p>
<h3 id="_161"><a name="user-content-_161" href="#_161" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Этот рецепт работает так: сначала вычисляется дата, соответствующая первому дню месяца. Быстрый способ сделать это — использовать метод <em>replace()</em> объектов <em>date</em> или <em>datetime</em>, чтобы присвоить атрибуту <em>days</em> значение 1. Приятно, что метод <em>replace()</em> создает объект того же типа, к которому он был применен. В данном случае, поскольку на входе у нас был экземпляр <em>date</em>, результат тоже является экземпляром <em>date</em>. Точно так же мы бы получили экземпляр <em>datetime</em>, если бы на входе у нас был экземпляр <em>datetime</em>. </p>
<p>Затем функция <em>calendar.monthrange()</em> используется для нахождения количества дней в рассматриваемом месяце. Модуль calendar весьма полезен для получения базовых данных о календарях. Функция <em>monthrange()</em> возвращает кортеж, который содержит день недели и количество дней в месяце. </p>
<p>Когда мы знаем количество дней в месяце, конечная дата вычисляется путём добавления соответствующего <em>timedelta</em> к стартовой дате.  Тонкий, но важный аспект этого рецепта — конечная дата не включается в диапазон (на самом деле это первая дата следующего месяца). Это отражает присущее срезам и диапазонам Python поведение, которое также не подразумевает включение последнего элемента.</p>
<p>Чтобы пройти в цикле по диапазону дат, используются стандартные математические операции и операторы сравнения. Например, экземпляр timedelta может быть использован для инкрементирования даты. Оператор &lt; используется для проверки того, не достигнута ли конечная дата.</p>
<p>В идеальном случае стоит создать функцию, которая будет работать как встроенная <em>range()</em>, но с датами. К счастью, есть чрезвычайно простой способ сделать это с помощью генератора:<br />
<pre><code class="python">def date_range(start, stop, step):
    while start &lt; stop:
        yield start
        start += step
</code></pre></p>
<p>Вот пример её использования:<br />
<pre><code class="python">&gt;&gt;&gt; for d in date_range(datetime(2012, 9, 1), datetime(2012,10,1),
timedelta(hours=6)):
... print(d)
...
2012-09-01 00:00:00
2012-09-01 06:00:00
2012-09-01 12:00:00
2012-09-01 18:00:00
2012-09-02 00:00:00
2012-09-02 06:00:00
...
&gt;&gt;&gt;
</code></pre></p>
<p>Повторимся, самое большое преимущество такой реализации в том, что датами и временем можно манипулировать с помощью стандартных математических операторов и операторов сравнения.</p>
<h2 id="315"><a name="user-content-315" href="#315" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.15. Конвертирование строк в даты и время</h2>
<h3 id="_162"><a name="user-content-_162" href="#_162" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Ваше приложение получает временные данные в строковом формате, но вы хотите конвертировать их в объекты <em>datetime</em>, чтобы выполнять над ними нестроковые операции.</p>
<h3 id="_163"><a name="user-content-_163" href="#_163" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Стандартный модуль <em>datetime</em> обычно легко справляется с этой задачей. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; text = '2012-09-20'
&gt;&gt;&gt; y = datetime.strptime(text, '%Y-%m-%d')
&gt;&gt;&gt; z = datetime.now()
&gt;&gt;&gt; diff = z - y
&gt;&gt;&gt; diff
datetime.timedelta(3, 77824, 177393)
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_164"><a name="user-content-_164" href="#_164" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Метод <em>datetime.strptime()</em> поддерживает множество параметров форматирования, такие как %Y для года из четырёх цифр и %m для месяца из двух цифр. Также стоит отметить, что эти параметры-плейсхолдеры работают в обратном направлении, что поможет, если вам нужно вывести объект <em>datetime</em> в строке и при этом заставить его красиво выглядеть.</p>
<p>Предположим, например, что у ваша программа генерирует объект <em>datetime</em>, но вам нужно создать из него красивую, понятную людям дату, чтобы потом вставить ее в заголовок автоматически создаваемого письма или отчёта:<br />
<pre><code class="python">&gt;&gt;&gt; z
datetime.datetime(2012, 9, 23, 21, 37, 4, 177393)
&gt;&gt;&gt; nice_z = datetime.strftime(z, '%A %B %d, %Y')
&gt;&gt;&gt; nice_z
'Sunday September 23, 2012'
&gt;&gt;&gt;
</code></pre></p>
<p>Стоит отметить, что производительность метода <em>strptime()</em> часто оказывается намного хуже, чем вы могли бы ожидать, поскольку функция написана на чистом Python и должна работать со всеми установками системной локализации. Если вы парсите множество дат в своей программе и знаете их точный формат, вы можете добиться намного более высокой производительности путём написания собственного решения. Например, если вы знаете, что даты представлены в формате “YYYY-MM-DD”, вы могли бы написать такую функцию:<br />
<pre><code class="python">from datetime import datetime
def parse_ymd(s):
    year_s, mon_s, day_s = s.split('-')
    return datetime(int(year_s), int(mon_s), int(day_s))
</code></pre></p>
<p>При тестировании эта функции оказалась более чем в семь раз быстрее метода <em>datetime.strptime()</em>. Это стоит держать в голове, если вы обрабатываете большие объемы данных с датами.</p>
<h2 id="316"><a name="user-content-316" href="#316" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3.16. Манипулирование датами с учётом таймзон</h2>
<h3 id="_165"><a name="user-content-_165" href="#_165" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас назначена телефонная конференция на 21 декабря 2012 года в 9:30 a.m. по чикагскому времени. В какое локальное время ваш друг из индийского города Бангалор должен выйти на связь?</p>
<h3 id="_166"><a name="user-content-_166" href="#_166" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для практических любых задач, связанных с таймзонами, вы можете использовать модуль <a href="https://pypi.python.org/pypi/pytz">pytz</a>. Этот пакет предоставляет базу таймзон Олсона (tz databaze), которая является стандартом де-факто для многих языков программирования и операционных систем.</p>
<p>Большая часть случаев использования <em>pytz</em> приходится на приведение к локальному времени дат, созданных с помощью библиотеки <em>datetime</em>. Например, вот как вы могли бы представить дату с чикагским местным временем:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from pytz import timezone
&gt;&gt;&gt; d = datetime(2012, 12, 21, 9, 30, 0)
&gt;&gt;&gt; print(d)
2012-12-21 09:30:00
&gt;&gt;&gt;

&gt;&gt;&gt; # Localize the date for Chicago
&gt;&gt;&gt; central = timezone('US/Central')
&gt;&gt;&gt; loc_d = central.localize(d)
&gt;&gt;&gt; print(loc_d)
2012-12-21 09:30:00-06:00
&gt;&gt;&gt;
</code></pre></p>
<p>Когда дата локализована (привязана к местному времени), ее можно конвертировать в другие таймзоны. Чтобы найти то же бангалорское время, вы можете сделать так:<br />
<pre><code class="python">&gt;&gt;&gt; # Convert to Bangalore time
&gt;&gt;&gt; bang_d = loc_d.astimezone(timezone('Asia/Kolkata'))
&gt;&gt;&gt; print(bang_d)
2012-12-21 21:00:00+05:30
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы собираетесь выполнять арифметические операции над локализованными датами, вам нужно знать о переводах времени с летнего на зимнее и прочих подобных деталях. Например, в 2013 году стандартное летнее время США началось 13 марта в 2:00 ночи по местному времени городов (время было переведено на час вперед). Если бы провели стандартную арифметическую операцию над датами, то получили бы неверный результат. Например:<br />
<pre><code class="python">&gt;&gt;&gt; d = datetime(2013, 3, 10, 1, 45)
&gt;&gt;&gt; loc_d = central.localize(d)
&gt;&gt;&gt; print(loc_d)
2013-03-10 01:45:00-06:00
&gt;&gt;&gt; later = loc_d + timedelta(minutes=30)
&gt;&gt;&gt; print(later)
2013-03-10 02:15:00-06:00
# WRONG! WRONG!
&gt;&gt;&gt;
</code></pre></p>
<p>Ответ получается неверным, поскольку он не учитывает перевод местного времени на один час. Чтобы исправить это, используйте метод таймзон <em>normalize()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; later = central.normalize(loc_d + timedelta(minutes=30))
&gt;&gt;&gt; print(later)
2013-03-10 03:15:00-05:00
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_167"><a name="user-content-_167" href="#_167" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Чтобы предотвратить взрыв головы, используйте обычную стратегию работы с локальным временем: преобразование всех дат в UTC и использование уже их для хранения и обработки. Например:<br />
<pre><code class="python">&gt;&gt;&gt; print(loc_d)
2013-03-10 01:45:00-06:00
&gt;&gt;&gt; utc_d = loc_d.astimezone(pytz.utc)
&gt;&gt;&gt; print(utc_d)
2013-03-10 07:45:00+00:00
&gt;&gt;&gt;
</code></pre><br />
Если время уже в UTC, вы можете не волноваться по поводу проблем, связанных с переходом на летнее время, а также прочих подобных вещах. Вы свободно можете выполнять арифметические операции с датами. Если же вы хотите вывести дату в локальном времени, просто сконвертируйте в нужную таймзону. Например:<br />
<pre><code class="python">&gt;&gt;&gt; later_utc = utc_d + timedelta(minutes=30)
&gt;&gt;&gt; print(later_utc.astimezone(central))
2013-03-10 03:15:00-05:00
&gt;&gt;&gt;
</code></pre></p>
<p>С использованием таймзон есть одна проблема: какие имена таймзон использовать? Например, в этом рецепте мы как-то узнали, что “Asia/Kolkata” — это правильное название таймзоны для Индии. Чтобы узнать название нужной зоны, поищите в словаре <em>pytz.country_timezones</em>, указывая в качестве ключа код страны по ISO 3166. Например:<br />
<pre><code class="python">&gt;&gt;&gt; pytz.country_timezones['IN']
['Asia/Kolkata']
&gt;&gt;&gt;
</code></pre></p>
<p><em>К тому времени, как вы это прочтёте, модуль </em>pytz<em> может быть признан устаревшим, а ему на смену придёт улучшенная поддержка таймзон по <a href="http://www.python.org/dev/peps/pep-0431">PEP 431</a>. Однако многие из описанных проблем все равно нужно будет учитывать (вопросы работы с UTC и т.п.)</em></p>
<h1 id="4"><a name="user-content-4" href="#4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4. Итераторы и генераторы</h1>
<p>Итерации — одна из сильнейших сторон Python. На высшем уровне абстракции вы можете рассматривать интерации как способ обработки элементов последовательности. Однако возможности намного шире: они включают создание собственных объектов-итераторов, применение полезных паттернов итераций из модуля <em>itertools</em>, создание функций-генераторов и т.д. Эта глава рассматривает типичные задачи, связанные с итерациями.</p>
<h2 id="41"><a name="user-content-41" href="#41" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.1. Ручное прохождение по итератору</h2>
<h3 id="_168"><a name="user-content-_168" href="#_168" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вам нужно обработать элементы итерируемого объекта, но по какой-то причине<br />
вы не хотите использовать цикл.</p>
<h3 id="_169"><a name="user-content-_169" href="#_169" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы вручную пройти по итерируемому объекту, используйте функцию <em>next()</em> и напишите код так, чтобы он ловил исключение <em>StopIteration</em>. Например, в этом случае мы вручную читаем строки из файла:<br />
<pre><code class="python">with open('/etc/passwd') as f:
    try:
        while True:
        line = next(f)
        print(line, end='')
    except StopIteration:
        pass
</code></pre></p>
<p>Обычно <em>StopIteration</em> используется для передачи сигнала о конце итерирования. Однако если вы используете <em>next()</em> вручную, вы вместо этого можете запрограммировать возвращение конечного значения, такого как <em>None</em>. Например:<br />
<pre><code class="python">with open('/etc/passwd') as f:
    while True:
    line = next(f, None)
        if line is None:
            break
    print(line, end='')
</code></pre></p>
<h3 id="_170"><a name="user-content-_170" href="#_170" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>В большинстве случаев для прохода по итерируемому объекту используется цикл <em>for</em>. Однако задачи иногда требуют более точного контроля «подкапотного» механизма итераций. Также это полезно для того, чтобы разобраться, как он работает.</p>
<p>Следующий интерактивный пример иллюстрирует базовые механизмы того, что происходит во время итерирования:<br />
<pre><code class="python">&gt;&gt;&gt; items = [1, 2, 3]
&gt;&gt;&gt; # Get the iterator
# Invokes items.__iter__()
&gt;&gt;&gt; it = iter(items)
&gt;&gt;&gt; # Run the iterator
&gt;&gt;&gt; next(it)
# Invokes it.__next__()
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; next(it)
3
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt;
</code></pre></p>
<p>Последующие рецепты в этой главе раскрывают подробности о приёмах итерирования, что предполагает знание базового протокола итераторов. Убедитесь, что этот первый рецепт прочно улёгся у вас в памяти.</p>
<h2 id="42"><a name="user-content-42" href="#42" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.2. Делегирование итерации</h2>
<h3 id="_171"><a name="user-content-_171" href="#_171" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы создали нестандартный объект-контейнер, который внутри содержит список, кортеж или какой-то другой итерируемый объект. Вы хотите заставить итерации работать с вашим новым контейнером.</p>
<h3 id="_172"><a name="user-content-_172" href="#_172" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В типичном случае вам нужно определить метод <strong>iter()</strong>, который делегирует итерацию внутреннему содержимому контейнера. Например:<br />
<pre><code class="python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

def __iter__(self):
        return iter(self._children)

# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    for ch in root:
    print(ch)
    # Outputs Node(1), Node(2)
</code></pre></p>
<p>В этой программе метод <em><strong>iter()</strong></em> просто перенаправляет запрос на итерацию содержащемус внутри атрибуту <em>_children</em>. </p>
<h3 id="_173"><a name="user-content-_173" href="#_173" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Протокол итераций Python требует, чтобы <em><strong>iter()</strong></em> возвращал специальный объект-итератор, в котором реализован метод <em><strong>next()</strong></em>, который и выполняет итерацию. Если вы просто итерируете по содержимому другого контейнера, вам не стоит беспокоиться о деталях внутреннего механизма процесса. Вам нужно просто передать запрос на итерацию.</p>
<p>Использование функции <em>iter()</em> здесь позволяет «срезать путь» и написать более чистый код. <em>iter(s)</em> просто возвращает внутренний итератор, вызывая <em>s.<strong>iter</strong>()</em> — примерно так же, как <em>len(s)</em> вызывает <em>s.<strong>len</strong>()</em>.</p>
<h2 id="43"><a name="user-content-43" href="#43" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.3. Создание новых итерационных паттернов с помощью генераторов</h2>
<h3 id="_174"><a name="user-content-_174" href="#_174" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите реализовать собственный паттерн итераций, который будет отличаться от обычных встроенных функций (таких как <em>range()</em>, <em>reversed()</em> и т.п.)</p>
<h3 id="_175"><a name="user-content-_175" href="#_175" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если вы хотите реализовать новый тип итерационного паттерна, определите его с помощью генератора. Вот, например, генератор, который создает диапазон чисел с плавающей точкой:<br />
<pre><code class="python">def frange(start, stop, increment):
    x = start
    while x &lt; stop:
        yield x
        x += increment
</code></pre></p>
<p>Чтобы использовать такую функцию, вы должны проитерировать по ней в цикле или применить ее с какой-то другой функцией, которая потребляет итерируемый объект (например, <em>sum()</em>, <em>list()</em> и т.п.) Например:<br />
<pre><code class="python">&gt;&gt;&gt; for n in frange(0, 4, 0.5):
...     print(n)
...
0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
&gt;&gt;&gt; list(frange(0, 1, 0.125))
[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_176"><a name="user-content-_176" href="#_176" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Само присутствие инструкции <em>yield</em> в функции превращает её в генератор. В отличие от обычной функции, генератор запускается только в ответ на итерацию. Вот эксперимент, который вы можете провести, чтобы понять внутренний механизм работы таких функций:<br />
<pre><code class="python">&gt;&gt;&gt; def countdown(n):
...print('Starting to count from', n)
...while n &gt; 0:
... yield n
... n -= 1
...print('Done!')
...

&gt;&gt;&gt; # Create the generator, notice no output appears
&gt;&gt;&gt; c = countdown(3)
&gt;&gt;&gt; c
&lt;generator object countdown at 0x1006a0af0&gt;

&gt;&gt;&gt; # Run to first yield and emit a value
&gt;&gt;&gt; next(c)
Starting to count from 3
3

&gt;&gt;&gt; # Run to the next yield
&gt;&gt;&gt; next(c)
2

&gt;&gt;&gt; # Run to next yield
&gt;&gt;&gt; next(c)
1

&gt;&gt;&gt; # Run to next yield (iteration stops)
&gt;&gt;&gt; next(c)
Done!
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt;
</code></pre></p>
<p>Ключевая особенность функции-генератора состоит в том, что она запускается только в ответ на операции <em>next</em> в ходе итерирования. Когда генератор возвращает значение, итерирование останавливается. Однако цикл <em>for</em>, который обычно используется для выполнения итераций, сам заботится об этих деталях, поэтому в большинстве случаев вам не стоит волноваться о них. </p>
<h2 id="44"><a name="user-content-44" href="#44" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.4. Реализация протокола итератора</h2>
<h3 id="_177"><a name="user-content-_177" href="#_177" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы создаете собственные объекты, которые вы хотите сделать итерируемыми, и ищете простой способ реализовать протокол итератора.</p>
<h3 id="_178"><a name="user-content-_178" href="#_178" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>На текущий момент простейший способ имплементации итерируемости в объекте — это использование генератора. В <strong>рецепте 4.2.</strong> был представлен класс <em>Node</em>, представляющий древовидные структуры. Возможно, вы захотите реализовать итератор, который будет обходить узлы поиском в глубину. Вот как можно это сделать:<br />
<pre><code class="python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()

# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)
    # Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
</code></pre></p>
<p>В этой программе метод <em>depth_first()</em> просто прочесть и описать. Сначала он выдает себя, а затем итерируется по каждому потомку, выдавая элементы, производимые методом <em>depth_first()</em> потомка (используя <em>yield from</em>). </p>
<h3 id="_179"><a name="user-content-_179" href="#_179" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Протокол итератора Python требует <em><strong>iter()</strong></em>, чтобы вернуть специальный объект итератора, в котором реализована операция <em><strong>next()</strong></em>, а исключение <em>StopIteration</em> используется для подачи сигнала о завершении. Однако создание таких объектов частов может быть запутанным делом. Например, следующая программа демонстрирует альтернативную имплементацию метода <em>depth_first()</em>, использующую связанный класс итератора:<br />
<pre><code class="python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, other_node):
        self._children.append(other_node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        return DepthFirstIterator(self)

class DepthFirstIterator(object):
    '''
    Depth-first traversal
    '''

    def __init__(self, start_node):
        self._node = start_node
        self._children_iter = None
        self._child_iter = None

    def __iter__(self):
        return self

    def __next__(self):
        # Return myself if just started; create an iterator for children
        if self._children_iter is None:
            self._children_iter = iter(self._node)
            return self._node

        # If processing a child, return its next item
        elif self._child_iter:
        try:
            nextchild = next(self._child_iter)
            return nextchild
        except StopIteration:
            self._child_iter = None
            return next(self)

        # Advance to the next child and start its iteration
        else:
            self._child_iter = next(self._children_iter).depth_first()
            return next(self)
</code></pre></p>
<p>Класс DepthFirstIterator работает так же, как и версия на основе генератора, но он беспорядочен и некрасив, поскольку итератор вынужден хранить много сложных состояний о состоянии итерационного процесса. Откровенно говоря, никому не нравится писать такой мозговыносящий код. Реализуйте итератор на базе генератора и успокойтесь на этом.</p>
<h2 id="45"><a name="user-content-45" href="#45" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.5. Итерирование в обратном порядке</h2>
<h3 id="_180"><a name="user-content-_180" href="#_180" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите проитерировать по последовательности в обратном порядке.</p>
<h3 id="_181"><a name="user-content-_181" href="#_181" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Используйте встроенную функцию <em>reversed()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; for x in reversed(a):
...     print(x)
...
4
3
2
1
</code></pre></p>
<p>Обратная итерация сработает только в том случае, если объект имеет определенный размер, или если в нём реализован специальный метод <em><strong>reversed</strong>()</em>. Если ни одно из этих условий не выполнено, вы должны будете сначала конвертировать объект в список. Например:<br />
<pre><code class="python"># Print a file backwards
f = open('somefile')
for line in reversed(list(f)):
    print(line, end='')
</code></pre></p>
<p>Обратите внимание, что конвертирование итерируемого объекта в список может съесть много памяти, если список получится большим. </p>
<h3 id="_182"><a name="user-content-_182" href="#_182" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Многие программисты не знают, что итерирование в обратном порядке может быть переопределено в собственном классе, если он реализует метод <em><strong>reversed</strong>()</em>. Например<br />
<pre><code class="python">class Countdown:
    def __init__(self, start):
        self.start = start

    # Forward iterator
    def __iter__(self):
        n = self.start
        while n &gt; 0:
            yield n
            n -= 1

    # Reverse iterator
    def __reversed__(self):
        n = 1
        while n &lt;= self.start:
            yield n
            n += 1
</code></pre></p>
<p>Определение обратного итератора делает код намного более эффективным, а также отпадает необходимость предварительного помещения данных в список для выполнения итераций в обратном порядке.</p>
<h2 id="46"><a name="user-content-46" href="#46" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.6. Определение генератора с дополнительным состоянием</h2>
<h3 id="_183"><a name="user-content-_183" href="#_183" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите написать генератор, но функция работает с дополнительным состоянием, которое вам хотелось бы каким-то образом показать пользователю.</p>
<h3 id="_184"><a name="user-content-_184" href="#_184" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Если вам нужен генератор, который показывает пользователю дополнительное состояние, не забудьте, что вы можете легко реализовать его в форме класса, поместив код генератора в метод <em><strong>iter</strong>()</em>. Например:<br />
<pre><code class="python">from collections import deque

class linehistory:
    def __init__(self, lines, histlen=3):
        self.lines = lines
        self.history = deque(maxlen=histlen)

    def __iter__(self):
        for lineno, line in enumerate(self.lines,1):
            self.history.append((lineno, line))
            yield line

    def clear(self):
        self.history.clear()
</code></pre></p>
<p>Вы можете обращаться с этим классом так же, как с обычным генератором. Однако, поскольку он создает экземпляр, вы можете обращаться к внутренним атрибутам, таким как <em>history</em> или метод <em>clear()</em>. Например:<br />
<pre><code class="python">with open('somefile.txt') as f:
    lines = linehistory(f)
    for line in lines:
        if 'python' in line:
            for lineno, hline in lines.history:
                print('{}:{}'.format(lineno, hline), end='')
</code></pre></p>
<h3 id="_185"><a name="user-content-_185" href="#_185" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>С генераторами легко попасть в ловушку, если пытаться делать всё только с помощью функций. В результате может получиться сложный код, если генератору нужно взаимодействовать с другими частями программы некими необычнымыми способами (раскрытие атрибутов, разрешение на управление через вызов методов и т.п.) В этом случае просто используйте определение класса, как показано выше. Определение генератора в методе <em><strong>iter</strong>()</em> не изменит ничего в том, как вы напишете алгоритм. Но тот факт, что генератор станет частью класса, сделает простым предоставление юзерам атрибутов и методов для каких-то взаимодействий.</p>
<p>Потенциально хрупкость в показанном приёме заключается в том, что он может потребовать дополнительного шага: вызова <em>iter()</em>, если вы собираетесь провести итерацию не через цикл <em>for</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; f = open('somefile.txt')
&gt;&gt;&gt; lines = linehistory(f)
&gt;&gt;&gt; next(lines)
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'linehistory' object is not an iterator

&gt;&gt;&gt; # Call iter() first, then start iterating
&gt;&gt;&gt; it = iter(lines)
&gt;&gt;&gt; next(it)
'hello world\n'
&gt;&gt;&gt; next(it)
'this is a test\n'
&gt;&gt;&gt;
</code></pre></p>
<h2 id="47"><a name="user-content-47" href="#47" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.7. Получение среза итератора</h2>
<h3 id="_186"><a name="user-content-_186" href="#_186" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите получить срез данных, производимых итератором, но обычный оператор среза не работает.</p>
<h3 id="_187"><a name="user-content-_187" href="#_187" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Функция <em>itertools.islice()</em> отлично подходит для получения срезов генераторов и итераторов. Например:<br />
<pre><code class="python">&gt;&gt;&gt; def count(n):
...     while True:
...         yield n
...         n += 1
...
&gt;&gt;&gt; c = count(0)
&gt;&gt;&gt; c[10:20]
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'generator' object is not subscriptable

&gt;&gt;&gt; # Now using islice()
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; for x in itertools.islice(c, 10, 20):
...     print(x)
...
10
11
12
13
14
15
16
17
18
19
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_188"><a name="user-content-_188" href="#_188" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Из итераторов и генераторов получить срез напрямую нельзя, потому что отсутствует информация об их длине (и в них не реализовано индексирование). Результат <em>islice()</em> — это итератор, который создает элементы нужного среза, но делает это путем потребления и выбрасывания всех элементов до стартового индекса среза. Следующие элементы затем производятся объектом <em>islice</em>, пока не будет достигнут конечный индекс среза. </p>
<p>Важно отметить, что <em>islice()</em> будут потреблять данные, предоставляемые итератором. Это важно, поскольку итераторы не могут быть отмотаны назад. Если вам нужно возвращаться назад, то вам, наверное, лучше сначала конвертировать данные в список.</p>
<h3 id="48"><a name="user-content-48" href="#48" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.8. Пропуск первой части итерируемого объекта</h3>
<h2 id="_189"><a name="user-content-_189" href="#_189" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h2>
<p>Вы хотите итерировать по элементам в последовательности, но первые несколько элементов вам неинтересны, и вы хотите их опустить.</p>
<h3 id="_190"><a name="user-content-_190" href="#_190" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>В модуле <em>itertools</em> есть несколько функций, которые могут быть использованы для решения этой задачи. Первая — <em>itertools.dropwhile()</em>. Чтобы использовать её, вы предоставляете функцию и итерируемый объект. Возвращаемый итератор отбрасывает первые элементы в последовательности до тех пор, пока предоставленная функция возвращает True. А затем выдается вся оставшаяся последовательность. </p>
<p>Предположим, что вы читаете файл, который начинается со строчек с комментариями:<br />
<pre><code class="python">&gt;&gt;&gt; with open('/etc/passwd') as f:
... for line in f:
...     print(line, end='')
...
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode. At other times, this information is provided by
# Open Directory.
...
##
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите пропустить все начальные закомментированные строчки, вот как это можно сделать:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import dropwhile
&gt;&gt;&gt; with open('/etc/passwd') as f:
...     for line in dropwhile(lambda line: line.startswith('#'), f):
...         print(line, end='')
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
&gt;&gt;&gt;
</code></pre></p>
<p>Этот пример показывает, как можно пропустить первые элементы в соответствии с возвращаемым значением проверочной функции. Если так случилось, что вы знаете точное количество элементов, которые вы хотите пропустить, то вы можете вместо вышеописанного способа использовать <em>itertools.islice()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; items = ['a', 'b', 'c', 1, 4, 10, 15]
&gt;&gt;&gt; for x in islice(items, 3, None):
...     print(x)
...
1
4
10
15
&gt;&gt;&gt;
</code></pre></p>
<p>В этом примере последний аргумент <em>islice()</em> <em>None</em> необходим для того, чтобы обозначить, что вам нужно всё за пределами первых трёх элементов (а не первые три элемента). То есть срез [3:0], а не [:3].</p>
<h3 id="_191"><a name="user-content-_191" href="#_191" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Главное преимущество функций <em>dropwhile()</em> и <em>islice()</em> в том, что они позволяют избажеть написания грязного кода наподобие вот такого:<br />
<pre><code class="python">with open('/etc/passwd') as f:
    # Skip over initial comments
    while True:
        line = next(f, '')
        if not line.startswith('#'):
            break

# Process remaining lines
while line:
    # Replace with useful processing    
    print(line, end='')
    line = next(f, None)
</code></pre></p>
<p>Отбрасывание первой части итерируемого объекта также немного отличается от простого фильтрования. Например, первая часть этого рецепта может быть переписана вот так:<br />
<pre><code class="python">with open('/etc/passwd') as f:
    lines = (line for line in f if not line.startswith('#'))
    for line in lines:
        print(line, end='')
</code></pre></p>
<p>Очевидно, что это отбросит все закомментированные строчки в начале файла, но такое решение отбросит и все остальные такие строчки во всём файле. С другой стороны, решение, которое отбрасывает все элементы до тех пор, пока не будет встречен элемент, не соответствующий условиям отбрасывания, удовлетворяет нашим требованиям: все последующие элементы будут возвращены без фильтрования.</p>
<p>Стоит отметить, что этот рецепт работает со всеми итерируемыми объектами, включая те, размер которых нельзя оценить предварительно: генераторами, файлами и другими подобными объектами.</p>
<h2 id="49"><a name="user-content-49" href="#49" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.9. Итерирование по всем возможным комбинациям и перестановкам</h2>
<h3 id="_192"><a name="user-content-_192" href="#_192" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите проитерировать по всем возможным комбинациям и перестановкам коллекции элементов.</p>
<h3 id="_193"><a name="user-content-_193" href="#_193" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Модуль <em>itertools</em> предоставляет три функции, подходящие для этой задачи. Первая, <em>itertools.permutations()</em>, принимает коллекцию элементов и создает последовательность кортежей со всеми возможными перестановками (то есть она тасует их во всех возможных конфигурациях). Например:<br />
<pre><code class="python">&gt;&gt;&gt; items = ['a', 'b', 'c']
&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt; for p in permutations(items):
...     print(p)
...
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
&gt;&gt;&gt;
</code></pre></p>
<p>Если вы хотите получить все возможные перестановки меньшей длины, вы можете передать функции необязательный аргумент со значением длины. Например:<br />
<pre><code class="python">&gt;&gt;&gt; for p in permutations(items, 2):
...     print(p)
...
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
&gt;&gt;&gt;
</code></pre></p>
<p>Используйте <em>itertools.combinations()</em>, чтобы создать последовательность комбинаций элементов входной последовательности. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import combinations
&gt;&gt;&gt; for c in combinations(items, 3):
...     print(c)
...
('a', 'b', 'c')
&gt;&gt;&gt; for c in combinations(items, 2):
...     print(c)
...
('a', 'b')
('a', 'c')
('b', 'c')
&gt;&gt;&gt; for c in combinations(items, 1):
...     print(c)
...
('a',)
('b',)
('c',)
&gt;&gt;&gt;
</code></pre></p>
<p>Для функции <em>combinations()</em> порядок элементов не имеет значения. Поэтому комбинация (&lsquo;a&rsquo;, &lsquo;b&rsquo;) она считает аналогичной (&lsquo;b&rsquo;, &lsquo;a&rsquo;) — поэтому вторая в выводимых результатах отсутствует.</p>
<p>При создании комбинаций выбранные элементы удаляются из коллекции возможных кандидатов (то есть если &lsquo;a&rsquo; уже выбран, он больше не будет рассматриваться). А функция itertools.combinations_with_replacement() выбирает один и тот же элемент более одного раза. Например:<br />
<pre><code class="python">&gt;&gt;&gt; for c in combinations_with_replacement(items, 3):
...     print(c)
...
('a', 'a', 'a')
('a', 'a', 'b')
('a', 'a', 'c')
('a', 'b', 'b')
('a', 'b', 'c')
('a', 'c', 'c')
('b', 'b', 'b')
('b', 'b', 'c')
('b', 'c', 'c')
('c', 'c', 'c')
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_194"><a name="user-content-_194" href="#_194" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Этот рецепт показывает лишь небольшую часть мощи модуля <em>itertools</em>. Хотя вы могли бы самостоятельно написать код, который выполняет перестановки и комбинации, это, вероятно, отняло бы у вас больше пары секунд времени. Когда вы сталкиваетесь с нетривиальными задачами итераций, обратитесь к <em>itertools</em>, это всегда окупается. Если задача типичная, велик шанс того, что вы найдете готовое решение.</p>
<h2 id="410-"><a name="user-content-410-" href="#410-" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.10. Итерирование по парам «индекс-значение» последовательности</h2>
<h3 id="_195"><a name="user-content-_195" href="#_195" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите проитерировать по последовательности и при этом хранить информацию о том, какой по счёту элемент сейчас обрабатывается.</p>
<h3 id="_196"><a name="user-content-_196" href="#_196" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Встроенная функция enumerate() изящно справляется с этой задачей:<br />
<pre><code class="python">&gt;&gt;&gt; my_list = ['a', 'b', 'c']
&gt;&gt;&gt; for idx, val in enumerate(my_list):
...     print(idx, val)
...
0 a
1 b
2 c
</code></pre></p>
<p>Для печати вывода с привычными номерами строк (то есть с нумерацией, начинающейся с 1, а не с 0), вы можете передать соответствующий аргумент start:<br />
<pre><code class="python">&gt;&gt;&gt; my_list = ['a', 'b', 'c']
&gt;&gt;&gt; for idx, val in enumerate(my_list, 1):
...     print(idx, val)
...
1 a
2 b
3 c
</code></pre></p>
<p>Этот приём особенно полезен для учёта номеров строк в файлах, если нужно будет вывести номер строки в сообщении об ошибке:<br />
<pre><code class="python">def parse_data(filename):
    with open(filename, 'rt') as f:
        for lineno, line in enumerate(f, 1):
            fields = line.split()
            try:
                count = int(fields[1])
                ...
                except ValueError as e:
                    print('Line {}: Parse error: {}'.format(lineno, e))
</code></pre></p>
<p><em>enumerate()</em> удобна, например, для отслеживания смещения (offset) в списке для вхождений определенных значений. Так что если вы хотите отобразить слова в файле к строчкам, в которых они встречаются, это легко сделать с помощью enumerate() — функция отображает каждое слово на смещение строки в файле, где оно найдено:<br />
<pre><code class="python">word_summary = defaultdict(list)

with open('myfile.txt', 'r') as f:
    lines = f.readlines()

for idx, line in enumerate(lines):
    # Create a list of words in current line
    words = [w.strip().lower() for w in line.split()]
    for word in words:
        word_summary[word].append(idx)
</code></pre></p>
<p>Если вы выведете <em>word_summary</em> после обработки файла, это будет словарь (<em>default dict</em>, если быть точными), и каждое слово будет ключом. Значение для каждого ключа — список номеров строк, где встретилось это слово. Если слово встретилось дважды в одной строке, этот номер строки будет записан в список дважды, что делает возможным получение разнообразных простых метрик текста.</p>
<h3 id="_197"><a name="user-content-_197" href="#_197" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p><em>enumerate()</em> — симпатичное решение для ситуаций, где вы могли бы склоняться использованию собственной переменной-счетчика. Вы могли бы написать такой код:<br />
<pre><code class="python">lineno = 1
    for line in f:
    # Process line
    ...
    lineno += 1
</code></pre></p>
<p>Но часто более элегантным (и менее подверженным ошибкам) способом становится использование <em>enumerate()</em>:<br />
<pre><code class="python">for lineno, line in enumerate(f):
    # Process line
    ...
</code></pre></p>
<p>Значение, возвращаемое функцией <em>enumerate()</em>, является объектом <em>enumerate</em>. Это итератор, который последовательно возвращает кортежи, состоящие из счётчика и значения, возвращаемого вызовом функции <em>next()</em> для последовательности, которую вы обходите.</p>
<p>Стоит отметить, что иногда можно запутаться при применении <em>enumerate()</em> к последовательности кортежей, которые при этом распаковываются:<br />
<pre><code class="python">data = [ (1, 2), (3, 4), (5, 6), (7, 8) ]

# Correct!
for n, (x, y) in enumerate(data):
    ...

# Error!
    for n, x, y in enumerate(data):
    ...
</code></pre></p>
<h2 id="411"><a name="user-content-411" href="#411" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.11. Одновременное итерирование по нескольким последовательностям</h2>
<h3 id="_198"><a name="user-content-_198" href="#_198" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите за один раз проитерировать по элементам, содержащимися более чем в одной последовательности.</p>
<h3 id="_199"><a name="user-content-_199" href="#_199" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Чтобы итерировать по более чем одной последовательности за раз, используйте функцию <em>zip()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; xpts = [1, 5, 4, 2, 10, 7]
&gt;&gt;&gt; ypts = [101, 78, 37, 15, 62, 99]
&gt;&gt;&gt; for x, y in zip(xpts, ypts):
...     print(x,y)
...
1 101
5 78
4 37
2 15
10 62
7 99
&gt;&gt;&gt;
</code></pre></p>
<p><em>zip(a, b)</em> работает путём создания итератора, который производит кортежи (x, y), где x берётся из a, а y — из b. Итерирование останавливается, когда заканчивается одна из последовательностей. Поэтому результат будет таким же по длине, как и самая короткая из входных последовательностей. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = ['w', 'x', 'y', 'z']
&gt;&gt;&gt; for i in zip(a,b):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
</code></pre></p>
<p>Если такое поведение нежелательно, используйте функцию <em>itertools.zip_longest()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import zip_longest
&gt;&gt;&gt; for i in zip_longest(a,b):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(None, 'z')
&gt;&gt;&gt; for i in zip_longest(a, b, fillvalue=0):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(0, 'z')
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_200"><a name="user-content-_200" href="#_200" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p><em>zip()</em> обычно используется тогда, когда вам нужно создать пары из данных. Предположим, например, что у вас есть список заголовков столбцов и значения столбцов:<br />
<pre><code class="python">headers = ['name', 'shares', 'price']
values = ['ACME', 100, 490.1]
</code></pre></p>
<p>Используя <em>zip()</em>, вы можете создать пары значений и поместить их в словарь:<br />
<pre><code class="python">s = dict(zip(headers,values))
</code></pre></p>
<p>Если вы хотите вывести результат, можно поступить так:<br />
<pre><code class="python">for name, val in zip(headers, values):
    print(name, '=', val)
</code></pre></p>
<p>Менее распространённое применение <em>zip()</em> заключается в том, что функции может быть передано не две последовательности, а больше. В этом случае кортежи результата будут иметь такое количество элементов, каким было количество последовательностей. Например:<br />
<pre><code class="python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [10, 11, 12]
&gt;&gt;&gt; c = ['x', 'y', 'z']
&gt;&gt;&gt; for i in zip(a, b, c):
...     print(i)
...
(1, 10, 'x')
(2, 11, 'y')
(3, 12, 'z')
&gt;&gt;&gt;
</code></pre></p>
<p>И последнее: важно подчеркнуть, что <em>zip()</em> возвращает итератор. Если вам нужны сохраненные в списке спаренные значения, используйте функцию <em>list()</em>. Например:<br />
<pre><code class="python">&gt;&gt;&gt; zip(a, b)
&lt;zip object at 0x1007001b8&gt;
&gt;&gt;&gt; list(zip(a, b))
[(1, 10), (2, 11), (3, 12)]
&gt;&gt;&gt;
</code></pre></p>
<h2 id="412"><a name="user-content-412" href="#412" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.12. Интерирования по элементам, находящимся в отдельных контейнерах</h2>
<h3 id="_201"><a name="user-content-_201" href="#_201" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Проблема</h3>
<p>Вам нужно выполнить одинаковую операцию над большим количеством объектов, но объекты находятся в различных контейнерах, а вам хотелось бы избежать написания вложенных циклов, причем без потери читабельности кода.</p>
<h3 id="_202"><a name="user-content-_202" href="#_202" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Для упрощения этой задачи может быть использовать метод <em>itertools.chain()</em>. Он принимает список итерируемых объектов и возвращает итератор, который эффективно скрывает тот факт, что вы на самом деле работаете с несколькими контейнерами. Рассмотрим пример:<br />
<pre><code class="python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; b = ['x', 'y', 'z']
&gt;&gt;&gt; for x in chain(a, b):
...     print(x)
...
1
2
3
4
x
y
z
&gt;&gt;&gt;
</code></pre></p>
<p>Обычно <em>chain()</em> используется, если вы хотите выполнить некоторые операции над всеми элементами за один раз, но элементы разнесены по разным рабочим наборам. Например:<br />
<pre><code class="python"># Various working sets of items
active_items = set()
inactive_items = set()

# Iterate over all items
for item in chain(active_items, inactive_items):
    # Process item
    ...
</code></pre></p>
<p>Это решение намного более элегантно, нежели использование двух отдельных циклов, как показано в этом примере:<br />
<pre><code class="python">for item in active_items:
    # Process item
    ...

for item in inactive_items:
    # Process item
    ...
</code></pre></p>
<h3 id="_203"><a name="user-content-_203" href="#_203" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p><em>itertools.chain()</em> принимает один или более итерируемых объектов в качестве аргументов. Далее она создает итератор, который последовательно потребляет и возвращает элементы, производимые каждым из предоставленных итерируемых объектов. Это тонкое различие, но <em>chain()</em> эффективнее, чем итерирование по предварительно объединенным последовательностям. Например:<br />
<pre><code class="python"># Inefficent
    for x in a + b:
    ...

# Better
    for x in chain(a, b):
    ...
</code></pre></p>
<p>В первом случае операция a + b создает новую последовательность и дополнительно требует, чтобы a и b относились к одному типу. <em>chain()</em> не выполняет такую операцию, намного эффективнее обращается с памятью, если входные последовательности большие, а также легко применяется к итерируемым объектов различных типов.</p>
<h2 id="413"><a name="user-content-413" href="#413" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.13. Создание каналов для обработки данных</h2>
<h3 id="_204"><a name="user-content-_204" href="#_204" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>Вы хотите обрабатывать данные итеративно, в стиле обрабатывающего данные канала (похожего на канал — он же конвейер — Unix). Например, у вас есть огромный объем данных для обработки, который просто не поместится в память целиком.</p>
<h3 id="_205"><a name="user-content-_205" href="#_205" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Генераторы хорошо подходят для реализации обрабатывающих каналов. Предположим, например, что у вас есть огромный каталог с файлами логов, который вы хотите обработать:<br />
<pre><code>foo/
    access-log-012007.gz
    access-log-022007.gz
    access-log-032007.gz
    ...
    access-log-012008
bar/
    access-log-092007.bz2
    ...
    access-log-022008
</code></pre></p>
<p>Предположим, каждый файл содержит такие строки данных:<br />
<pre><code>124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] &quot;GET /robots.txt ...&quot; 200 71
210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /ply/ ...&quot; 200 11875
210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /favicon.ico ...&quot; 404 369
61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] &quot;GET /blog/atom.xml ...&quot; 304 -
...
</code></pre></p>
<p>Чтобы обработать эти файлы, вы могли бы создать коллекцию небольших генераторов, которые будут выполнять специфические замкнутые в себе задачи:<br />
<pre><code class="python">import os
import fnmatch
import gzip
import bz2
import re

def gen_find(filepat, top):
    '''
    Find all filenames in a directory tree that match a shell wildcard pattern
    '''
    for path, dirlist, filelist in os.walk(top):
        for name in fnmatch.filter(filelist, filepat):
            yield os.path.join(path,name)

def gen_opener(filenames):
    '''
    Open a sequence of filenames one at a time producing a file object.
    The file is closed immediately when proceeding to the next iteration.
    '''
    for filename in filenames:
        if filename.endswith('.gz'):
            f = gzip.open(filename, 'rt')
        elif filename.endswith('.bz2'):
            f = bz2.open(filename, 'rt')
        else:
            f = open(filename, 'rt')
        yield f
        f.close()


def gen_concatenate(iterators):
    '''
    Chain a sequence of iterators together into a single sequence.
    '''
    for it in iterators:
        yield from it

def gen_grep(pattern, lines):
    '''
    Look for a regex pattern in a sequence of lines
    '''
    pat = re.compile(pattern)
    for line in lines:
        if pat.search(line):
            yield line
</code></pre></p>
<p>Теперь вы можете легко совместить эти функции для создания обрабатывающего канала. Например, чтобы найти все файлы логов, которые содержат слово <em>python</em>, вы можете поступить так:<br />
<pre><code class="python">lognames = gen_find('access-log*', 'www')
files = gen_opener(lognames)
lines = gen_concatenate(files)
pylines = gen_grep('(?i)python', lines)
for line in pylines:
    print(line)
</code></pre></p>
<p>Если вы хотите еще расширить канал, вы можете скармливать данные выражениям-генераторам. Например, эта версия находит количество переданных байтов и подсчитывает общую сумму:<br />
<pre><code class="python">lognames = gen_find('access-log*', 'www')
files = gen_opener(lognames)
lines = gen_concatenate(files)
pylines = gen_grep('(?i)python', lines)
bytecolumn = (line.rsplit(None,1)[1] for line in pylines)
bytes = (int(x) for x in bytecolumn if x != '-')
print('Total', sum(bytes))
</code></pre></p>
<h3 id="_206"><a name="user-content-_206" href="#_206" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Обработка данных в «каналообразной» манере отлично работает для решения широкого спектра задач: парсинга, чтения из риалтаймовых источников данных, периодического опрашивания и т.д.</p>
<p>В понимании представленного выше кода главное уловить, что инструкция <em>yield</em> действует как своего рода производитель данных для цикла <em>for</em>, который действует как потребитель данных. Когда генераторы соединены, каждый <em>yield</em> скармливает один элемент данных следующему этапу канала, который потребляет его, совершая итерацию. В последнем примере функция <em>sum()</em> управляет всей программой, вытягивая один элемент за другим из канала (конвейера) генераторов.</p>
<p>Приятная возможность этого подхода заключается в том, что каждый генератор является маленьким и замкнутым на себе, поэтому их легко писать и поддерживать. Во многих случаях они получаются настолько универсальными, что могут быть переиспользованы в других контекстах. Получающийся код, который «склеивает» компоненты вместе, тоже обычно читается как простой для понимания рецепт. </p>
<p>Есть небольшая тонкость с использованием функции <em>gen_concatenate()</em>. Ее назначение — конкатенировать входные последовательности в одну длинную последовательность строк. <em>itertools.chain()</em> выполняет похожую функцию, но требует, чтобы все объединяемые итерируемые объекты были определены в качестве аргументов. В случае этого конкретного рецепта, такой подход потребовал бы инструкции типа <em>lines = itertools.chain(*files)</em>, которая заставила бы генератор <em>gen_opener()</em> быть полностью потребленным. Поскольку генератор производит последовательность открытых файлов, которые немедленно закрываются на следующем шаге итерации, <em>chain()</em> использовать нельзя. Показанное решение позволяет решить эту проблему.</p>
<p>Также в функции <em>gen_concatenate()</em> используется <em>yield from</em> для делегирования субгенератору. Объявление <em>yield from it</em> просто заставляет <em>gen_concatenate()</em> выдать все значения, произведенные генератором <em>it</em>. Это описано далее, в <strong>рецепте 4.14.</strong></p>
<p>И последнее: стоит отметить, что «конвейерный» («канальный») подход не работает для всех на свете задач обработки данных. Иногда вам просто необходимо работать со всеми данными сразу. Однако, даже в этом случае, использование каналов генераторов может стать путём логического разбиения задачи. </p>
<p>Дэвид Бизли подробно написать об этих приёмах в обучающющей презентации <a href="http://www.dabeaz.com/generators">«Трюки с генераторами для системных программистов»</a>. Если вам нужны дополнительные примеры, обратитесь к ней.</p>
<h2 id="414"><a name="user-content-414" href="#414" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>4.14. Превращение вложенной последовательности в плоскую</h2>
<h3 id="_207"><a name="user-content-_207" href="#_207" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Задача</h3>
<p>У вас есть вложенная последовательность, и вы хотите превратить ее в один плоский список значений.</p>
<h3 id="_208"><a name="user-content-_208" href="#_208" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Решение</h3>
<p>Это легко решается с помощью рекурсивного генератора с инструкцией <em>yield from</em>. Например:<br />
<pre><code class="python">from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]

# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)
</code></pre></p>
<p>В этой программе <em>isinstance(x, Iterable)</em> просто проверяет, является ли элемент итерируемым объектом. Если это так, то <em>yield from</em> используется в качестве некой подпрограммы, чтобы выдать все его значения. Конечный результат — одна последовательность без вложенности.</p>
<p>Дополнительный аргументы <em>ignore_types</em> и проверка <em>not isinstance(x, ignore_types)</em> нужны для предотвращения определения строк и байтов как итерируемых последовательностей, без чего они были бы разбиты на отдельные символы. Это позволяет вложенным спискам строк работать так, как большинство людей этого и ожидают:<br />
<pre><code class="python">&gt;&gt;&gt; items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
&gt;&gt;&gt; for x in flatten(items):
...     print(x)
...
Dave
Paula
Thomas
Lewis
&gt;&gt;&gt;
</code></pre></p>
<h3 id="_209"><a name="user-content-_209" href="#_209" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Обсуждение</h3>
<p>Инструкция <em>yield from</em> — отличный способ написания генераторов, которые вызывают другие генераторы в качестве подпроцедуры. Без использования этой инструкции вам придется вставить в код дополнительный цикл. Например:<br />
<pre><code class="python">def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            for i in flatten(x):
                yield i
        else:
            yield x
</code></pre></p>
<p>Хотя это незначительное изменение, инструкция <em>yield from</em> просто приятнее и делает код чище.</p>
<p>Как было отмечено, дополнительная проверка на строки и байты нужна для предотвращения их разбивки на отдельные символы. Если есть еще какие-то типы, которые вы не хотите раскрывать, вы просто можете передать другие значения в <em>ignore_types</em>.</p>
<p>Стоит отметить, что <em>yield from</em> играет более важную роль в продвинутых программах, использующих корутины и основанную на генераторах многопоточность. См. другой пример в <strong>рецепте 12.12.</strong></p></article></body></html>