# 1. Структуры данных и алгоритмы #

Python предоставляет широкий спектр встроенных структур данных, таких как списки, множества и словари. Использовать эти структуры по большей части просто. Однако часто возникают общие вопросы, касающиеся поиска, сортировки, изменения порядка элементов и фильтрования. Цель этой главы — обсудить обычные стуктуры данных и алгоритмы. Также будет дано введение в разнообразные структуры данных из модуля *collections*.

## 1.1. Распаковка последовательности в отдельные переменные ##

### Проблема ###
У вас есть кортеж из N элементов или последовательность, которую вы хотите распаковать в коллекцию из N переменных.

### Решение
Любая последовательность (или итерируемый объект) могут быть распакованы в переменные с помощью простого присваивания. Единственное обязательное условие заключается в том, чтобы количество и структура переменных совпадали с последовательностью. Например:
``` python
>>> p = (4, 5)
>>> x, y = p
>>> x
4
>>> y
5
>>>
```

``` python
>>> data = ['ACME', 50, 91.1, (2012, 12, 21)]
>>> name, shares, price, date = data
>>> name
'ACME'
>>> date
(2012, 12, 21)
```

``` python
>>> name, shares, price, (year, mon, day) = data
>>> name
'ACME'
>>> year
2012
>>> mon
12
>>> day
21
>>>
```

При несовпадении количества элементов вы получите ошибку. Например:
``` python
>>> p = (4, 5)
>>> x, y, z = p
Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
ValueError: need more than 2 values to unpack
>>>
```

### Обсуждение ###
Распаковка работает с любым итерируемым объектом, а не только с кортежами и списками. Это строки, файлы, итераторы и генераторы. Например:
``` python
>>> s = 'Hello'
>>> a, b, c, d, e = s
>>> a
'H'
>>> b
'e'
>>> e
'o'
>>>
```

При распаковке вы иногда можете захотеть отбраковать некоторые значения. Специального синтаксиса для этого в Python нет, но вы можете назначить «выбрасываемые» переменные. Например:
``` python
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>
```

Но убедитесь, что вы уже не использовали где-то эту переменную.


## 1.2. Распаковка элементов из последовательностей произвольной длины ##

### Проблема ###
Вам нужно распаковать N элементов из итерируемого объекта, но этот объект может содержать больше N элементов, что вызывает исключение "too many values to unpack" («слишком много значений для распаковки»).

### Решение ###
Для решения этой задачи могут быть использованы «выражения со звёздочкой». Предположим, например, что вы ведете учебный курс и решаете в конце семестра, что вы не будете принимать во внимание оценки за первое и последнее домашние задания, а по остальным оценкам посчитаете среднее значение. Если у вас было четыре задания, то можно просто распаковать все четыре. Но что делать, если их 24? Выражения со звёздочкой позволяют легко решить проблему:
``` python
def drop_first_last(grades):
	first, *middle, last = grades
	return avg(middle)
```

Рассмотрим еще один пример: предположим, что у вас есть записи о юзерах, которые состоят из имени и email, за которыми следует произвольное количество телефонных номеров. Вы можете распаковать записи так:
``` python
>>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
>>> name, email, *phone_numbers = user_record
>>> name
'Dave'
>>> email
'dave@example.com'
>>> phone_numbers
['773-555-1212', '847-555-1212']
>>>
```

Стоит отметить, что переменная phone_numbers всегда будет списком, несмотря на то, сколько телефонных номеров распаковано (даже если и ни одного). Любой код, который использует phone_numbers не должен учитывать возможность, что в этой будет не список, или производить дополнительные проверки.

Переменная со звёздочкой также может быть первой в списке. Например, у вас есть последовательность значений, представляющая продажи вашей компании за последние восемь кварталов. Если вы хотите посмотреть, как последний квартал соотносится со средним значением по первым семи, вы можете сделать так:
```python
*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
```

Интерпретатор Python выдаст:
```python
>>> *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
>>> trailing
[10, 8, 7, 1, 9, 5, 10]
>>> current
3
```

### Обсуждение ###
Расширенная распаковка отлично подходит для распаковки итерируемых объектов неизвестной или произвольной длины. Часто эти объекты имеют некоторые известные элементы или паттерны (например, «всё, что после элемента 1, является телефонным номером»), и распаковка со звёздочкой позволяет программисту легко использовать эти паттерны — вместо того, чтобы исполнять акробатические трюки для извлечения нужных элементов из итерируемого объекта.

Стоит отметить, что синтаксис звёздочки может быть особенно полезен при итерировании по последовательности кортежей переменной длины. Например, возможна такая последовательность кортежей с тегами:
```python
records = [
	('foo', 1, 2),
	('bar', 'hello'),
	('foo', 3, 4),
]

def do_foo(x, y):
	print('foo', x, y)

def do_bar(s):
	print('bar', s)

for tag, *args in records:
	if tag == 'foo':
		do_foo(*args)
	elif tag == 'bar':
		do_bar(*args)
```

Распаковка со звёздочкой также может быть полезна в комбинации с операциями обработки строк, такими как разрезание. Например:
```python
>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
>>> uname, *fields, homedir, sh = line.split(':')
>>> uname
'nobody'
>>> homedir
'/var/empty'
>>> sh
'/usr/bin/false'
>>>
```

Иногда вам может быть нужно распаковать значения и выбросить их. Вы не можете просто определить голую * при распаковке, но вы можете использовать обычное для выбрасывания имя переменной, такое как _ или ign (ignored). Например:
```python
>>> record = ('ACME', 50, 123.45, (12, 18, 2012))
>>> name, *_, (*_, year) = record
>>> name
'ACME'
>>> year
2012
>>>
```

Есть некоторая схожесть между распаковкой со звёздочкой и обработкой списков в функциональных языках. Например, если у вас есть список, то вы можете легко разделить его на «хвост» и «голову»:
```python
>>> items = [1, 10, 7, 4, 5, 9]
>>> head, *tail = items
>>> head
1
>>> tail
[10, 7, 4, 5, 9]
>>>
```

Можно представить себе функцию, которая произведет такое разрезание с помощью хитрого рекурсивного алгоритма. Например:
```python
>>> def sum(items):
...   head, *tail = items
...   return head + sum(tail) if tail else head
...
>>> sum(items)
36
>>>
```

Однако вам следует знать, что рекурсия не относится к числу сильных сторон Python из-за внутреннего лимита на рекурсию. Поэтому последний пример на практике оказывается просто любопытным предметом для размышления.


## 1.3. Оставление N последних элементов ##
### Задача ###
Вы хотите хранить ограниченную историю из нескольких последних элементов, полученных в ходе итерации или какого-то другого процесса обработки данных.

### Решение ###
Хранение ограниченной истории — отличный повод применить *collections.deque*. Например, следующий отрывок кода производит простое сопоставление текста с последовательностью строк и при совпадении выдает совпадающие строки вместе с N предыдущими строками контекста:
```python
from collections import deque
def search(lines, pattern, history=5):
	previous_lines = deque(maxlen=history)
	for line in lines:
		if pattern in line:
			yield line, previous_lines
		previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
	with open('somefile.txt') as f:
		for line, prevlines in search(f, 'python', 5):
			for pline in prevlines:
				print(pline, end='')
		print(line, end='')
		print('-'*20)
```

### Обсуждение ###
При написании программы для поиска элементов обычно используют функцию-генератор, содержащую *yield* (как и показано в вышеприведенном примере). Это отделяет процесс поиска от кода, который использует результаты. Если вы новичок в обращении с генераторами, см. **Рецепт 4.3.**

Использование *deque(maxlen=N)* создает очередь фиксированной длины. Когда новые элементы добавлены и очередь заполнена, самый старый элемент автоматически удаляется. Пример:
```python
>>> q = deque(maxlen=3)
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3], maxlen=3)
>>> q.append(4)
>>> q
deque([2, 3, 4], maxlen=3)
>>> q.append(5)
>>> q
deque([3, 4, 5], maxlen=3)
```

Хотя вы можете вручную производить такие операции над списком (то есть добавление в конец, удаление и т.п.), решение с использованием очереди элегантнее и работает намного быстрее.

Обобщим: дека может быть использована в любом случае, когда вам нужна простая очередь. Если вы не задатите максимальную длину, вы получите бесконечную очередь, которая позволит вам добавлять и удалять элементы с обоих концов. Например:
```python
>>> q = deque()
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3])
>>> q.appendleft(4)
>>> q
deque([4, 1, 2, 3])
>>> q.pop()
3
>>> q
deque([4, 1, 2])
>>> q.popleft()
4
```

Добавление или удаление элементов с любого из концов очереди имеет сложность O(1). А вот добавление или удаление элемента в начало списка имеет сложность O(N).


## 1.4. Поиск N максимальных и минимальных элементов 
### Задача ###
Вы хотите создать список N максимальных или минимальных элементов коллекции.

### Решение ###
У модуля *heapq* есть две функции, nlargest() и nsmallest(), которые делают именно то, что вам нужно. Например:
```python
import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
```

Обе функции таке принимают ключевой параметр, который позволяет использовать их с более сложными структурами данных. Например:
```python
portfolio = [
	{'name': 'IBM', 'shares': 100, 'price': 91.1},
	{'name': 'AAPL', 'shares': 50, 'price': 543.22},
	{'name': 'FB', 'shares': 200, 'price': 21.09},
	{'name': 'HPQ', 'shares': 35, 'price': 31.75},
	{'name': 'YHOO', 'shares': 45, 'price': 16.35},
	{'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
```

### Обсуждение ###
Если вы ищете N наименьших или N наибольших элементов, причем N невелико по сравнению с общим размером коллекции, эти функции покажут великолепную производительность. «Под капотом» они начинают работу с конвертирования данных в список, где данные упорядочены как куча. Например:
```python
>>> nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
>>> import heapq
>>> heap = list(nums)
>>> heapq.heapify(heap)
>>> heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
>>>
``` 

Самое важная возможность кучи состоит в том, что heap[0] всегда будет наименьшим элементом. Кроме того, последующие элементы могут быть легко найдены с помощью метода heapq.heappop(), который удаляет первый элемент и заменяет его следующим наименьшим элементом (это требует O(log N) операций, где N — размер кучи). Например, чтобы найти три наименьших элемента, вы могли бы сделать это:
```python
>>> heapq.heappop(heap)
-4
>>> heapq.heappop(heap)
1
>>> heapq.heappop(heap)
2
```

Функции nlargest() и nsmallest() лучше всего подходят, если вы пытаетесь найти относительно небольшое количество элементов. Если вы просто хотите найти один наибольший или наименьший элемент (N = 1), функции min() и max() будут быстрее. Похожим образом, если N сопоставимо с размером самой коллекции, обычно будет быстрее отсортировать их и взять срез (то есть сделать sorted(items)[:N] или orted(items)[-N:]). Стоит отметить, что реальная имплементация nlargest() и nsmallest() работает гибко и выполняет некоторые из этих оптимизаций самостоятельно (например, использует сортировку, если размер N близок к размеру входящих данных).

Хотя использовать этот рецепт необязательно, имплементация кучи интересна и заслуживает изучения. Информацию об этом можно найти в любой приличной книге по алгоритмам и структурам данных. В документации модуля *heapq* также обсуждаются детали внутренней имплементации.

## 1.5. Имплементация очереди с приоритетом ##
### Задача ###
Вы хотите реализовать очередь, которая сортирует элементы по заданному приоритету и всегда возвращает элемент с наивысшим приоритетом при каждой операции получения (удаления) элемента.

### Решение
Приведенный ниже класс использует модуль *heapq* для реализации простой очереди с приоритетом.

```python
import heapq

class PriorityQueue:
	def __init__(self):
		self._queue = []
		self._index = 0
	
	def push(self, item, priority):
		heapq.heappush(self._queue, (-priority, self._index, item))
		self._index += 1

def pop(self):
		return heapq.heappop(self._queue)[-1]
```

А вот пример использования:
```python
>>> class Item:
...   def __init__(self, name):
...   self.name = name
...   def __repr__(self):
...   return 'Item({!r})'.format(self.name)
...
>>> q = PriorityQueue()
>>> q.push(Item('foo'), 1)
>>> q.push(Item('bar'), 5)
>>> q.push(Item('spam'), 4)
>>> q.push(Item('grok'), 1)
>>> q.pop()
Item('bar')
>>> q.pop()
Item('spam')
>>> q.pop()
Item('foo')
>>> q.pop()
Item('grok')
>>>
```    

Посмотрите, как первая операция pop() возвращает элемент с наивысшим приоритетом. Также пронаблюдайте, как два элемента с одинаковым приоритетом (foo и grok) были возвращены в том же порядке, в каком они были помещены в очередь.

### Обсуждение ###
Суть этого рецепта заключается в использовании модуля *heapq*. Функции heapq.heappush() и heapq.heappop() вставляют и удаляют элементы из list_queue таким образом, что первый элемент в списке имеет наименьший приоритет (как обсуждалось в **рецепте 1.4.**). Метод heappop() всегда возвращает «наименьший» элемент, что является ключом к тому, чтобы заставить очередь удалять правильные элементы. Кроме того, так как операции вталкивания и снятия имеют сложность O(log N), где N — число элементов в куче, то они являются вполне эффективными даже для весьма больших значений N.

В этом рецепте очередь состоит из кортежей формата *(-priority, index, item)*. Значение приоритета сделано отрицательным, чтобы заставить очередь сортировать элементы от наибольшего к наименьшему приоритету. Это противоположно обычному порядку сортировки кучи (от наименьшего к наибольшему значению).

Роль переменной *index* заключается в установлении правильного порядка элементов с одинаковым приоритетом. Поддержание постоянно увеличивающегося индекса позволяет сортировать элементы в соответствии с порядком, в каком они были вставлены. Однако индекс такде выполняет важную роль в выполнении операций сравнения при работе с элементами с одинаковыми значениями приоритета. 

Если остановиться на этом подробнее, то отметим, что экземпляры класса *Item* не могут быть упорядочены. Например:
```python
>>> a = Item('foo')
>>> b = Item('bar')
>>> a < b
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Если вы создаете кортежи *(priority, item)*, то их можно сравнивать до тех пор, пока приоритеты различны. Однако же если сравниваются два кортежа с равными приоритетами, то сравнение не может быть проведено (как и ранее). Например:
```python
>>> a = (1, Item('foo'))
>>> b = (5, Item('bar'))
>>> a < b
True
>>> c = (1, Item('grok'))
>>> a < c
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Вводя дополнительный индекс и создавая кортежи *(priority, index, item)*, вы избегаете этой проблемы полностью, поскольку два кортежа никогда не будут иметь одинаковые значения переменной *index* (и Python никогда не будет сравнивать остальные значения в кортежах, если результат сравнения уже определен):
```python
>>> a = (1, 0, Item('foo'))
>>> b = (5, 1, Item('bar'))
>>> c = (1, 2, Item('grok'))
>>> a < b
True
>>> a < c
True
>>>
```

Если вы хотите использовать эту очередь для коммуникации между потоками (тредами), вы должны добавить правильную блокировку и передачу сигналов (cм. **рецепт 12.3.**).  

Документация модуля *heapq* содержит дополнительные примеры и обсуждения теории и имплементации куч.


## 1.6. Отображение ключей на множественные значения в словаре ##
### Задача ###
Вы хотите создать словарь, который отображает ключи на более чем одно значение (так называемый «мультисловарь», multidict).

### Решение
Словарь — это отображение, где каждый ключ отображен на единственное значение. Если вы хотите отобразить ключи на множественные значения, вам нужно хранить множественные значения в другом контейнере, таком как список или множество. Например, вы можете создавать такие словари:
```python
d = {
	'a' : [1, 2, 3],
	'b' : [4, 5]
}

e = {
	'a' : {1, 2, 3},
	'b' : {4, 5}
}
```

Выбор того, использовать или не использовать списки или множества, зависит от того, как будет использован мультисловарь. Применяйте список, если вы хотите сохранить порядок, в котором добавлены элементы. Применяйте множество, если вы хотите устранить дубликаты (и при этом не беспокоитесь о порядке элементов).

Чтобы легко создавать такие словари, вы можете использовать *defaultdict* из модуля *collections*. Фишка *defautdict* заключается в автоматической инициализации первого значения, так что вы можете сосредоточиться на добавлении элементов. Например:
```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
...

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
...
```

Одно предупреждение: *defaultdict* автоматически создаст записи словаря для ключей, к которым позже будет осуществлен доступ (даже если их в данный момент в словаре нет). Если такое поведение нежелательно, вы можете использовать *setdefault()* на обычном словаре. Например:
```python
d = {}  # A regular dictionary
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)
...
```

Однако многие программисты находят *setdefault()* несколько неестественным — и это если не учитывать тот факт, что он всегда создает новый экземпляр первоначального значения при каждом вызове (в примере это пустой список []).

### Обсуждение ###
Конструирование словарей с множественными значениями не является чем-то сложным. Однако инициализация первого значения может быть запутанной, если вы пытаетесь сделать это самостоятельно. Например, вы можете написать что-то такое:
```python
d = {}
for key, value in pairs:
	if key not in d:
		d[key] = []
	d[key].append(value)
``` 

Использование *defaultdict* приводит к намного более чистому коду:
```python
d = defaultdict(list)
for key, value in pairs:
	d[key].append(value)
```

Этот рецепт сильно связан с проблемой группировки записей в задачах обработки данных. Посмотрите, например, рецепт **1.15.**

## 1.7. Поддержание порядка в словарях 
### Задача
Вы хотите создать словарь, и вы также хотите контролировать порядок элементов при итерировании или сериализации.

### Решение
Чтобы контролировать порядок элементов в словаре, вы можете использовать *OrderedDict* из модуля *collections*. Он в точности сохраняет изначальный порядок добавления данных при итерировании. Например:
```python
 from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
	print(key, d[key])
```

*OrderedDict* особенно полезен, когда вы хотите создать отображение, которое вы в дальнейшем собираетесь сериализовать или закодировать в другой формат. Например, если вы хотите строго контролировать порядок полей, выводимых в JSON, вам нужно просто создать *OrderedDict* с нужными данными:
```python
>>> import json

>>> json.dumps(d)
'{"foo": 1, "bar": 2, "spam": 3, "grok": 4}'
>>>
```

### Обсуждение
*OrderedDict* внутри себя поддерживает двусвязный список, который упорядочивает ключи в соответствии с порядком добавления. Когда новый элемент вставляется впервые, он помещается в конец этого списка. Последующее связывание значения с существующим ключом не изменяет порядок.

Заметьте, что размер *OrderedDict* более чем в два раза превышает размер обычного словаря из-за содержащегося внутри дополнительного списка. А если вы собираетесь создать структуру данных, в которой будет большое число экземпляров *OrderedDict* (например, вы хотите прочитать 100 000 строк CSV-файла в список экземпляров *OrderedDict*), вам стоит изучить требования вашего приложения, чтобы решить, перевесят ли преимущества использования *OrderedDict* оверхед на дополнительную память. 

## 1.8. Вычисления в словарях
### Задача
Вы хотите проводить различные вычисления (например, поиск минимального и максимального значения, сортировку) в словаре с данными.

### Решение
Рассмотрим словарь, который отображает тикеры (названия) акций на цены:
```python
prices = {
	'ACME': 45.23,
	'AAPL': 612.78,
	'IBM': 205.55,
	'HPQ': 37.20,
	'FB': 10.75
}
```

Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно обратить ключи и значения, используя функцию zip(). Например, вот так можно найти минимальную и максимальную цену, а также соответствующий тикер:
```python
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')

max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
```

Похожим образом для ранжирования данных можно использовать zip() с sorted(), как показано ниже:
```python
prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
# 					(45.23, 'ACME'), (205.55, 'IBM'),
# 					(612.78, 'AAPL')]
``` 

Когда вы производите эти вычисления, обратите внимание, что zip() создает итератор, по которому можно пройти только один раз. Например, следующий фрагмент кода — неправильный:
```python
prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names))  # OK
print(max(prices_and_names))  # ValueError: max() arg is an empty sequence
```

### Обсуждение 
Если вы попытаетесь выполнить обычные обработки данных на словаре, то вы обнаружите, что они обрабатывают только ключи, но не значения. Например:
```python
min(prices)  # Returns 'AAPL'
max(prices)  # Returns 'IBM'
```

Вероятно, это не то, чего вы хотели добиться, поскольку вы пытались выполнить вычисления с использованием значений словаря. Вы можете попробовать исправить это, используя метод словаря values():
```python
min(prices.values())  # Returns 10.75
max(prices.values())  # Returns 612.78
``` 

К несчастью, это часто тоже не позволит вам добиться желаемого. Например, вы можете хотеть знать соответствующие ключи (т.е., у каких акций самая низкая цена?)

Вы можете получить ключ, соответствующий минимальному или максимальному значению, если вы передадите функцию в функции min() и max(). Например:
```python
min(prices, key=lambda k: prices[k])  # Returns 'FB'
max(prices, key=lambda k: prices[k])  # Returns 'AAPL'
```

Однако чтобы получить минимальное значение, вам потребуется дополнительное обращение. Например:
```python
min_value = prices[min(prices, key=lambda k: prices[k])]
```

Решение с использованием функции zip() решает задачу путем «обращения» словаря в последовательность пар (value, key). Когда выполняется сравнение таких кортежей, элемент value сравнивается первым, а key — следующим. Это дает вам то самое поведение, которое вы хотите, и которое позволяет проводить обработки и сортировку словаря с использованием единственного выражения.

Стоит отметить, что в вычислениях с использованием пар (value, key) key будет использован, чтобы определить результат в экземплярах, где множественные записи имеют одинаковые value. Например, в вычислениях min() и max() запись с наименьшим или наибольшим ключом будет возвращена, если найдутся дублированные (одинаковые) значения (value). Например:
```python
>>> prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
>>> min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
>>> max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
>>>
```  

## 1.9. Поиск общих элементов в двух словарях
### Задача
У вас два словаря, и вы хотите выяснить, что у них общего (одинаковые ключи, значения и т.п.)

### Решение
Рассмотрим два словаря:
```python
a = {
	'x' : 1,
	'y' : 2,
	'z' : 3
}

b = {
	'w' : 10,
	'x' : 11,
	'y' : 2
}
```

Чтобы найти общие элементы, просто выполните обычный набор операций с использовением методов keys() и items(). Например:
```python
# Find keys in common
a.keys() & b.keys()  # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys()  # { 'z' }
# Find (key,value) pairs in common
a.items() & b.items() # { ('y', 2) }
```

Операции такого типа также могут быть использованы для изменения или фильтрования содержимого словаря. Предположим, например, что вы хотите создать новый словарь, в котором некоторые ключи удалены. Взгляните на этот пример кода генератора словаря (dictionary comprehension):
```python
# Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
```

### Обсуждение
Словарь — это отображение множества ключей на множество значений. Метод словаря keys() возвращает объект просмотра ключей (keys-view object). Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над множествами (объединения, пересечения, разности и т.п.) Так что если вам нужно выполнить этот набор операций над ключами словаря, вы можете использовать объект просмотра напрямую, без предварительного конвертирования в множество.

Метод словаря items() возвращает объект просмотра элементов, состоящий из пар (key, value). Этот объект поддерживает похожий набор операций и может быть использован для выполнения таких операций, как поиск того, какие пары ключ-значение являются общими для двух словарей.

Хотя метод словаря values() похож на предыдущие, он не поддерживает операции над множествами, описанные выше в этом рецепте. Это происходит, в частности, по причине того, что, в отличие от ключей, элементы объекта просмотра значений могут быть и не уникальными. Один этот факт делает применение к ним операций над множествами малополезным. Если же, однако, вы вынуждены выполнить такие операции, этого можно добиться путем простой предварительного конвертирования значений в множество.

## 1.10. Удаление дубликатов из последовательности с сохранением порядка элементов
### Задача
Вы хотите исключить дублирующиеся значения из последовательности, но при этом сохранить порядок следования оставшихся элементов. 

### Решение 
Если значения в последовательности являются хэшируемыми, задача может быть легко решена с использованием множества и генератора. Например:
```python
def dedupe(items):
	seen = set()
	for item in items:
		if item not in seen:
			yield item
			seen.add(item)
```

Вот пример использования этой функции:
```python
>>> a = [1, 5, 2, 1, 9, 1, 5, 10]
>>> list(dedupe(a))
[1, 5, 2, 9, 10]
>>>
```

Это будет работать только в том случае, если элементы последовательности хэшируются. Если вы пытаетесь удалить дубликаты в последовательности из нехэшируемых типов (таких как словари), вы можете внести небольшое изменение в этот рецепт. Например, такое:
```python
def dedupe(items, key=None):
	seen = set()
	for item in items:
		val = item if key is None else key(item)
		if val not in seen:
			yield item
			seen.add(val)
```

Аргумент key здесь нужен для определения функции, которая конвертирует элементы последовательности в хэшируемый тип, подходящий для поиска дубликатов. Вот как это работает:
```python
>>> a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
>>> list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
>>> list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
>>>
```

Последнее решение также отлично работает, если вам нужно удалить дубликаты, базируясь на значении одного поля или атрибута или более крупной структуры данных.

### Обсуждение
Если всё, что вы хотите сделать, это просто удалить дубликаты, то часто достаточно создать множество. Например:
```python
>>> a
[1, 5, 2, 1, 9, 1, 5, 10]
>>> set(a)
{1, 2, 10, 5, 9}
>>>
```

Однако этот поход не сохраняет какой бы то ни было порядок, поэтому результат будет перемешан. Показанный выше решения помогают избежать этого. 

Использование функции-генератора в этом рецепте отражает тот факт, что вы наверняка хотите написать функцию максимально широкого назначения, а не напрямую привязанную к обработке списков. Например, если вы хотите читать файл, удаляя дублирующиеся строки, вы можете сделать так:
```python
with open(somefile,'r') as f:
	for line in dedupe(f):
		...
```

Передача ключевой функции в качестве аргумента имитирует похожую возможность во встроенных функциях, таких как sorted(), min() и max(). См., например, рецепты **1.8** и **1.13.**

## 1.11. Присваивание имён срезам
### Задача
Ваша программа превратилась в нечитабельную массу индексов срезов, и вы хотите всё это расчистить.

### Решение
Предположим, что у вас есть код, который вытаскивает определенные поля с данными из строковых записей с фиксированным набором полей (то есть из файла с плоской структурой или похожего формата):
```python
###### 0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:32]) * float(record[40:48])
``` 

Вместо этого вы вполне можете присвоить срезам имена:
```python
SHARES = slice(20,32)
PRICE  = slice(40,48)

cost = int(record[SHARES]) * float(record[PRICE])
```

В последнем примере вы избежали появления кучи загадочных индексов, и код стал проще и яснее.

### Обсуждение
Общее правило таково: написание кода с большим количеством неоформленных индексов ведет к проблемам с читабельностью и поддерживаемостью. Например, если вы вернетесь к такому коду через год, то наверняка не сразу вспомните, как и о чём вы думали, когда всё это писали. Приведённое выше решение — простой путь к более ясному обозначению того, что делает ваш код. 

В общем, встроенная функция slice() создает объект среза, который может быть использован везде, где можно бы использовать обычные срезы. Например:
```python
>>> items = [0, 1, 2, 3, 4, 5, 6]
>>> a = slice(2, 4)
>>> items[2:4]
[2, 3]
>>> items[a]
[2, 3]
>>> items[a] = [10,11]
>>> items
[0, 1, 10, 11, 4, 5, 6]
>>> del items[a]
>>> items
[0, 1, 4, 5, 6]
```

Если у вас есть экземпляр *slice* s, вы можете получить больше информации о нём, если посмотрите на атрибуты s.start, s.stop и s.step. Например:
```python
>>> a = slice(10, 50, 2)
>>> a.start
10
>>> a.stop
50
>>> a.step
2
>>>
```

Также вы можете наложить срез на последовательность определенного размера, используя его метод indices(size). Он возвращает кортеж (start, stop, step), где все значения соответственно ограничены, чтобы вписаться в границы (для избегания исключений IndexError при индексировании). Например:
```python
>>> s = 'HelloWorld'
>>> a.indices(len(s))
(5, 10, 2)
>>> for i in range(*a.indices(len(s))):
...   print(s[i])
...
W
r
d
>>>
```

## 1.12. Определение наиболее часто встречающихся элементов в последовательности
### Проблема
У вас есть последовательность элементов, и вы хотите узнать, какие элементы встречаются в ней чаще всего.

### Решение
Класс *collections.Counter* разработан как раз решения для подобных задач. В нем даже есть удобный метод *most_common()*, который сразу выдаст вам ответ.

Чтобы проиллюстрировать это, предположим, что у вас есть список слов, и вы хотите найти наиболее часто встречающееся. Вот как можно это сделать:
```python
words = [
	'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
	'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
	'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
	'my', 'eyes', "you're", 'under'
]

from collections import Counter

word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
```

### Обсуждение
На входе объектам класса *Counter* можно скормить любую последовательность хэшируемых элементов. Под капотом *Counter* — это словарь, который отображает элементы на количество вхождений. Например:
```python
>>> word_counts['not']
1
>>> word_counts['eyes']
8
>>>
```

Если вы хотите увеличить счёт вручную, используйте сложение:
```python
>>> morewords = ['why','are','you','not','looking','in','my','eyes']
>>> for word in morewords:
...   word_counts[word] += 1
...
>>> word_counts['eyes']
9
>>>
```

Или же вы можете использовать метод *update()*:
```python
>>> word_counts.update(morewords)
>>>
```

Малоизвестная возможность экземпляров Counter состоит в том, что они могут быть легко скомбинированы с использованием разнообразных математических операций. Например:
```python
>>> a = Counter(words)
>>> b = Counter(morewords)
>>> a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1, 'not': 1})
>>> b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
		'my': 1, 'why': 1})

>>> # Combine counts
>>> c = a + b
>>> c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
		'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,
		'looking': 1, 'are': 1, 'under': 1, 'you': 1})

>>> # Subtract counts
>>> d = a - b
>>> d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1})
>>>
```

Нет смысла упоминать, что объекты Counter — невероятно полезный инструмент для практически любых задач, где вам нужно перевести данные в табличную форму и посчитать их. Рекомендуем использовать этот способ, а не писать вручную решения на основе словарей.