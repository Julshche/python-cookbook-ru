<!-- MarkdownTOC -->

- 1. Структуры данных и алгоритмы
	- 1.1. Распаковка последовательности в отдельные переменные
	- 1.2. Распаковка элементов из последовательностей произвольной длины
	- 1.3. Оставление N последних элементов
	- 1.4. Поиск N максимальных и минимальных элементов
	- 1.5. Имплементация очереди с приоритетом
	- 1.6. Отображение ключей на множественные значения в словаре
	- 1.7. Поддержание порядка в словарях
	- 1.8. Вычисления в словарях
	- 1.9. Поиск общих элементов в двух словарях
	- 1.10. Удаление дубликатов из последовательности с сохранением порядка элементов
	- 1.11. Присваивание имён срезам
	- 1.12. Определение наиболее часто встречающихся элементов в последовательности
	- 1.13. Сортировка списка словарей по общему ключу
	- 1.14. Сортировка объектов, не поддерживающих сравнение
	- 1.15. Группировка записей на основе полей
	- 1.16. Фильтрование элементов последовательности
	- 1.17. Извлечение подмножества из словаря
	- 1.18. Отображение имен на последовательность элементов
	- 1.19. Одновременное преобразование и сокращение данных
	- 1.20. Объединение нескольких отображений в одно
- 2. Строки и текст
	- 2.1. Разрезание строк, разделенных различными разделителями
	- 2.2. Поиск текста в начале и в конце строки
	- 2.3. Поиск строк с использованием масок оболочки (shell)
	- 2.4. Поиск совпадений и поиск текстовых паттернов
	- 2.5. Поиск и замена текста
	- 2.6. Поиск и замена текста без учета регистра
	- 2.7. Определение регулярных выражений для поиска кратчайшего совпадения
	- 2.8. Написание регулярного выражения для многострочных шаблонов
	- 2.9. Приведение текста в Unicode к стандартному представлению (нормализация)
	- 2.10. Использование символов Unicode в регулярных выражениях
	- 2.11. Убирание нежелательных символов из строк
	- 2.12. Чистка строк
	- 2.13. Выравнивание текстовых строк
	- 2.14. Объединение и конкатенация строк
	- 2.15. Интерполяция переменных в строках
	- 2.16. Разбивка текста на фиксированное количество колонок
	- 2.17. Работа с HTML- и XML-сущностями в тексте
	- 2.18. Токенизация текста
	- 2.19. Написание простого парсера на основе метода рекурсивного спуска
	- 2.20. Выполнение текстовых операций над байтовыми строками
- 3. Числа, даты и время
	- 3.1. Округление числовых значений
	- 3.2. Выполнение точных десятичных вычислений
	- 3.3. Форматирование чисел для вывода
	- 3.4. Работа с бинарными, восьмеричными и шестнадцатеричными целыми числами
	- 3.5. Упаковка и распаковка больших целых чисел из байтовых строк
	- 3.6. Вычисления с комплексными числами
	- 3.7. Работа с бесконечными значениями и NaN
	- 3.8. Вычисления с дробями
	- 3.9. Вычисления на больших массивах чисел
	- 3.10. Вычисления с матрицами и линейная алгебра
	- 3.11. Случайный выбор
	- 3.12. Перевод дней в секунды и другие базовые методы конвертации времени
	- 3.13. Определение даты последней пятницы
	- 3.14. Поиск диапазона дат для текущего месяца
	- 3.15. Конвертирование строк в даты и время
	- 3.16. Манипулирование датами с учётом таймзон
- 4. Итераторы и генераторы
	- 4.1. Ручное прохождение по итератору
	- 4.2. Делегирование итерации
	- 4.3. Создание новых итерационных паттернов с помощью генераторов
	- 4.4. Реализация протокола итератора
	- 4.5. Итерирование в обратном порядке
	- 4.6. Определение генератора с дополнительным состоянием
	- 4.7. Получение среза итератора
	- 4.8. Пропуск первой части итерируемого объекта
	- 4.9. Итерирование по всем возможным комбинациям и перестановкам
	- 4.10. Итерирование по парам «индекс-значение» последовательности
	- 4.11. Одновременное итерирование по нескольким последовательностям
	- 4.12. Интерирования по элементам, находящимся в отдельных контейнерах
	- 4.13. Создание каналов для обработки данных
	- 4.14. Превращение вложенной последовательности в плоскую
	- 4.15. Последовательное итерирование по слитым отсортированным итерируемым объектам
	- 4.16. Замена бесконечных циклов while итератором
- 5. Файлы и ввод-вывод
	- 5.1. Чтение и запись текстовых данных
	- 5.2. Перенаправление вывода в файл
	- 5.3. Вывод с другим разделителем или символом конца строки
	- 5.4. Чтение и запись бинарных данных
	- 5.5. Запись в файл, которого ещё нет
	- 5.6. Выполнение операций ввода-вывода над строками
	- 5.7. Чтение и запись сжатых файлов с данными
	- 5.8. Итерирование по записям фиксированного размера
	- 5.9. Чтение бинарных данных в изменяемый (мутабельный) буфер
	- 5.10. Отображаемые в память бинарные файлы
	- 5.11. Манипулирование путями к файлам
	- 5.12. Проверка существования файла
	- 5.13. Получение содержимого каталога
	- 5.14. Обход кодировки имен файлов
	- 5.15. Вывод «плохих» имён файлов
	- 5.16. Добавление или изменение кодировки уже открытого файла
	- 5.17. Запись байтов в текстовый файл
	- 5.18. Оборачивание существующего дескриптора файла для использования в качестве объекта файла
	- 5.19. Создание временных файлов и каталогов
	- 5.20. Работа с последовательными портами
	- 5.21. Сериализация объектов Python
- 6. Кодирование и обработка данных
	- 6.1. Чтение и запись данных в формате CSV
	- 6.2. Чтение и запись в формате JSON
	- 6.3. Парсинг простых XML-данных
	- 6.4. Инкрементальный парсинг очень больших XML-файлов
	- 6.5. Преобразование словарей в XML
	- 6.6. Парсинг, изменение и перезапись XML
	- 6.7. Парсинг XML-документов с пространствами имён
	- 6.8. Взаимодействие с реляционной базой данных
	- 6.9. Декодирование и кодирование шестнадцатеричных цифр
	- 6.10. Кодирование и декодирование в Base64
	- 6.11. Чтение и запись бинарных массивов структур
	- 6.12. Чтение вложенных и различных по размеру бинарных структур
	- 6.13. Суммирование данных и обсчёт статистики
- 7. Функции
	- 7.1. Определение функций, принимающих любое количество аргументов
	- 7.2. Определение функций, принимающих только именованные аргументы
	- 7.3. Прикрепление информационных метаданных к аргументам функций
	- 7.4. Возвращение функцией нескольких значений
	- 7.5. Определение функций с аргументами по умолчанию
	- 7.6. Определение анонимных функций или функций в строке (инлайновых)
	- 7.7. Захват переменных в анонимных функциях
	- 7.8. Заставляем вызывамый объект с N аргументами работать так же, как вызываемый объект с меньшим количеством аргументов
	- 7.9. Замена классов с одним методом функциями
	- 7.10. Передача дополнительного состояния в функциях обратного вызова
	- 7.11. Внутристрочные функции обратного вызова
	- 7.12. Доступ к переменным, определенным внутри замыкания
- 8. Классы и объекты
	- 8.1. Изменение строкового представления экземпляров
	- 8.2. Настройка строкового форматирования
	- 8.3. Создание объектов, поддерживающих протокол менеджера контекста
	- 8.4. Экономия памяти при создании большого количества экземпляров
	- 8.5. Инкапсуляция имён в классе
	- 8.6. Создание управляемых атрибутов
	- 8.7. Вызов метода родительского класса
	- 8.8. Расширение свойства в подклассе
	- 8.9. Создание нового типа атрибута класса или экземпляра
	- 8.10. Использование лениво вычисляемых свойств
	- 8.11. Упрощение инициализации структур данных
	- 8.12. Определение интерфейса или абстрактного базового класса
	- 8.13. Реализации модели данных или системы типов
	- 8.14. Реализация собственных контейнеров
	- 8.15. Делегирование доступа к атрибуту
	- 8.16. Определение более одного конструктора в классе
	- 8.17. Создание экземпляра без вызова *init*
	- 8.18. Расширение классов с помощью миксин (примесей)

<!-- /MarkdownTOC -->



*Прим. перев.: Комментарии в коде не переведены сознательно, поскольку комментарии в коде всегда должны быть написаны на английском языке.*

# 1. Структуры данных и алгоритмы

Python предоставляет широкий спектр встроенных структур данных, таких как списки, множества и словари. Использовать эти структуры по большей части просто. Однако часто возникают общие вопросы, касающиеся поиска, сортировки, изменения порядка элементов и фильтрования. Цель этой главы — обсудить обычные стуктуры данных и алгоритмы. Также будет дано введение в разнообразные структуры данных из модуля *collections*.

## 1.1. Распаковка последовательности в отдельные переменные

### Проблема
У вас есть кортеж из N элементов или последовательность, которую вы хотите распаковать в коллекцию из N переменных.

### Решение
Любая последовательность (или итерируемый объект) могут быть распакованы в переменные с помощью простого присваивания. Единственное обязательное условие заключается в том, чтобы количество и структура переменных совпадали с последовательностью. Например:
``` python
>>> p = (4, 5)
>>> x, y = p
>>> x
4
>>> y
5
>>>
```

``` python
>>> data = ['ACME', 50, 91.1, (2012, 12, 21)]
>>> name, shares, price, date = data
>>> name
'ACME'
>>> date
(2012, 12, 21)
```

``` python
>>> name, shares, price, (year, mon, day) = data
>>> name
'ACME'
>>> year
2012
>>> mon
12
>>> day
21
>>>
```

При несовпадении количества элементов вы получите ошибку. Например:
``` python
>>> p = (4, 5)
>>> x, y, z = p
Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
ValueError: need more than 2 values to unpack
>>>
```

### Обсуждение
Распаковка работает с любым итерируемым объектом, а не только с кортежами и списками. Это строки, файлы, итераторы и генераторы. Например:
``` python
>>> s = 'Hello'
>>> a, b, c, d, e = s
>>> a
'H'
>>> b
'e'
>>> e
'o'
>>>
```

При распаковке вы иногда можете захотеть отбраковать некоторые значения. Специального синтаксиса для этого в Python нет, но вы можете назначить «выбрасываемые» переменные. Например:
``` python
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>
```

Но убедитесь, что вы уже не использовали где-то эту переменную.


## 1.2. Распаковка элементов из последовательностей произвольной длины 

### Проблема
Вам нужно распаковать N элементов из итерируемого объекта, но этот объект может содержать больше N элементов, что вызывает исключение “too many values to unpack” («слишком много значений для распаковки»).

### Решение
Для решения этой задачи могут быть использованы «выражения со звёздочкой». Предположим, например, что вы ведете учебный курс и решаете в конце семестра, что вы не будете принимать во внимание оценки за первое и последнее домашние задания, а по остальным оценкам посчитаете среднее значение. Если у вас было четыре задания, то можно просто распаковать все четыре. Но что делать, если их 24? Выражения со звёздочкой позволяют легко решить проблему:
``` python
def drop_first_last(grades):
	first, *middle, last = grades
	return avg(middle)
```

Рассмотрим еще один пример: предположим, что у вас есть записи о юзерах, которые состоят из имени и email, за которыми следует произвольное количество телефонных номеров. Вы можете распаковать записи так:
``` python
>>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
>>> name, email, *phone_numbers = user_record
>>> name
'Dave'
>>> email
'dave@example.com'
>>> phone_numbers
['773-555-1212', '847-555-1212']
>>>
```

Стоит отметить, что переменная phone_numbers всегда будет списком, несмотря на то, сколько телефонных номеров распаковано (даже если и ни одного). Любой код, который использует phone_numbers не должен учитывать возможность, что в этой будет не список, или производить дополнительные проверки.

Переменная со звёздочкой также может быть первой в списке. Например, у вас есть последовательность значений, представляющая продажи вашей компании за последние восемь кварталов. Если вы хотите посмотреть, как последний квартал соотносится со средним значением по первым семи, вы можете сделать так:
```python
*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
```

Интерпретатор Python выдаст:
```python
>>> *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
>>> trailing
[10, 8, 7, 1, 9, 5, 10]
>>> current
3
```

### Обсуждение
Расширенная распаковка отлично подходит для распаковки итерируемых объектов неизвестной или произвольной длины. Часто эти объекты имеют некоторые известные элементы или паттерны (например, «всё, что после элемента 1, является телефонным номером»), и распаковка со звёздочкой позволяет программисту легко использовать эти паттерны — вместо того, чтобы исполнять акробатические трюки для извлечения нужных элементов из итерируемого объекта.

Стоит отметить, что синтаксис звёздочки может быть особенно полезен при итерировании по последовательности кортежей переменной длины. Например, возможна такая последовательность кортежей с тегами:
```python
records = [
	('foo', 1, 2),
	('bar', 'hello'),
	('foo', 3, 4),
]

def do_foo(x, y):
	print('foo', x, y)

def do_bar(s):
	print('bar', s)

for tag, *args in records:
	if tag == 'foo':
		do_foo(*args)
	elif tag == 'bar':
		do_bar(*args)
```

Распаковка со звёздочкой также может быть полезна в комбинации с операциями обработки строк, такими как разрезание. Например:
```python
>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
>>> uname, *fields, homedir, sh = line.split(':')
>>> uname
'nobody'
>>> homedir
'/var/empty'
>>> sh
'/usr/bin/false'
>>>
```

Иногда вам может быть нужно распаковать значения и выбросить их. Вы не можете просто определить голую \* при распаковке, но вы можете использовать обычное для выбрасывания имя переменной, такое как _ или ign (ignored). Например:
```python
>>> record = ('ACME', 50, 123.45, (12, 18, 2012))
>>> name, *_, (*_, year) = record
>>> name
'ACME'
>>> year
2012
>>>
```

Есть некоторая схожесть между распаковкой со звёздочкой и обработкой списков в функциональных языках. Например, если у вас есть список, то вы можете легко разделить его на «хвост» и «голову»:
```python
>>> items = [1, 10, 7, 4, 5, 9]
>>> head, *tail = items
>>> head
1
>>> tail
[10, 7, 4, 5, 9]
>>>
```

Можно представить себе функцию, которая произведет такое разрезание с помощью хитрого рекурсивного алгоритма. Например:
```python
>>> def sum(items):
...   head, *tail = items
...   return head + sum(tail) if tail else head
...
>>> sum(items)
36
>>>
```

Однако вам следует знать, что рекурсия не относится к числу сильных сторон Python из-за внутреннего лимита на рекурсию. Поэтому последний пример на практике оказывается просто любопытным предметом для размышления.


## 1.3. Оставление N последних элементов
### Задача
Вы хотите хранить ограниченную историю из нескольких последних элементов, полученных в ходе итерации или какого-то другого процесса обработки данных.

### Решение 
Хранение ограниченной истории — отличный повод применить *collections.deque*. Например, следующий отрывок кода производит простое сопоставление текста с последовательностью строк и при совпадении выдает совпадающие строки вместе с N предыдущими строками контекста:
```python
from collections import deque
def search(lines, pattern, history=5):
	previous_lines = deque(maxlen=history)
	for line in lines:
		if pattern in line:
			yield line, previous_lines
		previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
	with open('somefile.txt') as f:
		for line, prevlines in search(f, 'python', 5):
			for pline in prevlines:
				print(pline, end='')
		print(line, end='')
		print('-'*20)
```

### Обсуждение
При написании программы для поиска элементов обычно используют функцию-генератор, содержащую *yield* (как и показано в вышеприведенном примере). Это отделяет процесс поиска от кода, который использует результаты. Если вы новичок в обращении с генераторами, см. **Рецепт 4.3.**

Использование *deque(maxlen=N)* создает очередь фиксированной длины. Когда новые элементы добавлены и очередь заполнена, самый старый элемент автоматически удаляется. Пример:
```python
>>> q = deque(maxlen=3)
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3], maxlen=3)
>>> q.append(4)
>>> q
deque([2, 3, 4], maxlen=3)
>>> q.append(5)
>>> q
deque([3, 4, 5], maxlen=3)
```

Хотя вы можете вручную производить такие операции над списком (то есть добавление в конец, удаление и т.п.), решение с использованием очереди элегантнее и работает намного быстрее.

Обобщим: дека может быть использована в любом случае, когда вам нужна простая очередь. Если вы не задатите максимальную длину, вы получите бесконечную очередь, которая позволит вам добавлять и удалять элементы с обоих концов. Например:
```python
>>> q = deque()
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3])
>>> q.appendleft(4)
>>> q
deque([4, 1, 2, 3])
>>> q.pop()
3
>>> q
deque([4, 1, 2])
>>> q.popleft()
4
```

Добавление или удаление элементов с любого из концов очереди имеет сложность O(1). А вот добавление или удаление элемента в начало списка имеет сложность O(N).


## 1.4. Поиск N максимальных и минимальных элементов 
### Задача 
Вы хотите создать список N максимальных или минимальных элементов коллекции.

### Решение 
У модуля *heapq* есть две функции, nlargest() и nsmallest(), которые делают именно то, что вам нужно. Например:
```python
import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
```

Обе функции таке принимают параметр key, который позволяет использовать их с более сложными структурами данных. Например:
```python
portfolio = [
	{'name': 'IBM', 'shares': 100, 'price': 91.1},
	{'name': 'AAPL', 'shares': 50, 'price': 543.22},
	{'name': 'FB', 'shares': 200, 'price': 21.09},
	{'name': 'HPQ', 'shares': 35, 'price': 31.75},
	{'name': 'YHOO', 'shares': 45, 'price': 16.35},
	{'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
```

### Обсуждение 
Если вы ищете N наименьших или N наибольших элементов, причем N невелико по сравнению с общим размером коллекции, эти функции покажут великолепную производительность. «Под капотом» они начинают работу с конвертирования данных в список, где данные упорядочены как куча. Например:
```python
>>> nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
>>> import heapq
>>> heap = list(nums)
>>> heapq.heapify(heap)
>>> heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
>>>
``` 

Самое важная возможность кучи состоит в том, что *heap[0]* всегда будет наименьшим элементом. Кроме того, последующие элементы могут быть легко найдены с помощью метода *heapq.heappop()*, который удаляет первый элемент и заменяет его следующим наименьшим элементом (это требует O(log N) операций, где N — размер кучи). Например, чтобы найти три наименьших элемента, вы могли бы сделать это:
```python
>>> heapq.heappop(heap)
-4
>>> heapq.heappop(heap)
1
>>> heapq.heappop(heap)
2
```

Функции *nlargest()* и *nsmallest()* лучше всего подходят, если вы пытаетесь найти относительно небольшое количество элементов. Если вы просто хотите найти один наибольший или наименьший элемент (N = 1), функции *min()* и *max()* будут быстрее. Похожим образом, если N сопоставимо с размером самой коллекции, обычно будет быстрее отсортировать их и взять срез (то есть сделать *sorted(items)[:N]* или *sorted(items)[-N:]*). Стоит отметить, что реальная имплементация *nlargest()* и *nsmallest()* работает гибко и выполняет некоторые из этих оптимизаций самостоятельно (например, использует сортировку, если размер N близок к размеру входящих данных).

Хотя использовать этот рецепт необязательно, имплементация кучи интересна и заслуживает изучения. Информацию об этом можно найти в любой приличной книге по алгоритмам и структурам данных. В документации модуля *heapq* также обсуждаются детали внутренней имплементации.

## 1.5. Имплементация очереди с приоритетом 
### Задача 
Вы хотите реализовать очередь, которая сортирует элементы по заданному приоритету и всегда возвращает элемент с наивысшим приоритетом при каждой операции получения (удаления) элемента.

### Решение
Приведенный ниже класс использует модуль *heapq* для реализации простой очереди с приоритетом.

```python
import heapq

class PriorityQueue:
	def __init__(self):
		self._queue = []
		self._index = 0
	
	def push(self, item, priority):
		heapq.heappush(self._queue, (-priority, self._index, item))
		self._index += 1

def pop(self):
		return heapq.heappop(self._queue)[-1]
```

А вот пример использования:
```python
>>> class Item:
...   def __init__(self, name):
...   self.name = name
...   def __repr__(self):
...   return 'Item({!r})'.format(self.name)
...
>>> q = PriorityQueue()
>>> q.push(Item('foo'), 1)
>>> q.push(Item('bar'), 5)
>>> q.push(Item('spam'), 4)
>>> q.push(Item('grok'), 1)
>>> q.pop()
Item('bar')
>>> q.pop()
Item('spam')
>>> q.pop()
Item('foo')
>>> q.pop()
Item('grok')
>>>
```    

Посмотрите, как первая операция *pop()* возвращает элемент с наивысшим приоритетом. Также пронаблюдайте, как два элемента с одинаковым приоритетом (foo и grok) были возвращены в том же порядке, в каком они были помещены в очередь.

### Обсуждение 
Суть этого рецепта заключается в использовании модуля *heapq*. Функции *heapq.heappush()* и *heapq.heappop()* вставляют и удаляют элементы из *list_queue* таким образом, что первый элемент в списке имеет наименьший приоритет (как обсуждалось в **рецепте 1.4.**). Метод heappop() всегда возвращает «наименьший» элемент, что является ключом к тому, чтобы заставить очередь удалять правильные элементы. Кроме того, так как операции вталкивания и снятия имеют сложность O(log N), где N — число элементов в куче, то они являются вполне эффективными даже для весьма больших значений N.

В этом рецепте очередь состоит из кортежей формата *(-priority, index, item)*. Значение приоритета сделано отрицательным, чтобы заставить очередь сортировать элементы от наибольшего к наименьшему приоритету. Это противоположно обычному порядку сортировки кучи (от наименьшего к наибольшему значению).

Роль переменной *index* заключается в установлении правильного порядка элементов с одинаковым приоритетом. Поддержание постоянно увеличивающегося индекса позволяет сортировать элементы в соответствии с порядком, в каком они были вставлены. Однако индекс такде выполняет важную роль в выполнении операций сравнения при работе с элементами с одинаковыми значениями приоритета. 

Если остановиться на этом подробнее, то отметим, что экземпляры класса *Item* не могут быть упорядочены. Например:
```python
>>> a = Item('foo')
>>> b = Item('bar')
>>> a < b
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Если вы создаете кортежи *(priority, item)*, то их можно сравнивать до тех пор, пока приоритеты различны. Однако же если сравниваются два кортежа с равными приоритетами, то сравнение не может быть проведено (как и ранее). Например:
```python
>>> a = (1, Item('foo'))
>>> b = (5, Item('bar'))
>>> a < b
True
>>> c = (1, Item('grok'))
>>> a < c
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Вводя дополнительный индекс и создавая кортежи *(priority, index, item)*, вы избегаете этой проблемы полностью, поскольку два кортежа никогда не будут иметь одинаковые значения переменной *index* (и Python никогда не будет сравнивать остальные значения в кортежах, если результат сравнения уже определен):
```python
>>> a = (1, 0, Item('foo'))
>>> b = (5, 1, Item('bar'))
>>> c = (1, 2, Item('grok'))
>>> a < b
True
>>> a < c
True
>>>
```

Если вы хотите использовать эту очередь для коммуникации между потоками (тредами), вы должны добавить правильную блокировку и передачу сигналов (cм. **рецепт 12.3.**).  

Документация модуля *heapq* содержит дополнительные примеры и обсуждения теории и имплементации куч.


## 1.6. Отображение ключей на множественные значения в словаре 
### Задача 
Вы хотите создать словарь, который отображает ключи на более чем одно значение (так называемый «мультисловарь», multidict).

### Решение
Словарь — это отображение, где каждый ключ отображен на единственное значение. Если вы хотите отобразить ключи на множественные значения, вам нужно хранить множественные значения в другом контейнере, таком как список или множество. Например, вы можете создавать такие словари:
```python
d = {
	'a' : [1, 2, 3],
	'b' : [4, 5]
}

e = {
	'a' : {1, 2, 3},
	'b' : {4, 5}
}
```

Выбор того, использовать или не использовать списки или множества, зависит от того, как будет использован мультисловарь. Применяйте список, если вы хотите сохранить порядок, в котором добавлены элементы. Применяйте множество, если вы хотите устранить дубликаты (и при этом не беспокоитесь о порядке элементов).

Чтобы легко создавать такие словари, вы можете использовать *defaultdict* из модуля *collections*. Фишка *defautdict* заключается в автоматической инициализации первого значения, так что вы можете сосредоточиться на добавлении элементов. Например:
```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
...

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
...
```

Одно предупреждение: *defaultdict* автоматически создаст записи словаря для ключей, к которым позже будет осуществлен доступ (даже если их в данный момент в словаре нет). Если такое поведение нежелательно, вы можете использовать *setdefault()* на обычном словаре. Например:
```python
d = {}  # A regular dictionary
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)
...
```

Однако многие программисты находят *setdefault()* несколько неестественным — и это если не учитывать тот факт, что он всегда создает новый экземпляр первоначального значения при каждом вызове (в примере это пустой список []).

### Обсуждение 
Конструирование словарей с множественными значениями не является чем-то сложным. Однако инициализация первого значения может быть запутанной, если вы пытаетесь сделать это самостоятельно. Например, вы можете написать что-то такое:
```python
d = {}
for key, value in pairs:
	if key not in d:
		d[key] = []
	d[key].append(value)
``` 

Использование *defaultdict* приводит к намного более чистому коду:
```python
d = defaultdict(list)
for key, value in pairs:
	d[key].append(value)
```

Этот рецепт сильно связан с проблемой группировки записей в задачах обработки данных. Посмотрите, например, рецепт **1.15.**

## 1.7. Поддержание порядка в словарях 
### Задача
Вы хотите создать словарь, и вы также хотите контролировать порядок элементов при итерировании или сериализации.

### Решение
Чтобы контролировать порядок элементов в словаре, вы можете использовать *OrderedDict* из модуля *collections*. Он в точности сохраняет изначальный порядок добавления данных при итерировании. Например:
```python
 from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
	print(key, d[key])
```

*OrderedDict* особенно полезен, когда вы хотите создать отображение, которое вы в дальнейшем собираетесь сериализовать или закодировать в другой формат. Например, если вы хотите строго контролировать порядок полей, выводимых в JSON, вам нужно просто создать *OrderedDict* с нужными данными:
```python
>>> import json

>>> json.dumps(d)
'{"foo": 1, "bar": 2, "spam": 3, "grok": 4}'
>>>
```

### Обсуждение
*OrderedDict* внутри себя поддерживает двусвязный список, который упорядочивает ключи в соответствии с порядком добавления. Когда новый элемент вставляется впервые, он помещается в конец этого списка. Последующее связывание значения с существующим ключом не изменяет порядок.

Заметьте, что размер *OrderedDict* более чем в два раза превышает размер обычного словаря из-за содержащегося внутри дополнительного списка. А если вы собираетесь создать структуру данных, в которой будет большое число экземпляров *OrderedDict* (например, вы хотите прочитать 100 000 строк CSV-файла в список экземпляров *OrderedDict*), вам стоит изучить требования вашего приложения, чтобы решить, перевесят ли преимущества использования *OrderedDict* оверхед на дополнительную память. 

## 1.8. Вычисления в словарях
### Задача
Вы хотите проводить различные вычисления (например, поиск минимального и максимального значения, сортировку) в словаре с данными.

### Решение
Рассмотрим словарь, который отображает тикеры (названия) акций на цены:
```python
prices = {
	'ACME': 45.23,
	'AAPL': 612.78,
	'IBM': 205.55,
	'HPQ': 37.20,
	'FB': 10.75
}
```

Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно обратить ключи и значения, используя функцию *zip()*. Например, вот так можно найти минимальную и максимальную цену, а также соответствующий тикер:
```python
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')

max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
```

Похожим образом для ранжирования данных можно использовать *zip()* с sorted(), как показано ниже:
```python
prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
# 					(45.23, 'ACME'), (205.55, 'IBM'),
# 					(612.78, 'AAPL')]
``` 

Когда вы производите эти вычисления, обратите внимание, что *zip()* создает итератор, по которому можно пройти только один раз. Например, следующий фрагмент кода — неправильный:
```python
prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names))  # OK
print(max(prices_and_names))  # ValueError: max() arg is an empty sequence
```

### Обсуждение 
Если вы попытаетесь выполнить обычные обработки данных на словаре, то вы обнаружите, что они обрабатывают только ключи, но не значения. Например:
```python
min(prices)  # Returns 'AAPL'
max(prices)  # Returns 'IBM'
```

Вероятно, это не то, чего вы хотели добиться, поскольку вы пытались выполнить вычисления с использованием значений словаря. Вы можете попробовать исправить это, используя метод словаря *values()*:
```python
min(prices.values())  # Returns 10.75
max(prices.values())  # Returns 612.78
``` 

К несчастью, это часто тоже не позволит вам добиться желаемого. Например, вы можете хотеть знать соответствующие ключи (т.е., у каких акций самая низкая цена?)

Вы можете получить ключ, соответствующий минимальному или максимальному значению, если вы передадите функцию в функции *min()* и *max()*. Например:
```python
min(prices, key=lambda k: prices[k])  # Returns 'FB'
max(prices, key=lambda k: prices[k])  # Returns 'AAPL'
```

Однако чтобы получить минимальное значение, вам потребуется дополнительное обращение. Например:
```python
min_value = prices[min(prices, key=lambda k: prices[k])]
```

Решение с использованием функции *zip()* решает задачу путем «обращения» словаря в последовательность пар (value, key). Когда выполняется сравнение таких кортежей, элемент value сравнивается первым, а key — следующим. Это дает вам то самое поведение, которое вы хотите, и которое позволяет проводить обработки и сортировку словаря с использованием единственного выражения.

Стоит отметить, что в вычислениях с использованием пар (value, key) key будет использован, чтобы определить результат в экземплярах, где множественные записи имеют одинаковые value. Например, в вычислениях *min()* и *max()* запись с наименьшим или наибольшим ключом будет возвращена, если найдутся дублированные (одинаковые) значения (value). Например:
```python
>>> prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
>>> min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
>>> max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
>>>
```  

## 1.9. Поиск общих элементов в двух словарях
### Задача
У вас два словаря, и вы хотите выяснить, что у них общего (одинаковые ключи, значения и т.п.)

### Решение
Рассмотрим два словаря:
```python
a = {
	'x' : 1,
	'y' : 2,
	'z' : 3
}

b = {
	'w' : 10,
	'x' : 11,
	'y' : 2
}
```

Чтобы найти общие элементы, просто выполните обычный набор операций с использовением методов *keys()* и *items()*. Например:
```python
# Find keys in common
a.keys() & b.keys()  # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys()  # { 'z' }
# Find (key,value) pairs in common
a.items() & b.items() # { ('y', 2) }
```

Операции такого типа также могут быть использованы для изменения или фильтрования содержимого словаря. Предположим, например, что вы хотите создать новый словарь, в котором некоторые ключи удалены. Взгляните на этот пример кода генератора словаря (dictionary comprehension):
```python
# Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
```

### Обсуждение
Словарь — это отображение множества ключей на множество значений. Метод словаря *keys()* возвращает объект просмотра ключей (keys-view object). Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над множествами (объединения, пересечения, разности и т.п.) Так что если вам нужно выполнить этот набор операций над ключами словаря, вы можете использовать объект просмотра напрямую, без предварительного конвертирования в множество.

Метод словаря *items()* возвращает объект просмотра элементов, состоящий из пар (key, value). Этот объект поддерживает похожий набор операций и может быть использован для выполнения таких операций, как поиск того, какие пары ключ-значение являются общими для двух словарей.

Хотя метод словаря *values()* похож на предыдущие, он не поддерживает операции над множествами, описанные выше в этом рецепте. Это происходит, в частности, по причине того, что, в отличие от ключей, элементы объекта просмотра значений могут быть и не уникальными. Один этот факт делает применение к ним операций над множествами малополезным. Если же, однако, вы вынуждены выполнить такие операции, этого можно добиться путем простой предварительного конвертирования значений в множество.

## 1.10. Удаление дубликатов из последовательности с сохранением порядка элементов
### Задача
Вы хотите исключить дублирующиеся значения из последовательности, но при этом сохранить порядок следования оставшихся элементов. 

### Решение 
Если значения в последовательности являются хэшируемыми, задача может быть легко решена с использованием множества и генератора. Например:
```python
def dedupe(items):
	seen = set()
	for item in items:
		if item not in seen:
			yield item
			seen.add(item)
```

Вот пример использования этой функции:
```python
>>> a = [1, 5, 2, 1, 9, 1, 5, 10]
>>> list(dedupe(a))
[1, 5, 2, 9, 10]
>>>
```

Это будет работать только в том случае, если элементы последовательности хэшируются. Если вы пытаетесь удалить дубликаты в последовательности из нехэшируемых типов (таких как словари), вы можете внести небольшое изменение в этот рецепт. Например, такое:
```python
def dedupe(items, key=None):
	seen = set()
	for item in items:
		val = item if key is None else key(item)
		if val not in seen:
			yield item
			seen.add(val)
```

Аргумент *key* здесь нужен для определения функции, которая конвертирует элементы последовательности в хэшируемый тип, подходящий для поиска дубликатов. Вот как это работает:
```python
>>> a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
>>> list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
>>> list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
>>>
```

Последнее решение также отлично работает, если вам нужно удалить дубликаты, базируясь на значении одного поля или атрибута или более крупной структуры данных.

### Обсуждение
Если всё, что вы хотите сделать, это просто удалить дубликаты, то часто достаточно создать множество. Например:
```python
>>> a
[1, 5, 2, 1, 9, 1, 5, 10]
>>> set(a)
{1, 2, 10, 5, 9}
>>>
```

Однако этот поход не сохраняет какой бы то ни было порядок, поэтому результат будет перемешан. Показанный выше решения помогают избежать этого. 

Использование функции-генератора в этом рецепте отражает тот факт, что вы наверняка хотите написать функцию максимально широкого назначения, а не напрямую привязанную к обработке списков. Например, если вы хотите читать файл, удаляя дублирующиеся строки, вы можете сделать так:
```python
with open(somefile,'r') as f:
	for line in dedupe(f):
		...
```

Передача функции в аргументе *key* имитирует похожую возможность во встроенных функциях, таких как *sorted()*, *min()* и *max()*. См., например, рецепты **1.8** и **1.13.**

## 1.11. Присваивание имён срезам
### Задача
Ваша программа превратилась в нечитабельную массу индексов срезов, и вы хотите всё это расчистить.

### Решение
Предположим, что у вас есть код, который вытаскивает определенные поля с данными из строковых записей с фиксированным набором полей (то есть из файла с плоской структурой или похожего формата):
```python
###### 0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:32]) * float(record[40:48])
``` 

Вместо этого вы вполне можете присвоить срезам имена:
```python
SHARES = slice(20,32)
PRICE  = slice(40,48)

cost = int(record[SHARES]) * float(record[PRICE])
```

В последнем примере вы избежали появления кучи загадочных индексов, и код стал проще и яснее.

### Обсуждение
Общее правило таково: написание кода с большим количеством неоформленных индексов ведет к проблемам с читабельностью и поддерживаемостью. Например, если вы вернетесь к такому коду через год, то наверняка не сразу вспомните, как и о чём вы думали, когда всё это писали. Приведённое выше решение — простой путь к более ясному обозначению того, что делает ваш код. 

В общем, встроенная функция slice() создает объект среза, который может быть использован везде, где можно бы использовать обычные срезы. Например:
```python
>>> items = [0, 1, 2, 3, 4, 5, 6]
>>> a = slice(2, 4)
>>> items[2:4]
[2, 3]
>>> items[a]
[2, 3]
>>> items[a] = [10,11]
>>> items
[0, 1, 10, 11, 4, 5, 6]
>>> del items[a]
>>> items
[0, 1, 4, 5, 6]
```

Если у вас есть экземпляр *slice* s, вы можете получить больше информации о нём, если посмотрите на атрибуты *s.start*, *s.stop* и *s.step*. Например:
```python
>>> a = slice(10, 50, 2)
>>> a.start
10
>>> a.stop
50
>>> a.step
2
>>>
```

Также вы можете наложить срез на последовательность определенного размера, используя его метод *indices(size)*. Он возвращает кортеж (start, stop, step), где все значения соответственно ограничены, чтобы вписаться в границы (для избегания исключений *IndexError* при индексировании). Например:
```python
>>> s = 'HelloWorld'
>>> a.indices(len(s))
(5, 10, 2)
>>> for i in range(*a.indices(len(s))):
...   print(s[i])
...
W
r
d
>>>
```

## 1.12. Определение наиболее часто встречающихся элементов в последовательности
### Проблема
У вас есть последовательность элементов, и вы хотите узнать, какие элементы встречаются в ней чаще всего.

### Решение
Класс *collections.Counter* разработан как раз решения для подобных задач. В нем даже есть удобный метод *most_common()*, который сразу выдаст вам ответ.

Чтобы проиллюстрировать это, предположим, что у вас есть список слов, и вы хотите найти наиболее часто встречающееся. Вот как можно это сделать:
```python
words = [
	'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
	'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
	'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
	'my', 'eyes', "you're", 'under'
]

from collections import Counter

word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
```

### Обсуждение
На входе объектам класса *Counter* можно скормить любую последовательность хэшируемых элементов. Под капотом *Counter* — это словарь, который отображает элементы на количество вхождений. Например:
```python
>>> word_counts['not']
1
>>> word_counts['eyes']
8
>>>
```

Если вы хотите увеличить счёт вручную, используйте сложение:
```python
>>> morewords = ['why','are','you','not','looking','in','my','eyes']
>>> for word in morewords:
...   word_counts[word] += 1
...
>>> word_counts['eyes']
9
>>>
```

Или же вы можете использовать метод *update()*:
```python
>>> word_counts.update(morewords)
>>>
```

Малоизвестная возможность экземпляров *Counter* состоит в том, что они могут быть легко скомбинированы с использованием разнообразных математических операций. Например:
```python
>>> a = Counter(words)
>>> b = Counter(morewords)
>>> a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1, 'not': 1})
>>> b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
		'my': 1, 'why': 1})

>>> # Combine counts
>>> c = a + b
>>> c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
		'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,
		'looking': 1, 'are': 1, 'under': 1, 'you': 1})

>>> # Subtract counts
>>> d = a - b
>>> d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1})
>>>
```

Нет смысла упоминать, что объекты *Counter* — невероятно полезный инструмент для практически любых задач, где вам нужно перевести данные в табличную форму и посчитать их. Рекомендуем использовать этот способ, а не писать вручную решения на основе словарей.

## 1.13. Сортировка списка словарей по общему ключу
### Задача
У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более словарным значениям.

### Решение
Сортировка структур этого типа легко выполняется с помощью функции *itemgetter* из модуля *operator*. Предположим, вы выполнили запрос к таблице базы данных, чтобы получить список зарегистрированных пользователей вашего сайта, и получили в ответ вот такую структуру данных:
```python
rows = [
	{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
	{'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
	{'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
	{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
```  

Можно достаточно легко вывести эти строки упорядоченно по любому из полей, общих для всех словарей. Например:
```python
from operator import itemgetter

rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))

print(rows_by_fname)
print(rows_by_uid)
```

Вышеприведенный код выведет следующее:
```python
[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]

[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
```

Функция *itemgetter()* также может принимать несколько ключей. Пример кода:
```python
rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)
```

Вышеприведенный код выведет:
```python
[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
```

### Обсуждение
В этом примере строки передаются встроенной функции *sorted()*, которая принимает именованный аргумент *key*. Этот аргумент должен быть вызываемым объектом, который принимает один элемент из *rows* и возвращает значение, которое будет использовано в качестве основы для сортировки. Функция *itemgetter()* создает такой вызываемый объект. **(Прим. пер.: вызываемый объект — это объект, который имеет метод __call__).**

Функция *operator.itemgetter()* принимает в качестве аргументов индексы, которые используются для извлечения желаемых значений из записей в *rows*. Это может быть ключ словаря, номер элемента в списке или любое другое значение, которое может быть скормлено методу *__getitem()__*. Если вы передадите несколько индексов функции *itemgetter()*, вызываемый объект, который она создаст, вернет кортеж со всеми элементами, и функция *sorted()* упорядочит выводимые элементы в соответствии с отсортированным порядком кортежей. Это может быть полезно, если вы хотите провести сортировку сразу по нескольким полям (в примере это имя и фамилия):
```python
rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
```

Это решение в большинстве случаев работает отлично. Однако решение с использованием *itemgetter()* обычно выполняется быстрее. Так что обратите на него внимание, если производительность в фокусе вашего внимания.

Последнее по порядку, но не по значению: не забудьте, что описанная в этом рецепте техника может быть применена к таким функциям, как *min()* и *max()*. Например:
```python
>>> min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
>>> max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
>>>
```

## 1.14. Сортировка объектов, не поддерживающих сравнение
### Задача
Вы хотите отсортировать объекты одного класса, но они не поддерживают операции сравнения.

### Решение
Встроенная функция *sorted()* принимает аргумент *key*, в котором может быть передан вызываемый объект, который будет возвращать некоторое значение из объектов, которое *sorted()* будет использовать для сравнения этих объектов. Например, если у вас в приложении есть последовательность экземпляров класса *User*, и вы хотите отсортировать их по атрибуту *user_id*, то вы могли бы предоставить вызываемый объект, который принимает экземпляр класса *User* и возвращает атрибут *user_id*. Например:  
```python
>>> class User:
...  def __init__(self, user_id):
...  	self.user_id = user_id
...  def __repr__(self):
...  	return 'User({})'.format(self.user_id)
...
>>> users = [User(23), User(3), User(99)]
>>> users
[User(23), User(3), User(99)]
>>> sorted(users, key=lambda u: u.user_id)
[User(3), User(23), User(99)]
>>>
```

Вместо лямбды можно применить альтернативный подход с использованием *operator.attrgetter()*: 
```python
>>> from operator import attrgetter
>>> sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
>>>
```

### Обсуждение
Использовать или не использовать лямбду или *attrgetter()* — вопрос личных предпочтений. Однако *attrgetter()* часто оказывается немного быстрее, а также добавляет возможность одновременного извлечения нескольких полей. Это аналогично использованию *operator.itemgetter()* для словарей (см. **рецепт 1.13.**). Например, если экземпляры класса User также имеют атрибуты *first_name* и *last_name*, вы можете выполнить вот такую сортировку:
```python
by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
```

Также стоит отметить, что использованный в этом рецепте приём может быть применён к таким функциям, как *min()* и *max()*. Например:
```python
>>> min(users, key=attrgetter('user_id')
User(3)
>>> max(users, key=attrgetter('user_id')
User(99)
>>>
``` 

## 1.15. Группировка записей на основе полей
### Задача
У вас есть последовательность словарей или экземпляров, и вы хотите итерировать по данным в группах, основываясь на значении конкретного поля (например, на дате).

### Решение
Функция *itertools.groupby()* особенно полезна для такого типа группировки данных. Предположим, что у вас есть список словарей:
```python
rows = [
	{'address': '5412 N CLARK', 'date': '07/01/2012'},
	{'address': '5148 N CLARK', 'date': '07/04/2012'},
	{'address': '5800 E 58TH', 'date': '07/02/2012'},
	{'address': '2122 N CLARK', 'date': '07/03/2012'},
	{'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
	{'address': '1060 W ADDISON', 'date': '07/02/2012'},
	{'address': '4801 N BROADWAY', 'date': '07/01/2012'},
	{'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
```

Предположим также, что вы хотите проитерировать по данным, причем сгруппированными по дате кусочками. Проведем отсортировку по нужному полю (в данном случае по дате), а потом применим *itertools.groupby()*:
```python
from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))

# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
	print(date)
	for i in items:
		print(' ', i)
```    

Вывод будет таким:
```python
07/01/2012
	{'date': '07/01/2012', 'address': '5412 N CLARK'}
	{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
	{'date': '07/02/2012', 'address': '5800 E 58TH'}
	{'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
	{'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
	{'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
	{'date': '07/04/2012', 'address': '5148 N CLARK'}
	{'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
```

### Обсуждение
Функция *groupby()* работает так: сканирует последовательность и ищет последовательные «партии» одинаковых значений (или значений, возвращенных переданной через *key* функцией). В каждой итерации функции возвращает значение вместе с итератором, который выводит все элементы в группу с одинаковым значением.

Важным предварительным шагом тут является сортировка данных по интересующему нас полю. Поскольку *groupby()* проверяет только последовательные элементы, без предварительной сортировки группировка записей выполнена не будет.

Если ваша цель — просто сгруппировать данные вместе в крупную структуру данных с произвольным доступом, то вам больше поможет *defaultdict()*, которая создает «мультисловарь», как описано в **рецепте 1.6**. Например:
```python
from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
	rows_by_date[row['date']].append(row)
```

Это позволяет легко получить доступ к записям для каждой даты:
```python
>>> for r in rows_by_date['07/01/2012']:
...   print(r)
...
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
>>>
```

В последнем примере предварительная сортировка записей не обязательна. Но если вы не заботитесь о потреблении памяти, то может оказаться быстрее сделать это с помощью предварительной сортировки и итерированию с использованием *groupby()*.  

## 1.16. Фильтрование элементов последовательности
### Задача
У вас есть данные внутри последовательности, и вы хотите извлечь значения или уменьшить последовательность по какому-либо критерию.

### Решение
Самый простой способ фильтрования последовательности — использовать генератор списка (list comprehension). Например:
```python
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> [n for n in mylist if n > 0]
[1, 4, 10, 2, 3]
>>> [n for n in mylist if n < 0]
[-5, -7, -1]
>>>
```

Потенциальная проблема с использованием генераторов списоков заключается в том, что они могут создать большой результат, если размер входных данных тоже большой. Если это вас беспокоит, вы можете использовать выражения-генераторы для итеративного возврата отфильтрованных значений. Например:
```python
>>> pos = (n for n in mylist if n > 0)
>>> pos
<generator object <genexpr> at 0x1006a0eb0>
>>> for x in pos:
...   print(x)
...
1
4
10
2
3
>>>
```
Иногда критерий фильтрования не может быть легко выражен в форме генератора списка или выражения-генератора. Предположим, например, что процесс фильтрования включает обработку исключений или какой-то другой сложный момент. Чтобы справиться с этим, поместите фильтрующий код в функцию и используйте встроенную функцию *filter()*. Например: 
```python
values = ['1', '2', '-3', '-', '4', 'N/A', '5']

def is_int(val):
	try:
		x = int(val)
		return True
	except ValueError:
		return False

ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
```

*filter()* создает итератор, так что если вы хотите получить список результатов, не забудьте использовать *list()*, как показано выше.

### Обсуждение
Генераторы списков и выражения-генераторы часто являются самым лёгким и прямым способом фильтрования простых данных. Но у них также есть дополнительная способность одновременного изменения данных. Например:
```python
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> import math
>>> [math.sqrt(n) for n in mylist if n > 0]
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
>>>
```  

Одна из разновидностей фильтрования включает замену значений, которые не подходят под определенный критерий, другим значением (вместо отбраковки неподходящих). Например, вместо простого поиска положительных значений, вы также хотите обрезать «плохие» значения, чтобы они попадали в определенный диапазон. В большинстве случаев это легко сделать с помощью перемещения критерия фильтрования в условное выражение:
```python
>>> clip_neg = [n if n > 0 else 0 for n in mylist]
>>> clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
>>> clip_pos = [n if n < 0 else 0 for n in mylist]
>>> clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
>>>
```

Другой важный инструмент для фильтрации — *itertools.compress()*, который принимает итерируемый объект вместе с последовательностью-селектором из булевых значений. На выходе функция выдает все элементы итерируемого объекта, для которых совпадающий элемент в селекторе — True. Это может быть полезно, если вы пытаетесь применить результаты фильтрования одной последовательности к другой связанной последовательности. Например, у вас есть две колонки данных:
```python
addresses = [
	'5412 N CLARK',
	'5148 N CLARK',
	'5800 E 58TH',
	'2122 N CLARK'
	'5645 N RAVENSWOOD',
	'1060 W ADDISON',
	'4801 N BROADWAY',
	'1039 W GRANVILLE',
]

counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
```

Теперь предположим, что вы хотите создать список всех адресов, где соответствующие значение из *counts* больше 5. Вот как это можно сделать:
```python
>>> from itertools import compress
>>> more5 = [n > 5 for n in counts]
>>> more5
[False, False, True, False, False, True, True, False]
>>> list(compress(addresses, more5))
['5800 E 58TH', '4801 N BROADWAY', '1039 W GRANVILLE']
>>>
``` 

Ключевой момент — сначала создать последовательность булевых значений, которые будут указывать, какие элементы удовлетворяют заданному условию. Далее функция *compress()* выберет элементы, соответствующие значениям True.

Как и *filter()*, функция *compress()* возвращает итератор. Поэтому если вы хотите на выходе получить список, вам придется использовать *list()*.  

## 1.17. Извлечение подмножества из словаря
### Задача
Вы хотите создать словарь, который будет подмножеством другого словаря.

### Решение
Эту задачу можно легко решить с помощью генератора словаря (dictionary comprehension). Например:
```python
prices = {
	'ACME': 45.23,
	'AAPL': 612.78,
	'IBM': 205.55,
	'HPQ': 37.20,
	'FB': 10.75
}

# Make a dictionary of all prices over 200
p1 = { key:value for key, value in prices.items() if value > 200 }

# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:value for key,value in prices.items() if key in tech_names }
```

### Обсуждение
Большая часть того, что можно сделать с помощью генераторов словарей, можно осуществить путём создания последовательности кортежей и передачи их в функцию *dict()*. Например:
```python
p1 = dict((key, value) for key, value in prices.items() if value > 200)
```

Однако решение на основе генератора словаря немного яснее и работает немного быстрее (в рассмотренном выше примере генератор отработал в два раза быстрее). 

Иногда существует множество путей решить задачу. Например, второй пример можно переписать так:
```python
# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() & tech_names }
```

Однако подсчет времени выполнения открывает нам, что это решение почти в 1,6 раза медленнее, чем первое. Если производительность для вас важна, обычно стоит потратить немного времени на изучение таких вопросов. См. **рецепт 14.13.**, чтобы получить детальную информацию о подсчете времени и профилировании.

## 1.18. Отображение имен на последовательность элементов
### Задача
У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции, но такой подход часто делает программу нечитабельной. Также вы можете захотеть уменьшить зависимость от позиции в структуре данных путём перехода к доступу к элементам по имени.

### Решение
*collections.namedtuple()* предоставляет такую возможность, добавляя минимальный оверхед по сравнению с использованием обычного кортежа. *collections.namedtuple()* — это фабричный метод, который возвращает подкласс стандартного пайтоновского типа tuple (кортеж). Вы скармливаете этому методу имя типа и поля, которые он должен иметь, и он возвращает класс, который может порождать экземпляры с полями, которые вы определили, и значениями этих полей, которые вы передадите при порождении. Например:
```python
>>> from collections import namedtuple
>>> Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
>>> sub = Subscriber('jonesy@example.com', '2012-10-19')
>>> sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
>>> sub.addr
'jonesy@example.com'
>>> sub.joined
'2012-10-19'
>>>
```

Хотя экземпляр *namedtuple* (именованного кортежа) выглядит так же, как и обычный экземпляр класса, он взаимозаменяем с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка. Например:
```python
>>> len(sub)
2
>>> addr, joined = sub
>>> addr
'jonesy@example.com'
>>> joined
'2012-10-19'
>>>
```  

Самый частый случай использования именованного кортежа — отвязка вашего кода от работы с позициями элементов, которыми он манипулирует. Так что если вы получаете большой список кортежей в ответ на запрос к базе данных, а потом манипулируете ими через позиционное обращение к элементам, ваш код может сломаться, если вы, скажем, добавите новую колонку в таблицу. Этого можно избежать, если вы сначала превратите полученные кортежи в именованные кортежи.

Чтобы проиллюстрировать это, приведём пример кода, использующего обычные кортежи:
```python
def compute_cost(records):
	total = 0.0
	for rec in records:
		total += rec[1] * rec[2]
	return total
```

Использование позиционного обращения к элементам часто делает код немного менее выразительным и более зависимым от структуры записей. А вот версия с использованием именованного кортежа:
```python
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
	total = 0.0
	for rec in records:
		s = Stock(*rec)
		total += s.shares * s.price
	return total
```

Естественно, вы можете избежать явной конвертации в именованный кортеж *Stock*, если последовательность *records* из примера уже содержит такие экземпляры. 

### Обсуждение
Возможное использование именованного кортежа — замена словаря, который требует больше места для хранения. Так что если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако не забудьте, что именнованные кортежи неизменяемы (в отличие от словарей). Например:
```python
>>> s = Stock('ACME', 100, 123.45)
>>> s
Stock(name='ACME', shares=100, price=123.45)
>>> s.shares = 75
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
>>>
```

Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода *_replace()*, которым обладают экземпляры именованных кортежей. Он создает полностью новый именованный кортеж, в котором указанные значения заменены. Например:
```python
>>> s = s._replace(shares=75)
>>> s
Stock(name='ACME', shares=75, price=123.45)
>>>
```

Тонкость использования метода *_replace()* заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте *_replace()* для создания новых экземпляров с замененными значениями. Например:
```python
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])

# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)

# Function to convert a dictionary to a Stock
def dict_to_stock(s):
	return stock_prototype._replace(**s)
```   

Вот пример работы этого кода:
```python
>>> a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
>>> dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
>>> b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
>>> dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
>>>
```

Последнее, но важное замечание: стоит отметить, что если вашей целью является создание эффективной структуры данных, где вы сможете менять различные атрибуты экземпляров, использование именованных кортежей — не лучший вариант. Вместо них стоит определить класс с использованием \__slots__ (см. **рецепт 8.4.**)


## 1.19. Одновременное преобразование и сокращение данных
### Задача
Вам нужно выполнить функцию сокращения (т.е. sum(), min(), max()), но сначала необходимо преобразовать или отфильтровать данные.

### Решение
Есть весьма элегантное решение для объединения сокращения и преобразования данных — выражение-генератор в аргументе. Например, если вы хотите подсчитать сумму квадратов, попробуйте следующее:
```python
nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
``` 

Вот еще несколько примеров:
```python
# Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
	print('There be python!')
else:
	print('Sorry, no python.')

# Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))

# Data reduction across fields of a data structure
portfolio = [
	{'name':'GOOG', 'shares': 50},
	{'name':'YHOO', 'shares': 75},
	{'name':'AOL', 'shares': 20},
	{'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio)
```

### Обсуждение
Решение демонстрирует тонкий синтаксический аспект выражений-генераторов, связанный с передачей их как единственного аргумента в функцию — повторяющиеся скобки не нужны. Например, следующие инструкции эквивалентны:
```python
s = sum((x * x for x in nums))  # Pass generator-expr as argument
s = sum(x * x for x in nums)  # More elegant syntax
```

Использование аргумента-генератора часто будет более эффективным и элегантным, нежели предварительное создание временного списка. Например, если вы не используете выражение-генератор, вы можете поразмыслить над этой альтернативной имплементацией:
```python
nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
```

Это работает, но вводит лишний шаг и создает лишний список. Для небольшого списка из примера это не имеет значения, но если *nums* был огромным, вы получите крупную временную структуру данных, которая будет использована только один раз, а потом выброшена. Решение с генератором обрабатывает данные итеративно и потому намного более эффективно с точки зрения использования памяти.

Некоторые функции сокращения, такие как *min()* и *max()*, принимают аргумент *key*, что может оказаться полезным в ситуациях, когда вы склоняетесь к использованию генератора. Например, в этом примере вы можете попробовать альтернативный подход:
```python
# Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)

# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares'])
```

## 1.20. Объединение нескольких отображений в одно
### Задача
У вас есть много словарей или отображений, которые вы хотите логически объединить в одно отображение, чтобы выполнить некоторые операции, такие как поиск значений или проверка существования ключей.

### Решение
Предположим, у вас есть два словаря:
```python
a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
```

А теперь предположим, что вы хотите провести поиски, в которых вы хотите проверить оба словаря (то есть сначала проверить в словаре *a*, а потом в *b*, если в первом словаре искомое не найдено). Простой способ сделать это — использовать класс *ChainMap* из модуля *collections*. Например:
```python
from collections import ChainMap
c = ChainMap(a,b)
print(c['x'])  # Outputs 1 (from a)
print(c['y'])  # Outputs 2 (from b)
print(c['z'])  # Outputs 3 (from a)
```

### Обсуждение
*ChainMap* принимает несколько отображений и делает так, что они логически становятся единым целым. Однако в буквальном смысле они не сливаются. Вместо этого *ChainMap* просто содержит список отображений и переопределяет обычные операции над словарями для сканирования этого списка. Большинство операций работают. Например:
```python
>>> len(c)
3
>>> list(c.keys())
['x', 'y', 'z']
>>> list(c.values())
[1, 2, 3]
>>>
``` 

В случае появления одинаковых ключей будут использованы значения из первого словаря. Например, *c['z']* в примере всегда будет ссылаться на значение из словаря *a*, а не из *b*.

Операции, которые изменяют отображение, всегда действуют на первое отображение в списке. Например:
```python
>>> c['z'] = 10
>>> c['w'] = 40
>>> del c['x']
>>> a
{'w': 40, 'z': 10}
>>> del c['y']
Traceback (most recent call last):
...
KeyError: "Key not found in the first mapping: 'y'"
>>>
``` 

*ChainMap* особенно полезны для работы со значениями, принадлежащими областям видимости, такими как переменные языка программирования (глобальные, локальные и т.п.) На самом деле даже существуют методы, которые всё упрощают:
```python
>>> values = ChainMap()
>>> values['x'] = 1
>>> # Add a new mapping
>>> values = values.new_child()
>>> values['x'] = 2
>>> # Add a new mapping
>>> values = values.new_child()
>>> values['x'] = 3
>>> values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
>>> values['x']
3
>>> # Discard last mapping
>>> values = values.parents
>>> values['x']
2
>>> # Discard last mapping
>>> values = values.parents
>>> values['x']
1
>>> values
ChainMap({'x': 1})
>>>
```  

В качестве альтернативы *ChainMap* вы можете обдумать слияние словарей с использованием метода update(). Например:
```python
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = dict(b)
>>> merged.update(a)
>>> merged['x']
1
>>> merged['y']
2
>>> merged['z']
3
>>>
``` 

Это работает, но требует от вас создания полностью нового объекта словаря (или необратимого изменения одного из существующих). В этом случае при изменении одного из первоначальных словарей новый объект объединенного словаря изменения не затронут. Например:
```python
>>> a['x'] = 13
>>> merged['x']
1
``` 

*ChainMap* использует первоначальные словари, поэтому не подвержен такому поведению. Например:
```python
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = ChainMap(a, b)
>>> merged['x']
1
>>> a['x'] = 42
>>> merged['x']  # Notice change to merged dicts
42
>>>
```

# 2. Строки и текст
Практически любая полезная программа включает тот или иной вид обработки текста: от парсинга данных до генерации вывода. Эта глава рассматривает обычные задачи манипулирования текстом, такие как разбивка строк, поиск, подстановка, лексический анализ и парсинг. Многие из этих задач могут быть легко решены с использованием встроенных строковых методов. Однако более сложные операции могут потребовать использования регулярных выражений ии создания полноценного парсера. Все эти темы разобраны в данной главе. Также мы обратим внимание на несколько хитрых аспектов работы с Unicode.

## 2.1. Разрезание строк, разделенных различными разделителями
### Задача
Вам нужно разделить строку на поля, но разделители (и пробелы вокруг них) внутри строки не одинаковые.

### Решение
Функция *re.split()* будет в этом случае весьма полезной, поскольку вы сможете определить многочисленные шаблоны разделителей. Например, как показано в решении, разделитель может быть либо запятой (,), точкой с запятой (;) или пробелом, за которым следует любое количество дополнительных пробелов. Какой бы из этих шаблонов ни был найден, совпадение становится разделителем. Результатом будет просто список полей, точно такой же, какой создает строковый метод *str.split()*.

При применении *re.split()* вы должны быть осторожными, если шаблон регулярного выражения использует группу, заключенную в скобки. При использовании групп совпавший с шаблоном текст также включается в результат. Например:
```python
>>> fields = re.split(r'(;|,|\s)\s*', line)
>>> fields
['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
>>>
```

Получение символов-разделителей может быть полезным в некоторых обстоятельствах. Например, вам могут потребоваться эти символы позже — для переформатирования выводимой строки:
```python
>>> values = fields[::2]
>>> delimiters = fields[1::2] + ['']
>>> values
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>> delimiters
[' ', ';', ',', ',', ',', '']

>>> # Reform the line using the same delimiters
>>> ''.join(v+d for v,d in zip(values, delimiters))
'asdf fjdk;afed,fjek,asdf,foo'
>>>
```

Если вы не хотите, чтобы разделители попали в результат, но при этом вам нужно применить группы в шаблоне регулярного выражения, убедитесь, что вы используете незахватывающую (noncapture) группу, которая определяется так: (?:...). Например:
```python
>>> re.split(r'(?:,|;|\s)\s*', line)
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>>
```

## 2.2. Поиск текста в начале и в конце строки
### Задача
Вам нужно проверить начало или конец строки на содержание неких текстовых шаблонов, таких как расширения файлов, схемы URL и т.д.

### Решение
Простой способ проверить начало или конец строки — применить методы *str.startswith()* или *str.endswith()*. Например:
```python
>>> filename = 'spam.txt'
>>> filename.endswith('.txt')
True
>>> filename.startswith('file:')
False
>>> url = 'http://www.python.org'
>>> url.startswith('http:')
True
>>>
```

Если вам нужно проверить несколько вариантов, передайте кортеж с ними в *startswith()* или *endswith()*:
```python
>>> import os
>>> filenames = os.listdir('.')
>>> filenames
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ]
>>> [name for name in filenames if name.endswith(('.c', '.h')) ]
['foo.c', 'spam.c', 'spam.h'
>>> any(name.endswith('.py') for name in filenames)
True
>>>
```

А вот другой пример:
```python
from urllib.request import urlopen

def read_data(name):
	if name.startswith(('http:', 'https:', 'ftp:')):
		return urlopen(name).read()
	else:
		with open(name) as f:
		return f.read()
```

Любопытно, что в этом случае на вход нужно подавать именно кортеж. Если так случилось, что варианты выбора собраны у вас в списке или множестве, сначала сконвертируйте их с помощью *tuple()*. Например:
```python
>>> choices = ['http:', 'ftp:']
>>> url = 'http://www.python.org'
>>> url.startswith(choices)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: startswith first arg must be str or a tuple of str, not list
>>> url.startswith(tuple(choices))
True
>>>
```

### Обсуждение
Методы *startswith()* и *endswith()* предоставляют весьма удобный способ проверки префиксов и окончаний. Такие же операции можно осуществить с помощью срезов, но это намного менее элегантно. Например:
```python
>>> filename = 'spam.txt'
>>> filename[-4:] == '.txt'
True
>>> url = 'http://www.python.org'
>>> url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
True
>>>
```

Вы также можете склониться к использованию регулярных выражений в качестве альтернативы. Например:
```python
>>> import re
>>> url = 'http://www.python.org'
>>> re.match('http:|https:|ftp:', url)
<_sre.SRE_Match object at 0x101253098>
>>>
```

Такой подход работает, но часто это будет огнем из пушки по воробьям. Использование вышеописанного рецепта проще и работает быстрее.

И последнее: методы *startswith()* и *endswith()* отлично работают вместе с другими операциями, такими как обычные сокращения данных. Например, это выражение проверяет каталог на присутствие файлов определенных типов:
```python
if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
...
```  

## 2.3. Поиск строк с использованием масок оболочки (shell)
### Задача
Вы хотите найти текст, используя те же маски, которые обычно используются в оболочках Unix (например, *.py, Dat[0-9]*.csv и т.д.)

### Решение
Модуль *fnmatch* предоставляет две функции: *fnmatch()* и *fnmatchcase()*, которые можно использовать для такого поиска. Всё просто:
```python
>>> from fnmatch import fnmatch, fnmatchcase
>>> fnmatch('foo.txt', '*.txt')
True
>>> fnmatch('foo.txt', '?oo.txt')
True
>>> fnmatch('Dat45.csv', 'Dat[0-9]*')
True
>>> names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
>>> [name for name in names if fnmatch(name, 'Dat*.csv')]
['Dat1.csv', 'Dat2.csv']
>>>
```

По умолчанию *fnmatch()* использует те же чувствительные к регистру правила, как и файловая система текущей операционной системы (то есть правила меняются от системы к системе). Например:
```python
>>> # On OS X (Mac)
>>> fnmatch('foo.txt', '*.TXT')
False

>>> # On Windows
>>> fnmatch('foo.txt', '*.TXT')
True
>>>
```

Если это различие важно, используйте метод *fnmatchcase()*. Он ищет именно такие совпадения заглавных и строчных букв, которые вы предоставите:
```python
>>> fnmatchcase('foo.txt', '*.TXT')
False
>>>
```

Часто упускается из вида возможность использования этих функций на строках, получаемых при обработке данных, или на строках, не являющихся именами файлов. Например, у вас есть список адресов:
```python
addresses = [
	'5412 N CLARK ST',
	'1060 W ADDISON ST',
	'1039 W GRANVILLE AVE',
	'2122 N CLARK ST',
	'4802 N BROADWAY',
]
``` 

Вы можете написать такой генератор списка (list comprehension):
```python
>>> from fnmatch import fnmatchcase
>>> [addr for addr in addresses if fnmatchcase(addr, '* ST')]
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
>>> [addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')]
['5412 N CLARK ST']
>>>
```

### Обсуждение
Поиск совпадений с использованием *fnmatch* занимает нишу между возможностями простых строковых методов и полной мощью регулярных выражений. Если вы просто хотите простой механизм для применения масок в обработке данных, он часто является подходящим решением.

Если же вы пишете код для поиска имён файлов, используйте модуль *glob* (см. **рецепт 5.13.**)

## 2.4. Поиск совпадений и поиск текстовых паттернов
### Задача
Вы хотите отыскать совпадение или провести поиск по определенному шаблону.

### Решение
Если текст, который вы хотите найти, является простым литералом, в большинстве случаев вам подойдут базовые строковые методы, такие как *str.find()*, *str.endswith()*, *str.startwith()* и другие подобные. Например:
```python
>>> text = 'yeah, but no, but yeah, but no, but yeah'

>>> # Exact match
>>> text == 'yeah'
False

>>> # Match at start or end
>>> text.startswith('yeah')
True
>>> text.endswith('no')
False

>>> # Search for the location of the first occurrence
>>> text.find('no')
10
>>>
```

Для более сложного поиска совпадений используйте регулярные выражения и модуль *re*. Чтобы проиллюстрировать базовые механики использования регулярных выражений, предположим, что вы хотите найти даты, определенные цифрами, такие как «11/27/2012.» Вот пример того, как вы можете это сделать:
```python
>>> text1 = '11/27/2012'
>>> text2 = 'Nov 27, 2012'
>>>
>>> import re
>>> # Simple matching: \d+ means match one or more digits
>>> if re.match(r'\d+/\d+/\d+', text1):
...   print('yes')
... else:
...   print('no')
...
yes
>>> if re.match(r'\d+/\d+/\d+', text2):
...   print('yes')
... else:
...   print('no')
...
no
>>>
```

Если вы собираетесь много раз искать по одному и тому же шаблону, часто окупается предварительная компиляция шаблона регулярного выражения в объект шаблона. Например:
```python
>>> datepat = re.compile(r'\d+/\d+/\d+')
>>> if datepat.match(text1):
...   print('yes')
... else:
...   print('no')
...
yes
>>> if datepat.match(text2):
...   print('yes')
... else:
...   print('no')
...
no
>>>
```

*match()* всегда пытается найти совпадения в начале строки. Если вы хотите провести поиск по всем случаям соответствия шаблону, используйте метод *findall()*. Например:
```python
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
['11/27/2012', '3/13/2013']
>>>
```

При составлении регулярных выражений, часто нужно использовать захватывающие группы, заключая части шаблона в скобки. Например:
```python
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>>
```

Захватывающие группы часто упрощают последующую обработку найденного текста, поскольку содержимое каждой группы может быть извлечено отдельно. Например:
```python
>>> m = datepat.match('11/27/2012')
>>> m
<_sre.SRE_Match object at 0x1005d2750>

>>> # Extract the contents of each group
>>> m.group(0)
'11/27/2012'
>>> m.group(1)
'11'
>>> m.group(2)
'27'
>>> m.group(3)
'2012'
>>> m.groups()
('11', '27', '2012')
>>> month, day, year = m.groups()
>>>

>>> # Find all matches (notice splitting into tuples)
>>> text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>> for month, day, year in datepat.findall(text):
...   print('{}-{}-{}'.format(year, month, day))
...
2012-11-27
2013-3-13
>>>
```

Метод *findall()* проходит по тексту и находит все совпадения, возвращая их в списке. Если вы хотите искать совпадения итеративно, используйте метод *finditer()*:
```python
>>> for m in datepat.finditer(text):
...   print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
>>>
```

### Обсуждение
Вводного курса в теорию регулярных выражений в этой книге вы не найдете. Однако этот рецепт демонстрирует простейшие примеры использования модуля re для поиска совпадений в тексте. Самые основные приёмы — компилирование шаблонов с использованием *re.compile()* и последующее использование таких методов как *match()*, *findall()* или *finditer()*.  

При составлении шаблонов часто нужно использовать «сырые» (raw) строки, такие как r'(\d+)/(\d+)/(\d+)'. Такие строки оставляют символы обратных слэшей необработанными, что может быть полезно в контесте применения регулярных выражений. С другой стороны, вы можете использовать двойные обратные слэши: '(\\d+)/(\\d+)/(\\d+)'. 

Учтите, что метод *match()* проверяет только начало строки. Возможно, что он найдет вещи, которые вы не ожидаете. Например:
```python
>>> m = datepat.match('11/27/2012abcdef')
>>> m
<_sre.SRE_Match object at 0x1005d27e8>
>>> m.group()
'11/27/2012'
>>>
```

Если вам нужно точное совпадение, убедитесь, что шаблон включает символ завершения ($), как в примере ниже:
```python
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
>>> datepat.match('11/27/2012abcdef')
>>> datepat.match('11/27/2012')
<_sre.SRE_Match object at 0x1005d2750>
>>>
```

И последнее: если вы просто проводите простые операции поиска, вы часто можете пропустить шаг компиляции и использовать функции уровня модуля из модуля *re*. Например:
```python
>>> re.findall(r'(\d+)/(\d+)/(\d+)', text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>>
``` 

Обратите внимание, что если вы проводите много операций поиска совпадений, часто окупается компилирование шаблона и многократное его использование. Функции уровня модуля поддерживают кэш недавно скомпилированных паттернов, так что вы не получите огромного выигрыша в производительности, но вы сэкономите несколько обращений и избежите лишней обработки, используя ваш собственный скомпилированный шаблон.

## 2.5. Поиск и замена текста
### Задача
Вы хотите найти в строке и заменить текст, соответствующий некому шаблону. 

### Решение
Для простых литеральных шаблонов используйте метод *str.replace()*. Например:
```python
>>> text = 'yeah, but no, but yeah, but no, but yeah'

>>> text.replace('yeah', 'yep')
'yep, but no, but yep, but no, but yep'
>>>
```

Для более сложных шаблонов используйте функции/методы *sub()* из модуля *re*. Предположим, вы хотите перезаписать даты, чтобы перевести из их формата “11/27/2012” в “2012-11-27.” Вот пример того, как это можно сделать:
```python
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> import re
>>> re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>
```

Первый аргумент, передаваемый в *sub()*, это шаблон для поиска, а второй — шаблон, которым нужно заменять найденное. Цифры, перед которыми поставлен обратный слэш (такие как \3), ссылаются на номера захватывающих групп в шаблоне.

Если вы собираетесь многократно выполнять подстановку по одному и тому же шаблону, рекомендуем скомпилировать его для увеличения производительности. Например:
```python
>>> import re
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>> datepat.sub(r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>
```

В случае более сложных подстановок можно определить подстановочную функцию с обратным вызовом (callback function). Например:
```python
>>> from calendar import month_abbr
>>> def change_date(m):
...   mon_name = month_abbr[int(m.group(1))]
...   return '{} {} {}'.format(m.group(2), mon_name, m.group(3))
...
>>> datepat.sub(change_date, text)
'Today is 27 Nov 2012. PyCon starts 13 Mar 2013.'
>>>
```

На вход подстановочному коллбэку в аргументе передается объект поиска совпадений, возвращенный функцией *match()* или *find()*. Используйте метод *.group()* для извлечения определенных частей совпадения. Функция должна возвращать текст замены (replacement text). 

Если вы хотите знать, сколько подстановок было сделано в дополнение к получению текста замены (replacement text), используйте *re.subn()*. Например:
```python
>>> newtext, n = datepat.subn(r'\3-\1-\2', text)
>>> newtext
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>> n
2
>>>
```

### Обсуждение
В поиске совпадений с помощью регулярных выражений не особо много чего-то дополнительного к показанному примеру с использованием метода *sub()*. Самое сложное — это составление шаблона регулярного выражения, и это мы оставляем читателю в качестве упражнений.


## 2.6. Поиск и замена текста без учета регистра
### Задача
Вам необходимо найти и, возможно, заменить текст, не обращая внимания на регистр букв.

### Решение
Для выполнения действий над текстом без учёта регистра вам понадобится модуль *re* и флаг *re.IGNORECASE*, который можно применять в различных операциях. Например:
```python
>>> text = 'UPPER PYTHON, lower python, Mixed Python'
>>> re.findall('python', text, flags=re.IGNORECASE)
['PYTHON', 'python', 'Python']
>>> re.sub('python', 'snake', text, flags=re.IGNORECASE)
'UPPER snake, lower snake, Mixed snake'
>>>
``` 

Последний пример раскрывает ограничение: текст замены не будет совпадать по регистру с заменяемым текстом. Если вам нужно исправить такое поведение, используйте поддерживающую функцию:
```python
def matchcase(word):
	def replace(m):
		text = m.group()
		if text.isupper():
			return word.upper()
		elif text.islower():
			return word.lower()
		elif text[0].isupper():
			return word.capitalize()
		else:
			return word
	return replace
```

А вот пример использования этой функции:
```python
>>> re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE)
'UPPER SNAKE, lower snake, Mixed Snake'
>>>
```

### Обсуждение
В простых случаях простого использования *re.INGNORECASE* достаточно для поиска совпадений без учёта регистра. Однако обратите внимание, что этого может оказаться недостаточно для некоторых случаев работы с Unicode, использующих выравнивание регистров (case folding). См. **рецепт 2.10.**


## 2.7. Определение регулярных выражений для поиска кратчайшего совпадения
### Задача
Вы пытаетесь найти совпадение по текстовому шаблону, используя регулярное выражение, но оно находит самое длинное из всех возможных совпадений. Вы же хотите найти самое короткое из всех возможных.

### Решение
Эта проблема часто возникает в шаблонах, которые пытаются найти текст, заключенный в пару открывающих и закрывающих разделителей (например, строка в кавычках). Рассмотрим следующий пример:
```python
>>> str_pat = re.compile(r'\"(.*)\"')
>>> text1 = 'Computer says "no."'
>>> str_pat.findall(text1)
['no.']
>>> text2 = 'Computer says "no." Phone says "yes."'
>>> str_pat.findall(text2)
['no." Phone says "yes.']
>>>
```

В этом примере шаблон r'\"(\.\*)\"' пытается найти текст, заключенный в кавычки. Однако оператор \* в регулярном выражении является жадным, поэтому поиск получается поиском самого длинного из возможных совпадений. Поэтому во втором примере с переменной *text2* неверно выполняется сопоставление двух строк в кавычках.

Чтобы исправить это, добавьте модификатор ? после оператора \* в шаблоне:
```python
>>> str_pat = re.compile(r'\"(.*?)\"')
>>> str_pat.findall(text2)
['no.', 'yes.']
>>>
```
Это делает поиск совпадений нежадным и выводит кратчайшее из найденных совпадений.

### Обсуждение
Этот рецепт решает одну из часто встречающихся при написании регулярных выражений с символом точки (\.) задач. В шаблоне точка соотвествует любому символу за исключением символа новой строки. Однако если вы окружите точку открывающим и закрывающим текстом (таким как кавычки), поиск будет пытаться найти самое длинное из возможных совпадений. Это вызывает многочисленные случаи пропуска открывающего и закрывающего текста и включения в результаты самого длинного совпадения. Добавление ? сразу после таких операторов как \* или \+ заставляет алгоритм поиска искать самое короткое совпадение.

## 2.8. Написание регулярного выражения для многострочных шаблонов
### Вы пытаетесь провести поиск по блоку текстов с использованием регулярного выражения, но вам нужно, чтобы совпадение охватывало несколько строк.

### Решение
Эта проблема обычно возникает в шаблонах, которые используют точку (\.) для поиска совпадения с любым символом. Многие забывают, что точка не может совпадать с символом новой строки. Например, вы пытаетесь найти совпадения в комментариях в стиле языка С:
```python
>>> comment = re.compile(r'/\*(.*?)\*/')
>>> text1 = '/* this is a comment */'
>>> text2 = '''/* this is a
... multiline comment */
... '''
>>>
>>> comment.findall(text1)
[' this is a comment ']
>>> comment.findall(text2)
[]
>>>
```

Чтобы исправить проблему, вам нужно добавить поддержку символов новой строки. Например:
```python
>>> comment = re.compile(r'/\*((?:.|\n)*?)\*/')
>>> comment.findall(text2)
[' this is a\n multiline comment ']
>>>
```

В этом шаблоне (?:.|\n) определяет незахватывающую группу (то есть выражение определяет группу для целей поиска совпадений, но эта группа не захватывается и не подсчитывается).

### Обсуждение
Функция *re.compile()* принимает полезный в данном случае флаг *re.DOTALL*. Он заставляет . в регулярном выражении совпадать с любыми символами, включая символ новой строки. Например:
```python
>>> comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)
>>> comment.findall(text2)
[' this is a\n multiline comment ']
```

Использование флага *re.DOTALL* отличное работает в простых случаях, но это может быть проблематично при работе с очень сложными шаблонами или сочетанием отдельных регулярных выражений, которые должны объединяться друг с другом для токенизации (как описано в **рецепте 2.18.**) Если у вас есть выбор, обычно лучше определить шаблон регулярного выражения так, чтобы он работал правильно без необходимости в дополнительных флагах.

## 2.9. Приведение текста в Unicode к стандартному представлению (нормализация)
### Задача
Вы работате со строками Unicode и хотите убедиться, что все эти строки имеют одинаковое внутреннее представление.

### Решение
В Unicode некоторые символы могут быть представлены несколькими допустимыми кодирующими последовательностями. Рассмотрим пример:
```python
>>> s1 = 'Spicy Jalape\u00f1o'
>>> s2 = 'Spicy Jalapen\u0303o'
>>> s1
'Spicy Jalapeño'
>>> s2
'Spicy Jalapeño'
>>> s1 == s2
False
>>> len(s1)
14
>>> len(s2)
15
>>>
```

Здесь текст “Spicy Jalapeño” представлен в двух формах. Первая использует полноценный символ “ñ” (U\+00F1). Второй использует латинскую букву “n”, за которой следует дополняющий символ “~” (U\+0303).

Такие множественные представления становятся проблемой для программ, которые занимаются сравнением строк. Чтобы это исправить, вы должны сначала нормализовать текст, то есть привести его к стандартному представлению с помощью модуля *unicodedata*:
```python
>>> import unicodedata
>>> t1 = unicodedata.normalize('NFC', s1)
>>> t2 = unicodedata.normalize('NFC', s2)
>>> t1 == t2
True
>>> print(ascii(t1))
'Spicy Jalape\xf1o'

>>> t3 = unicodedata.normalize('NFD', s1)
>>> t4 = unicodedata.normalize('NFD', s2)
>>> t3 == t4
True
>>> print(ascii(t3))
'Spicy Jalapen\u0303o'
>>>
```

Первый аргумент, передаваемый в *normalize()*, определяет режим нормализации текста. NFC означает, что символы должны быть полноценными (то есть по возможности использовать только одну кодирующую последовательность). NFD означает, что символы должны быть декомпозированными, то есть разделенными на комбинирующиеся символы. 

Python также поддерживает режимы нормализации NFKC и NFKD, которые добавляют возможности совместимости, которые позволяют работать с определенными типами символов. Например:
```python
>>> s = '\ufb01'  # A single character
>>> s
'ﬁ'
>>> unicodedata.normalize('NFD', s)
'ﬁ'

# Notice how the combined letters are broken apart here
>>> unicodedata.normalize('NFKD', s)
'fi'
>>> unicodedata.normalize('NFKC', s)
'fi'
>>>
``` 

### Обсуждение
Нормализация — это важная часть любой программы, в которой присутствует необходимость обработки текста в Unicode разумным и единообразным способом. Это особенно важно, когда обрабатываемые строки поступают из пользовательского ввода, кодировку которого вы практически никак не контролируете.

Нормализация (приведение) также может быть важной частью чистки и фильтрации текста. Предположим, например, что вы хотите удалить из текста диакритические знаки (возможно, для цели поиска совпадений):
```python
>>> t1 = unicodedata.normalize('NFD', s1)
>>> ''.join(c for c in t1 if not unicodedata.combining(c))
'Spicy Jalapeno'
>>>
```     

Последний пример демонстрирует еще один важный аспект модуля *unicodedata*, а именно полезные функции для проверки принадлежности символов к определенным классам символов. Функция *combining()* проверяет, является ли символ объединяющимся. В этом модуле есть и другие функции для поиска символов определенных категорий, проверки цифр и так далее.

Unicode — весьма обширная тема. Для более подробной информации о нормализации посетите [соответствующую страницу](http://www.unicode.org/faq/normalization.html) на сайте Unicode. Нед Батчелдер также разместил на своем сайте [отличную презентацию](http://nedbatchelder.com/text/unipain.html) о решении проблем, связанных с Unicode в Python.  

## 2.10. Использование символов Unicode в регулярных выражениях
### Задача
Вы используете регулярные выражения для обработки текста, однако беспокоитесь о правильном взаимодействии с символами Unicode.

### Решение
По умолчанию модуль *re* уже имеет некоторые зачаточные представления о некоторых типах символов Unicode. Например, \\d совпадает с любым цифровым символом Unicode:
```python
>>> import re
>>> num = re.compile('\d+')
>>> # ASCII digits
>>> num.match('123')
<_sre.SRE_Match object at 0x1007d9ed0>

>>> # Arabic digits
>>> num.match('\u0661\u0662\u0663')
<_sre.SRE_Match object at 0x101234030>
>>>
```

Если вам нужно включить специфические символы Unicode в шаблоны, вы можете использовать обычные последовательности для экранирования символов Unicode (например, \uFFFF или \UFFFFFFF). Например, вот регексп, который найдет совпадения со всеми символами в нескольких разных арабских страницах:
```python
>>> arabic = re.compile('[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+')
>>>
```

При выполнении поиска совпадений следует нормализовывать и по возможноости чистить текст, приводя его к стандартной форме (см. **рецепт 2.9.**) Также нужно знать о некоторых специальных случаях. Например, рассмотрим поведение нечувствительного к регистру поиска совпадений при объединении с приведением к одному регистру:
```python
>>> pat = re.compile('stra\u00dfe', re.IGNORECASE)
>>> s = 'straße'
>>> pat.match(s)  # Matches
<_sre.SRE_Match object at 0x10069d370>
>>> pat.match(s.upper())  # Doesn't match
>>> s.upper()  # Case folds
'STRASSE'
>>>
```

### Обсуждение
Смешивание Unicode и регулярных выражений — отличный способ взорвать себе голову. Если вы собираетесь серьезно в это погрузиться, установите не включенную в стандартную поставку Python библиотеку [regex](https://pypi.python.org/pypi/regex), в которой есть полная поддержка приведения текстов в Unicode к одному регистру, а также множество других интересных возможностей, включая аппроксимирующий поиск совпадений.

## 2.11. Убирание нежелательных символов из строк
### Задача
Вы хотите убрать ненужные символы, такие как пробелы в начале, конце или середине текстовой строки.

### Решение
Метод *strip()* можно использовать для срезания символов в начале или конце строки. *lstrip()* и *rstrip()* выполняют срезание слева и справа соответственно. По умолчанию они срезают пробел, однако им можно передать и другие символы. Например:
```python
>>> # Whitespace stripping
>>> s = ' hello world  \n'
>>> s.strip()
'hello world'
>>> s.lstrip()
'hello world \n'
>>> s.rstrip()
' hello world'

>>>
>>> # Character stripping
>>> t = '-----hello====='
>>> t.lstrip('-')
'hello====='
>>> t.strip('-=')
'hello'
>>>
``` 

### Обсуждение
Различные методы *strip()* часто используются при чтении и чистке данных для последующей обработки. Например, вы можете использовать их, чтобы избавиться от пробелов, удалить кавычки и т.д.

Обратите внимание, что срезание символов нельзя применить к тексту в середине строки. Например:
```python
>>> s = ' hello world  \n'
>>> s = s.strip()
>>> s
'hello world'
>>>
```

Если вам нужно что-то сделать с внутренним пробелом, вам нужно применить другой приём, такой как использование метода *replace()* или подстановку с использованием регулярного выражения. Например:
```python
>>> s.replace(' ', '')
'helloworld'
>>> import re
>>> re.sub('\s+', ' ', s)
'hello world'
>>>
```

Часто вам нужно сочетать срезание символов с другими видами итерационной обработки, таким как чтением строк данных из файла. Если это так, то стоит применить выражение-генератор:
```python
with open(filename) as f:
	lines = (line.strip() for line in f)
	for line in lines:
		...
```

Здесь выражение *lines = (line.strip() for line in f)* работает как преобразователь данных. Это эффективно, потому что оно не читает данные из какого-либо временного списка. Оно просто создает итератор, где ко всем производимым строкам применена операция срезания символов.

Для более продвинутого срезания вам стоит обратиться к методу *translate()*. Детали вы найдете в следующем рецепте, где описана чистка строк.

## 2.12. Чистка строк
### Решение
Некий деятель ввел текст “pýtĥöñ” в форму на вашей веб-странице, и вы хотите как-то почистить эту строку.

### Решение
Проблема чистки текста применяется к широкому спектру задач с использованием парсинга текста и обработки данных. На самом простом уровне вы можете использовать простые строковые функции (например, *str.upper()* и *str.lower()* для приведения текста к стандартному регистру). Простые замены с использованием *str.replace()* или *re.sub()* помогут справиться с удалением или изменением некоторых специфических последовательностей символов. Вы также можете нормализовать текст, используя функцию *unicodedata.normalize()*, как показано в **рецепте 2.9.**

Однако вы можете пожелать сделать следующий шаг в процессе чистки. Предположим, например, что вы хотите удалить целые диапазоны символов или удалить диакритические знаки. Для этого вы можете обратиться к методу *str.translate()*. Предположим, у вас есть вот такая замусоренная строка:
```python
>>> s = 'pýtĥöñ\fis\tawesome\r\n'
>>> s
'pýtĥöñ\x0cis\tawesome\r\n'
>>>
```

Первый шаг — удалить пробел. Сделаем небольшую таблицу перевода и задействуем *translate()*:
```python
>>> remap = {
...   ord('\t') : ' ',
...   ord('\f') : ' ',
...   ord('\r') : None  # Deleted
... }
>>> a = s.translate(remap)
>>> a
'pýtĥöñ is awesome\n'
>>>
```

Как вы можете увидеть, символы пробелов, такие как \t и \f, были приведены к единой форме. Символ возврата каретки \r был удален. 

Вы можете продолжить идею и создать намного более крупные таблицы перевода. Например, давайте удалим все комбинирующиеся символы:
```python
>>> import unicodedata
>>> import sys
>>> cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode)
...   if unicodedata.combining(chr(c)))
...
>>> b = unicodedata.normalize('NFD', a)
>>> b
'pýtĥöñ is awesome\n'
>>> b.translate(cmb_chrs)
'python is awesome\n'
>>>
``` 

В последнем примере с помощью *dict.fromkeys()* был создан словарь, отображающий все комбинирующиеся символы Unicode на None. 

Первоначальные вводные данные затем были нормализованы в декомпозированную форму с использованием *unicodedata.normalize()*. Далее функция *translate()* используется для удаления значков. Похожие приёмы могут быть использованы для удаления символов другого типа (например, управляющих символов). 

Ещё один пример — таблица перевода, которая отображает все десятичные цифры Unicode на их эквиваленты в ASCII:
```python
>>> digitmap = { c: ord('0') + unicodedata.digit(chr(c))
...   for c in range(sys.maxunicode)
...   if unicodedata.category(chr(c)) == 'Nd' }
...
>>> len(digitmap)
460
>>> # Arabic digits
>>> x = '\u0661\u0662\u0663'
>>> x.translate(digitmap)
'123'
>>>
```

Ещё один приём для чистки текста использует функции кодирования и декодирования ввода-вывода. Идея состоит в выполнении некоторой первичной очистки текста, а затем пропускании его через encode() и decode() для срезания символов или изменения. Например:
```python
>>> a
'pýtĥöñ is awesome\n'
>>> b = unicodedata.normalize('NFD', a)
>>> b.encode('ascii', 'ignore').decode('ascii')
'python is awesome\n'
>>>
```

Здесь процесс нормализации разложил исходный текст на символы вместе с отдельными комбинирующимися символами. Последовательное кодирование и декодирование в ASCII просто удаляет все эти эти символы. Естественно, это сработает только в том случае, если нашей целью было получение ASCII-представления.

### Обсуждение
Большой проблемой с чисткой текста может стать производительность. Общее правило: чем проще обработка, тем быстрее она работает. Для простых замен метод *str.replace()* часто оказывается самым быстрым способом — даже если вызывать его несколько раз. Например, чтобы вычистить пробелы, вы можете использовать такую программу:
```python
def clean_spaces(s):
s = s.replace('\r', '')
s = s.replace('\t', ' ')
s = s.replace('\f', ' ')
return s
``` 

Если вы попробуете это, то обнаружите, что метод немного быстрее использования *translate()* или регулярных выражений.

С другой стороны, метод *translate()* очень быстр, если вам нужно выполнить любую нетривиальную операцию замены символов на другие символы или удаления символов.

Производительность — это нечто, что вам придется изучать в каждом конкретном приложении. К несчастью, невозможно предложить один приём, который будет работать лучше всего во всех возможных ситуациях, поэтому пробуйте разные подходы и измеряйте результы.

Хотя этот рецепт делает акцент на работе с текстом, похожие приёмы могут быть применены к последовательностям байтов.   


## 2.13. Выравнивание текстовых строк
### Задача
Вам нужно отформатировать текст с применением некого выравнивания.

### Решение
Для базового выравнивания строк можно использовать методы *ljust()*, *rjust()* и *center()*. Например:
```python
>>> text = 'Hello World'
>>> text.ljust(20)
'Hello World '
>>> text.rjust(20)
' Hello World'
>>> text.center(20)
' Hello World '
>>>
```

Все эти методы могут принимать опциональный символ заполнения. Например:
```python
>>> text.rjust(20,'=')
'=========Hello World'
>>> text.center(20,'*')
'****Hello World*****'
>>>
``` 

Функция *format()* также может быть использована для выравнивания. Вам нужно просто использовать символы <, > или ^ вместе с желаемой шириной. Например:
```python
>>> format(text, '>20')
' Hello World'
>>> format(text, '<20')
'Hello World '
>>> format(text, '^20')
' Hello World '
>>>
```

Если вы хотите использовать в качестве заполняющего символа не пробел, определите его перед символом выравнивания:
```python
>>> format(text, '=>20s')
'=========Hello World'
>>> format(text, '*^20s')
'****Hello World*****'
>>>
```

Эти коды форматирования могут быть также использованы с методом *format()* при обработке нескольких значений. Например:
```python
>>> '{:>10s} {:>10s}'.format('Hello', 'World')
' Hello World'
>>>
```

У *format()* есть преимущество — он работает не только со строками. Он работает с любыми значениями, что делает его назначение очень широким. Например, вы можете использовать его с числами:
```python
>>> x = 1.2345
>>> format(x, '>10')
' 1.2345'
>>> format(x, '^10.2f')
' 1.23 '
>>>
```

### Обсуждение
В старых программах вы также можете увидеть, как для форматирования текста использовался оператор %. Например:
```python
>>> '%-20s' % text
'Hello World '
>>> '%20s' % text
' Hello World'
>>>
```  

Однако в новых программах вы должны предпочитать функцию или метод *format()*. Онам намного мощнее оператора %. Более того, *format()* может применяться более широко, нежели строковые методы *ljlust()*, *rjust()* или *center()*, поскольку работает с любыми объектами. 

За полным списком возможностей функции *format()* обратитесь к [документации Python](https://docs.python.org/3/library/string.html#formatspec).

## 2.14. Объединение и конкатенация строк
### Задача
Вам нужно объединить много небольших строк в большую строку. 

### Решение
Если строки, которые вы хотите объединить, находятся в последовательности или итерируемом объекте, самый быстрый способ — использовать метод *join()*. Например:
```python
>>> parts = ['Is', 'Chicago', 'Not', 'Chicago?']
>>> ' '.join(parts)
'Is Chicago Not Chicago?'
>>> ','.join(parts)
'Is,Chicago,Not,Chicago?'
>>> ''.join(parts)
'IsChicagoNotChicago?'
>>>
```

На первый взгляд синтаксис может показаться странным, однако операция *join()* относится к строковым методам. Объекты, которые вы хотите объединить, могут приходить из разнообразных последовательностей данных: (списки, кортежи, словари, файлы, множества или генераторы), поэтому было бы избыточным имплементировать метод *join()* для всех этих объектов. Поэтому вы просто задаете нужную строку-разделитель, а затем применяете метод *join()* для склеивания текстовых фрагментов.

Если вы просто объединяете несколько строк, неплохо сработает \+:
```python
>>> a = 'Is Chicago'
>>> b = 'Not Chicago?'
>>> a + ' ' + b
'Is Chicago Not Chicago?'
>>>
```

Оператор \+ также отлично работает в качестве замены более сложным операциям форматирования строк. Например:
```python
>>> print('{} {}'.format(a,b))
Is Chicago Not Chicago?
>>> print(a + ' ' + b)
Is Chicago Not Chicago?
>>>
```

Если вы пытаетесь объединить строковые литералы в исходном коде, вы можете просто разместить их рядом без использования оператора \+. Например:
```python
>>> a = 'Hello' 'World'
>>> a
'HelloWorld'
>>>
```

### Обсуждение
Объединение строк может показаться недостаточно сложным, чтобы писать про него целый рецепт, но часто эта область является критически важной для производительности. 

Важно знать, что использование оператора \+ для объединения большого количества строк крайне неэффективно, посколько в памяти создаются копии, что прибавляет работы сборщику мусора. Никогда не пишите такой код для объединения строк:
```python
s = ''
for p in parts:
	s += p
```

Это работает заметно медленнее метода *join()*, главным образом потому, что каждая \+= операция создает новый строковый объект. Намного лучше собрать все части и только затем объединить.

Еще один классный фокус из этой области — преобразование данных в строки и конкатенация с одновременным использованием выражения-генератора, как описано в **рецепте 1.19.** Например:
```python
>>> data = ['ACME', 50, 91.1]
>>> ','.join(str(d) for d in data)
'ACME,50,91.1'
>>>
```

Берегитесь ненужной конкатенации. Иногда программисты применяют конкатенацию там, где это не нужно. Например:
```python
print(a + ':' + b + ':' + c)  # Ugly
print(':'.join([a, b, c]))  # Still ugly

print(a, b, c, sep=':')  # Better
```

Смешивание операций ввода-вывода и конкатенации строк — момент, с которым нужно быть очень внимательными. Наример, рассмотрим два фрагмента кода:
```python
# Version 1 (string concatenation)
f.write(chunk1 + chunk2)

# Version 2 (separate I/O operations)
f.write(chunk1)
f.write(chunk2)
```

Если две строки невелики, первая может предложить намного большую производительность благодаря дороговизне системного вызова ввода-вывода. Однако если строки велики, вторая версия может быть более эффективной, поскольку в это случае не создается огромный промежуточный результат и не происходит копирования больших блоков памяти. Пробуйте на своих данных и выясняйте, что работает быстрее в вашем конкретном случае.

И последнее: если вы пишите код, который формирует результат из множества небольших строк, подумайте о том, чтобы оформить его как генератор, используя *yield* для производства фрагментов. Например:
```python
def sample():
yield 'Is'
yield 'Chicago'
yield 'Not'
yield 'Chicago?'
```

Интересно, что этот подход не делает предположений по поводу того, как фрагменты будут собираться вместе. Например, вы можете просто объединить фрагменты с помощью *join()*:
```python
text = ''.join(sample())
```

Или же вы можете перенаправить фрагменты на вывод:
```python
for part in sample():
	f.write(part)
```

Или же вы можете создать некую гибридную схему, что умно с точки зрения операций ввода-вывода:
```python
def combine(source, maxsize):
	parts = []
	size = 0
	for part in source:
		parts.append(part)
		size += len(part)
		if size > maxsize:
			yield ''.join(parts)
			parts = []
			size = 0
	yield ''.join(parts)

for part in combine(sample(), 32768):
	f.write(part)
```

Ключевой момент в том, что первоначальный генератор не обязан знать деталей: он просто выдает части.



## 2.15. Интерполяция переменных в строках
### Задача
Вы хотите создать строку, в которой на место переменных будут подставляться строковые представления значений этих переменных.

### Решение
В Python нет прямой поддержки простой подстановки значений переменных в строках. Однако строковый метод *format()* предоставляет приближенную по смыслу возможность: Например:
```python
>>> s = '{name} has {n} messages.'
>>> s.format(name='Guido', n=37)
'Guido has 37 messages.'
>>>
``` 

Если значения, которые должны быть подставлены, на самом деле находятся в переменных, вы можете использовать сочетание *format_map()* и *vars()*, как показано тут:
```python
>>> name = 'Guido'
>>> n = 37
>>> s.format_map(vars())
'Guido has 37 messages.'
>>>
```

Стоит отметить, что *vars()* также работает с экземплярами. Например:
```python
>>> class Info:
...   def __init__(self, name, n):
...   self.name = name
...   self.n = n
...
>>> a = Info('Guido',37)
>>> s.format_map(vars(a))
'Guido has 37 messages.'
>>>
```

Недостаток *format()* и *format(map)* в том, что они не могут аккуратно справиться с отсутствующими значениями. Например:
```python
>>> s.format(name='Guido')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
KeyError: 'n'
>>>
```

Этого можно избежать путём определения альтернативный класс словаря с методом *__missing__()*, как показано ниже:
```python
class safesub(dict):
	def __missing__(self, key):
		return '{' + key + '}'
```

Теперь этот класс можно использовать, чтобы обернуть значения, которые подаются на вход в *format_map()*:
```python
>>> del n  # Make sure n is undefined
>>> s.format_map(safesub(vars()))
'Guido has {n} messages.'
>>>
``` 

Если вы обнаружите, что часто делаете такие вещи в своей программе, вы можете спрятать процесс подстановки переменных в небольшую функцию, которая использует так называемый “frame hack”. Например:
```python
import sys
def sub(text):
	return text.format_map(safesub(sys._getframe(1).f_locals))
```

Теперь вы можете делать вот так:
```python
>>> name = 'Guido'
>>> n = 37
>>> print(sub('Hello {name}'))
Hello Guido
>>> print(sub('You have {n} messages.'))
You have 37 messages.
>>> print(sub('Your favorite color is {color}'))
Your favorite color is {color}
>>>
```

### Обсуждение
Отсутствие настоящей интерполяции переменных в Python привело к созданию разнообразных решений. В качестве альтернативы описанным выше решениям, вы иногда можете увидеть такой подход к форматированию строк:
```python
>>> name = 'Guido'
>>> n = 37
>>> '%(name) has %(n) messages.' % vars()
'Guido has 37 messages.'
>>>
```

Или же вам могут попасться строки-темплейты:
```python
>>> import string
>>> s = string.Template('$name has $n messages.')
>>> s.substitute(vars())
'Guido has 37 messages.'
>>>
```

Однако методы *format()* и *format_map()* являеются более современными, нежели эти альтернативы, и отдавать предпочтение нужно им. Преимущество использования *format()* заключается в том, что вы также получаете все возможности форматирования строк (выравнивание, отступы, нумерация и т.п.), что недоступно для альтернативных решений, таких как строковые объекты *Template*.

В этом рецепте нам также удалось показать несколько интересных продвинутых возможностей. Малоизвестный метод классов словарей и отображений *__missing()__* позволяет вам определить подход для работы с отсутствующими значениями. В классе *safesub* этот метод был определен таким образом, чтобы возвращать отсутствующие значения в форме заглушки (плейсхолдера). Вместо того, чтобы получить исключение *KeyException*, вы увидите отсутствующие значения появляющимися в строке-результате (что может оказаться полезным для дебаггинга).

Функция *sub()* использует *sys._getframe(1)* чтобы вернуть фрейм стека вызывающего. Отсюда атрибут *f_locals* доступен, чтобы получить локальные переменные. Стоит отметить, что игр с фреймами стека стоит избегать. Однако для утилитарных функций типа строковой подстановки это может оказаться полезным. Отдельно заметим, что *f_locals* — это словарь, который является копией локальных переменных в вызывающей функции. Хотя вы можете изменить содержимое *f_locals*, эти изменения не станут постоянными. Поэтому, хотя доступ другому фрейму стека и может показаться адским злом, невозможно случайно переписать переменные или изменить локальное окружение вызывающей функции (caller).   

## 2.16. Разбивка текста на фиксированное количество колонок
### Задача
У вас есть длинные строки, которые вы хотите переформатировать таким образом, чтобы они распределились по заданному пользователем количеству колонок.

### Решение
Используйте модуль *textwrap* для переформатирования выводимого текста. Предположим, например, что у вас есть такая длинная строка:
```python
s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under."
```

Вот как вы можете использовать модуль *textwrap* чтобы переформатировать её различным образом:
```python
>>> import textwrap
>>> print(textwrap.fill(s, 70))
Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
not around the eyes, don't look around the eyes, look into my eyes,
you're under.

>>> print(textwrap.fill(s, 40))
Look into my eyes, look into my eyes,
the eyes, the eyes, the eyes, not around
the eyes, don't look around the eyes,
look into my eyes, you're under.

>>> print(textwrap.fill(s, 40, initial_indent=' '))
Look into my eyes, look into my
eyes, the eyes, the eyes, the eyes, not
around the eyes, don't look around the
eyes, look into my eyes, you're under.

>>> print(textwrap.fill(s, 40, subsequent_indent=' '))
Look into my eyes, look into my eyes,
the eyes, the eyes, the eyes, not
around the eyes, don't look around
the eyes, look into my eyes, you're
under.
```

### Обсуждение
Модуль *textwrap* — это простой способ очистить текст — особенно если вы хотите, чтобы вывод соответствовал размерам терминала. К вопросу о размере терминала: вы можете получить его, используя *os.get_terminal_size()*. Например: 
```python
>>> import os
>>> os.get_terminal_size().columns
80
>>>
```

У метода *fill()* есть неколько дополнительных параметров, которые контролируют то, как он обращается с табуляцией, окончаниями предложений и т.д. За подробностями обратитесь к [документации класса textwrap.TextWrapper](https://docs.python.org/3.3/library/textwrap.html#textwrap.TextWrapper).


## 2.17. Работа с HTML- и XML-сущностями в тексте
### Задача
Вы хотите заменить HTML- и XML-сущности, такие как *&entity;* или *&\#code;*, соответствующим текстом. Или же вам нужно произвести текст, но экранировать некоторые символы (например, <, > или &).

### Решение
Если вы производите текст, довольно просто заменить спецсимволы типа < или > с помощью функции *html.escape()*. Например:
```python
>>> s = 'Elements are written as "<tag>text</tag>".'
>>> import html
>>> print(s)
Elements are written as "<tag>text</tag>".
>>> print(html.escape(s))
Elements are written as &quot;&lt;tag&gt;text&lt;/tag&gt;&quot;.

>>> # Disable escaping of quotes
>>> print(html.escape(s, quote=False))
Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".
>>>
```

Если вы хотите произвести текст в кодировке ASCII и вставить коды символов вместо отсутствующих в ASCII символов, вы можете использовать аргумент *errors='xmlcharrefreplace'* с различными функциями ввода-вывода. Например:
```python
>>> s = 'Spicy Jalapeño'
>>> s.encode('ascii', errors='xmlcharrefreplace')
b'Spicy Jalape&#241;o'
>>>
```

Чтобы заменить сущности в тексте, нужен другой подход. Если обрабатываете HTML или XML, попробуйте для начала настоящий парсер HTML или XML. Обычно эти инструменты автоматически позаботятся о замене значений во время парсинга, и вам не придётся об этом беспокоиться. 

Если же по каким-то причинам вы получили голый текст с включением сущностей, и вы хотите заменить их вручную, вы сможете сделать это с помощью различных функций и методов, связанных с парсерами HTML и XML. Например:
```python
>>> s = 'Spicy &quot;Jalape&#241;o&quot.'
>>> from html.parser import HTMLParser
>>> p = HTMLParser()
>>> p.unescape(s)
'Spicy "Jalapeño".'
>>>

>>> t = 'The prompt is &gt;&gt;&gt;'
>>> from xml.sax.saxutils import unescape
>>> unescape(t)
'The prompt is >>>'
>>>
``` 

### Обсуждение
О правильном экранировании спецсимволов при генерировании HTML или XML легко забыть. Это особенно верно, если вы генерируете вывод самостоятельно, используя *print()* или другую базовую функцию строкового форматирования. Есть простое решение — использовать функции типа *html.escape()*.

Если вам нужно произвести обратное преобразование текста, к вашим услугам различные фукции типа *xml.sax.saxutils.unescape()*. Однако мы все же рекомендуем использовать парсер. Например, если при обработке HTML и XML использовать такие парсеры как *html.parser* или *xml.etree.ElementTree*, они самостоятельно позаботятся о замене сущностей в тексте.

## 2.18. Токенизация текста
### Задача
У вас есть строка, которую вы хотите распарсить в поток токенов слева направо.

### Решение
Предположим, у вас есть вот такая строка:
```python
text = 'foo = 23 + 42 * 10'
```

Чтобы токенизировать строку, вам нужно нечто большее, чем простой поиск по шаблонам. Вам также нужен способ определить тип шаблона. Например, вы можете захотеть превратить строку в последовательность пар:
```python
tokens = [('NAME', 'foo'), ('EQ','='), ('NUM', '23'), ('PLUS','+'),
('NUM', '42'), ('TIMES', '*'), ('NUM', 10')]
```

Для разрезания такого типа первым шагом должно быть определение всех возможных токенов, включая пробелы, с помошью шаблонов регулярных выражений, использующих именованные захватывающие группы:
```python
import re
NAME = r'(?P<NAME>[a-zA-Z_][a-zA-Z_0-9]*)'
NUM  = r'(?P<NUM>\d+)'
PLUS = r'(?P<PLUS>\+)'
TIMES = r'(?P<TIMES>\*)'
EQ  = r'(?P<EQ>=)'
WS  = r'(?P<WS>\s+)'

master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))
```

В этих шаблонах условие *?P<TOKENNAME>* используется для присваивания имени шаблону. Это мы используем позже.

Далее, для собственно токенизации, используем малоизвестный метод объектов шаблонов *scanner()*. Этот метод создает объект сканера, в котором повторно вызывается шаг *match()* для предоставленного текста, выполняя один поиск совпадения за раз. Вот интерактивный пример работы объекта сканера:
```python
>>> scanner = master_pat.scanner('foo = 42')
>>> scanner.match()
<_sre.SRE_Match object at 0x100677738>
>>> _.lastgroup, _.group()
('NAME', 'foo')
>>> scanner.match()
<_sre.SRE_Match object at 0x100677738>
>>> _.lastgroup, _.group()
('WS', ' ')
>>> scanner.match()
<_sre.SRE_Match object at 0x100677738>
>>> _.lastgroup, _.group()
('EQ', '=')
>>> scanner.match()
<_sre.SRE_Match object at 0x100677738>
>>> _.lastgroup, _.group()
('WS', ' ')
>>> scanner.match()
<_sre.SRE_Match object at 0x100677738>
>>> _.lastgroup, _.group()
('NUM', '42')
>>> scanner.match()
>>>
```

Чтобы взять это приём и использовать в программе, он должен быть очищен и упакован в генератор:
```python
from collections import namedtuple

Token = namedtuple('Token', ['type','value'])

def generate_tokens(pat, text):
	scanner = pat.scanner(text)
		for m in iter(scanner.match, None):
			yield Token(m.lastgroup, m.group())

# Example use
for tok in generate_tokens(master_pat, 'foo = 42'):
	print(tok)

# Produces output
# Token(type='NAME', value='foo')
# Token(type='WS', value=' ')
# Token(type='EQ', value='=')
# Token(type='WS', value=' ')
# Token(type='NUM', value='42')
```

Если вы хотите как-то отфильтровать поток токенов, вы можете либо определить больше генераторов, либо использовать выражение-генератор. Например, вот так можно отфильтровать все токены-пробелы:
```python
tokens = (tok for tok in generate_tokens(master_pat, text)
	if tok.type != 'WS')
for tok in tokens:
	print(tok)
```

### Обсуждение
Токенизация часто является первым шагом более продвинутого парсинга и обработки текста. Чтобы использовать показанные приёмы сканирования, нужно держать в уме несколько важных моментов. Во-первых, вы должны убедиться, что вы определили соответствующие шаблоны регулярных выражений для всех возможных текстовых последовательностей, которые могут встретиться во входных данных. Если встретится текст, для которого нельзя найти совпадение, сканирование просто остановится. Вот почему необходимо было определить токен пробела (WS) в примере выше.

Порядок токенов в главном регулярном выражении также важен. При поиске совпадений регулярное выражение пытается отыскать совпадения с шаблонами в заданном порядке. Поэтому если шаблон окажется подстрокой более длинного шаблона, вы должны убедиться, что более длинный шаблон вписан в выражение первым. Например:
```python
LT = r'(?P<LT><)'
LE = r'(?P<LE><=)'
EQ = r'(?P<EQ>=)'

master_pat = re.compile('|'.join([LE, LT, EQ]))  # Correct
# master_pat = re.compile('|'.join([LT, LE, EQ])) # Incorrect
```

Второй шаблон неправильный, потому что он будет отыскивать совпадение с <=, поскольку за токеном LT следует токен EQ, а не LE.

И последнее: вы должны следить за шаблонами, формирующими подстроки. Предположим, например, что у вас есть два шаблона:
```python
PRINT = r'(P<PRINT>print)'
NAME  = r'(P<NAME>[a-zA-Z_][a-zA-Z_0-9]*)'

master_pat = re.compile('|'.join([PRINT, NAME]))

for tok in generate_tokens(master_pat, 'printer'):
	print(tok)

# Outputs :
# Token(type='PRINT', value='print')
# Token(type='NAME', value='er')
```

Для более продвинутого токенизирования вы можете обратиться к пакетам [PyParsing](http://pyparsing.wikispaces.com/) или [PLY](http://www.dabeaz.com/ply/index.html). Пример использования PLY вы найдете в следующем рецепте.

## 2.19. Написание простого парсера на основе метода рекурсивного спуска
### Задача
Вам нужно распарсить текст в соответствии с грамматическими правилами и выполнить действия или построить абстрактное синтаксическое дерево, представляющее входные данные.

### Решение
В этой задаче мы сосредоточены на парсинге текста в соответствии с некоторой определенной грамматикой. Чтобы это сделать, вы должны начать с формальной спецификации грамматики в форме BNF (БНФ, форма Бэкуса — Наура) или EBNF (РБНФ, расширенная форма Бэкуса — Наура). Например, грамматика для простых арифметических выражений может выглядеть так:

	expr ::= expr + term
		| expr - term
		| term
	
	term ::= term * factor
		| term / factor
		| factor
	
	factor ::= ( expr )
		| NUM

А вот альтернативная форма РБНФ:

	expr ::= term { (+|-) term }*

	term ::= factor { (*|/) factor }*

	factor ::= ( expr )
		| NUM

В РБНФ части правил, заключенные в { ... }\* являются необязательными. \* означает ноль и более повторений (то есть имеет такое значение, как и в регулярных выражениях).

Теперь, если вы незнакомы с механизмом работы БНФ, думайте о ней как об определении правил замены или подстановки, где символы слева могут быть заменены символами справа (или наоборот). В общем, во время парсинга вы пытаетесь сопоставить входящий текст с грамматикой, делая различные подстановки и расширения с использованием БНФ. Чтобы проиллюстрировать это, предположим, что вы парсите выражение 3 \+ 4 \* 5. Это выражение должно быть сначала разбито на поток токенов с использованием описанных в **рецепте 2.18.** приёмов. Результатом будет последовательность токенов:

	NUM + NUM * NUM

С этого момента парсинг начинает пытаться сопоставить грамматику с входящими токенами, делая подстановки:

	expr
	expr ::= term { (+|-) term }*
	expr ::= factor { (*|/) factor }* { (+|-) term }*
	expr ::= NUM { (*|/) factor }* { (+|-) term }*
	expr ::= NUM { (+|-) term }*
	expr ::= NUM + term { (+|-) term }*
	expr ::= NUM + factor { (*|/) factor }* { (+|-) term }*
	expr ::= NUM + NUM { (*|/) factor}* { (+|-) term }*
	expr ::= NUM + NUM * factor { (*|/) factor }* { (+|-) term }*
	expr ::= NUM + NUM * NUM { (*|/) factor }* { (+|-) term }*
	expr ::= NUM + NUM * NUM { (+|-) term }*
	expr ::= NUM + NUM * NUM

Чтобы пройти по всем шагам подстановки и разобраться, придётся потратить время, но в целом они работают так: смотрят на входящие данные и пытаются сопоставить их с правилами грамматики. Первый входящий токен — это NUM, поэтому подстановки сначала сосредотачиваются на поиске совпадений с этой частью. Когда совпадение найдено, внимание переходит к следующему токену \+ и т.д. Некоторые части правой стороны (например, { (\*/) factor }\*) иcчезают, когда определено, что они не совпадают со следующим токеном. Парсинг проходит успешно, если правая сторона достаточно полна, чтобы охватить все входящие токены. 

Со всей вышеизложенной вводной информацией перейдем к простому рецепту построения «выполнителя» выражений, работающего по методу рекурсивного спуска:
```python
import re
import collections

# Token specification
NUM  = r'(?P<NUM>\d+)'
PLUS  = r'(?P<PLUS>\+)'
MINUS  = r'(?P<MINUS>-)'
TIMES  = r'(?P<TIMES>\*)'
DIVIDE = r'(?P<DIVIDE>/)'
LPAREN = r'(?P<LPAREN>\()'
RPAREN = r'(?P<RPAREN>\))'
WS  = r'(?P<WS>\s+)'

master_pat = re.compile('|'.join([NUM, PLUS, MINUS, TIMES,
                                  DIVIDE, LPAREN, RPAREN, WS]))

# Tokenizer
Token = collections.namedtuple('Token', ['type','value'])

def generate_tokens(text):
	scanner = master_pat.scanner(text)
	for m in iter(scanner.match, None):
		tok = Token(m.lastgroup, m.group())
		if tok.type != 'WS':
			yield tok

# Parser
class ExpressionEvaluator:
	'''
	Implementation of a recursive descent parser. Each method
	implements a single grammar rule. Use the ._accept() method
	to test and accept the current lookahead token. Use the ._expect()
	method to exactly match and discard the next token on on the input
	(or raise a SyntaxError if it doesn't match).
	'''

	def parse(self,text):
		self.tokens = generate_tokens(text)
		self.tok = None  # Last symbol consumed
		self.nexttok = None  # Next symbol tokenized
		self._advance()  # Load first lookahead token
		return self.expr()

	def _advance(self):
		'Advance one token ahead'
		self.tok, self.nexttok = self.nexttok, next(self.tokens, None)

	def _accept(self,toktype):
		'Test and consume the next token if it matches toktype'
		if self.nexttok and self.nexttok.type == toktype:
			self._advance()
			return True
		else:
			return False

	def _expect(self,toktype):
		'Consume next token if it matches toktype or raise SyntaxError'
		if not self._accept(toktype):
			raise SyntaxError('Expected ' + toktype)

	# Grammar rules follow

	def expr(self):
		"expression ::= term { ('+'|'-') term }*"

		exprval = self.term()
		while self._accept('PLUS') or self._accept('MINUS'):
			op = self.tok.type
			right = self.term()
			if op == 'PLUS':
				exprval += right
			elif op == 'MINUS':
				exprval -= right
			return exprval

	def term(self):
		"term ::= factor { ('*'|'/') factor }*"
		
		termval = self.factor()
		while self._accept('TIMES') or self._accept('DIVIDE'):
			op = self.tok.type
			right = self.factor()
			if op == 'TIMES':
				termval *= right
			elif op == 'DIVIDE':
				termval /= right
		return termval

	def factor(self):
		"factor ::= NUM | ( expr )"

		if self._accept('NUM'):
			return int(self.tok.value)
		elif self._accept('LPAREN'):
			exprval = self.expr()
			self._expect('RPAREN')
			return exprval
		else:
			raise SyntaxError('Expected NUMBER or LPAREN')
```   

Вот пример интерактивного использования класса ExpressionEvaluator:
```python
>>> e = ExpressionEvaluator()
>>> e.parse('2')
2
>>> e.parse('2 + 3')
5
>>> e.parse('2 + 3 * 4')
14
>>> e.parse('2 + (3 + 4) * 5')
37
>>> e.parse('2 + (3 + * 4)')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "exprparse.py", line 40, in parse
		return self.expr()
	File "exprparse.py", line 67, in expr
		right = self.term()
	File "exprparse.py", line 77, in term
		termval = self.factor()
	File "exprparse.py", line 93, in factor
		exprval = self.expr()
	File "exprparse.py", line 67, in expr
		right = self.term()
	File "exprparse.py", line 77, in term
		termval = self.factor()
	File "exprparse.py", line 97, in factor
		raise SyntaxError("Expected NUMBER or LPAREN")
SyntaxError: Expected NUMBER or LPAREN
>>>
```

Если вы хотите сделать что-то другое, а не только простое вычисление, вам нужно изменить класс ExpressionEvaluator. Например, вот альтернативная имплементация, которая конструирует простое дерево разбора (парсинга):
```python
class ExpressionTreeBuilder(ExpressionEvaluator):
	def expr(self):
		"expression ::= term { ('+'|'-') term }"

		exprval = self.term()
		while self._accept('PLUS') or self._accept('MINUS'):
			op = self.tok.type
			right = self.term()
			if op == 'PLUS':
				exprval = ('+', exprval, right)
			elif op == 'MINUS':
				exprval = ('-', exprval, right)
		return exprval

	def term(self):
		"term ::= factor { ('*'|'/') factor }"
		
		termval = self.factor()
		while self._accept('TIMES') or self._accept('DIVIDE'):
			op = self.tok.type
			right = self.factor()
			if op == 'TIMES':
				termval = ('*', termval, right)
			elif op == 'DIVIDE':
				termval = ('/', termval, right)
		return termval

	def factor(self):
		'factor ::= NUM | ( expr )'

		if self._accept('NUM'):
			return int(self.tok.value)
		elif self._accept('LPAREN'):
			exprval = self.expr()
			self._expect('RPAREN')
			return exprval
		else:
			raise SyntaxError('Expected NUMBER or LPAREN')
```

Вот как это работает:
```python
>>> e = ExpressionTreeBuilder()
>>> e.parse('2 + 3')
('+', 2, 3)
>>> e.parse('2 + 3 * 4')
('+', 2, ('*', 3, 4))
>>> e.parse('2 + (3 + 4) * 5')
('+', 2, ('*', ('+', 3, 4), 5))
>>> e.parse('2 + 3 + 4')
('+', ('+', 2, 3), 4)
>>>
```

### Обсуждение
Парсинг — это обширная тема, освоение которой обычно занимает у студентов первые три недели курса изучения компиляторов. Если вы ищите, где бы почерпнуть знания о грамматиках, алгоритмах разбор и прочую подобную информацию, обратитесь к книгам о компиляторах. Нет нужды говорить, что всё это втиснуть в эту книгу просто невозможно.

Тем не менее, общая идея парсера на основе рекурсивного спуска проста. Для начала вы берете каждое правило грамматики и превращаете его в функцию или метод. Если ваша грамматика выглядит так:

	expr ::= term { ('+'|'-') term }*
	term ::= factor { ('*'|'/') factor }*
	factor ::= '(' expr ')'
	| NUM

То вы начинаете с превращения её в такой набор методов:
```python
class ExpressionEvaluator:
	...
	def expr(self):
		...
	def term(self):
		...
	def factor(self):
		...
```

Задача каждого метода проста: он должен пройти слева направо по каждой части грамматического правила, потребляя токены в процессе. Цель метода — либо потребить правило, либо сгенерировать синтаксическую ошибку в случае застревания. Чтобы реализовать это, применяются следующие приёмы:

* Если следующий символ в правиле является именем другого грамматического правила (например, term или factor), вы просто вызываете метод с этим именем. Это  «спуск» алгоритма — управление спускается в другое грамматическое правило. Иногда правила могут использовать вызовы методов, которые уже выполняются (например, вызов expr в правиле factor ::= '(' expr ')'). Это «рекурсивность» алгоритма.  
* Если следующий символ в правиле должен быть конкретным символом (например, (), вы смотрите на следующий токен и проверяете на точное совпадение. Если он не совпадает, то это синтаксическая ошибка. В этом рецепте для выполнения этих шагов используется метод *_expect()*.
* Если следующий символ в правиле может соответствовать нескольким возможным выборам (например, \+ или -), вы должны проверить следующий токен на каждую из этих возможностей и продвигаться вперед только в том случае, если совпадение найдено. В этом рецепте за это отвечает метод *_accept()*. Он похож на более слабую версию метода *_expect()* — в том отношении, что он продвинется вперед только если совпадение найдено, но если нет, то он просто отступает, не возбуждая ошибку (что позволяет сделать другие проверки).
* Для грамматических правил с повторяющимися частями (как, например, в правиле expr ::= term { ('\+'|'-') term }\*), повторение имплементируется циклом *while*. Тело цикла будет в общем собирать или обрабатывать все повторяющиеся значения, пока они не закончатся.
* Если грамматическое правило потреблено, каждый метод возвращает некий результат тому, кто его вызывал. Так значения передаются во время парсинга. Например, в «вычислителе» выражений возвращаемые значения будут представлять частичные результаты разбираемого выражения. В конце концов они все объединятся в высшем методе грамматического правила, который будет выполнен.

Хотя здесь мы показали простой пример, парсеры на основе рекурсивного спуска могут быть использованы для создания весьма сложных парсеров. Например, код самого Python интерпретируется парсером на основе метода рекурсивного спуска. Если вы заинтересовались, вы можете залезть в файл Grammar/Grammar в исходном коде Python и взглянуть на грамматику под капотом. При всём при этом, конечно, в ручном создании парсеров множество ограничений и ловушек.

Одно из таких ограничений парсеров на основе рекурсивного спуска заключается в том, что они не могут быть написаны для грамматических правил, использующих левую рекурсию. Предположим, например, что вам нужно перевести такое правило:

	items ::= items ',' item
	| item

Чтобы сделать это, вы могли бы использовать метод items():
```python
def items(self):
	itemsval = self.items()
	if itemsval and self._accept(','):
		itemsval.append(self.item())
	else:
		itemsval = [ self.item() ]
```

Единственная проблема в том, что это не работает. Такой код вылетит с ошибкой бесконечной рекурсии. 

Вы можете также столкнуться с хитрыми проблемами, касающимися самих грамматических правил. Например, вы можете поразмышлять над тем, могут ли выражения быть описаны вот такой более простой грамматикой:

	expr ::= factor { ('+'|'-'|'*'|'/') factor }*

	factor ::= '(' expression ')'
	| NUM

Эта грамматика технически «работает», но она не соблюдает стандартные правила порядка вычисления арифметических выражений. Например, для выражения “3 + 4 * 5” оно выдаст результат 35 вместо правильного 23. Чтобы решить эту проблему, нужно использовать отдельные правила expr и term.

Для по-настоящему сложных грамматик лучше использовать инструменты парсинга типа [PyParsing](http://pyparsing.wikispaces.com/) или [PLY](http://www.dabeaz.com/ply/index.html). Вот как выглядит код «вычислителя» выражений, созданный с применением PLY:
```python
from ply.lex import lex
from ply.yacc import yacc

# Token list
tokens = [ 'NUM', 'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'LPAREN', 'RPAREN' ]

# Ignored characters
t_ignore = ' \t\n'

# Token specifications (as regexs)
t_PLUS  = r'\+'
t_MINUS  = r'-'
t_TIMES  = r'\*'
t_DIVIDE = r'/'
t_LPAREN = r'\('
t_RPAREN = r'\)'

# Token processing functions
def t_NUM(t):
	r'\d+'
	t.value = int(t.value)
	return t

# Error handler
def t_error(t):
	print('Bad character: {!r}'.format(t.value[0]))
	t.skip(1)

# Build the lexer
lexer = lex()

# Grammar rules and handler functions
def p_expr(p):
	'''
	expr : expr PLUS term
	| expr MINUS term
	'''
	if p[2] == '+':
		p[0] = p[1] + p[3]
	elif p[2] == '-':
		p[0] = p[1] - p[3]

def p_expr_term(p):
	'''
	expr : term
	'''
	p[0] = p[1]


def p_term(p):
	'''
	term : term TIMES factor
	| term DIVIDE factor
	'''
	if p[2] == '*':
		p[0] = p[1] * p[3]
	elif p[2] == '/':
		p[0] = p[1] / p[3]

def p_term_factor(p):
	'''
	term : factor
	'''
	p[0] = p[1]

def p_factor(p):
	'''
	factor : NUM
	'''
	p[0] = p[1]


def p_factor_group(p):
	'''
	factor : LPAREN expr RPAREN
	'''
	p[0] = p[2]

def p_error(p):
	print('Syntax error')

parser = yacc()
```

В этой программе вы найдете, что всё определено так же, как и ранее написанном парсере, но на намного более высоком уровне. Вы просто пишете регулярные выражения для токенов и высокоуровневые функции-обработчики, которые выполняются, когда возникают совпадения по различным правилам грамматики. А вся механика работы парсера, приёма токенов и так далее полностью реализована в библиотеке. 

Вот пример использования созданного объекта парсера:
```python
>>> parser.parse('2')
2
>>> parser.parse('2+3')
5
>>> parser.parse('2+(3+4)*5')
37
>>>
```

Если вы хотите сделать свою программерскую жизнь более захватывающей, начните писать парсеры и компиляторы. Повторимся, книги про компиляторы предлагают кучу низкоуровневых подробностей и теории. Множество полезных ресурсов и всякой информации вы также найдете в сети. А в Python есть модуль *ast*, на который также стоит посмотреть.

  
## 2.20. Выполнение текстовых операций над байтовыми строками
### Задача
Вы хотите выполнить стандартные текстовые операции (срезание символов, поиск, замену) над строками байтов.

### Решение
Байтовые строки поддерживают большую часть тех же встроенных операций, что и текстовые строки. Например:
```python
>>> data = b'Hello World'
>>> data[0:5]
b'Hello'
>>> data.startswith(b'Hello')
True
>>> data.split()
[b'Hello', b'World']
>>> data.replace(b'Hello', b'Hello Cruel')
b'Hello Cruel World'
>>>
```

Такие операции можно проделать и над байтовыми массивами:
```python
>>> data = bytearray(b'Hello World')
>>> data[0:5]
bytearray(b'Hello')
>>> data.startswith(b'Hello')
True
>>> data.split()
[bytearray(b'Hello'), bytearray(b'World')]
>>> data.replace(b'Hello', b'Hello Cruel')
bytearray(b'Hello Cruel World')
>>>
```

Вы можете просто применить к байтовым строкам поиск совпадений с помощью регулярных выражений, но сами шаблоны должны быть определены как байты. Например:
```python
>>>
>>> data = b'FOO:BAR,SPAM'
>>> import re
>>> re.split('[:,]',data)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "/usr/local/lib/python3.3/re.py", line 191, in split
        return _compile(pattern, flags).split(string, maxsplit)
TypeError: can't use a string pattern on a bytes-like object

>>> re.split(b'[:,]',data)  # Notice: pattern as bytes
[b'FOO', b'BAR', b'SPAM']
>>>
```  

### Обсуждение
Практически все доступные для текстовых строк операции будут работать и на байтовых строках. Однако есть несколько заметных отличий, о которых нужно знать. Во-первых, при индексировании байтовых строк мы получаем целые числа, а не символы. Например:
```python
>>> a = 'Hello World'  # Text string
>>> a[0]
'H'
>>> a[1]
'e'
>>> b = b'Hello World'  # Byte string
>>> b[0]
72
>>> b[1]
101
>>>
``` 

Эта разница в семантике может воздействовать на программы, которые пытаются обработать байтовые данные так же, как и текстовые.

Во-вторых, байтовые строки не предоставляют красивые строковые представления и не выводятся в симпатичном виде, если сначала не проведено декодирование в текстовую строку. Например:
```python
>>> s = b'Hello World'
>>> print(s)
b'Hello World' # Observe b'...'
>>> print(s.decode('ascii'))
Hello World
>>>
```

Строковые операции форматирования также недоступны для байтовых строк.
```python
>>> b'%10s %10d %10.2f' % (b'ACME', 100, 490.1)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for %: 'bytes' and 'tuple'

>>> b'{} {} {}'.format(b'ACME', 100, 490.1)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
AttributeError: 'bytes' object has no attribute 'format'
>>>
```

Если вы хотите применить какое-то форматирование к байтовой строке, это должно быть проделано с помощью обычных текстовых строк и последующего кодирования. Например:
```python
>>> '{:10s} {:10d} {:10.2f}'.format('ACME', 100, 490.1).encode('ascii')
b'ACME 100 490.10'
>>>
```

И, наконец, вы должны знать, что использование байтовых строк может изменить семантику некоторых операций — особенно тех, что относятся к файловой системе. Например, если вы предоставляете имя файла закодированным в байтовую строку, а не в текстовую, это обычно отключает кодирование и декодирование имени файла. Например:
```python
>>> # Write a UTF-8 filename
>>> with open('jalape\xf1o.txt', 'w') as f:
...   f.write('spicy')
...

>>> # Get a directory listing
>>> import os
>>> os.listdir('.')  # Text string (names are decoded)
['jalapeño.txt']

>>> os.listdir(b'.')  # Byte string (names left as bytes)
[b'jalapen\xcc\x83o.txt']
>>>
```

Посмотрите, как в последней части этого примера передача имени каталога в виде байтовой строки вызывает возврат имен файлов в виде недекодированных байтов. Имя файла, показанное в списке содержимого каталога, содержит «сырую» кодировку UTF-8. См. **рецепт 5.15.**, в нем обсуждается вопрос работы с именами файлов, имеющий отношение к этому случаю.

Некоторые программисты могут склоняться к использованию байтовых строк в качестве альтернативы текстовым из-за возможного выигрыша в производительности. Да, операции над байтами могут быть немного более эффективными, чем работа с текстом (из-за оверхеда на Unicode), однако такой подход приводит к грязному и неидиоматическому году. Вы будете часто сталкиваться с тем, что байтовые строки не очень хорошо сочетаются с другими частями Python, и вы закончите тем, что будете вручную выполнять всевозможные операции кодирования-декодирования, чтобы всё работало. Так что если вы работаете с текстом, используйте обычные текстовые строки, а не байтовые.


# 3. Числа, даты и время
В Python легко выполненять математические вычисления с целыми числами и числами с плавающей точкой. Однако если вам нужно работать с дробями, массивами или датами и временем, придется приложить больше усилий. Эта глава фокусируется как раз на таких темах.

## 3.1. Округление числовых значений
### Задача
Вы хотите округлить число с плавающей точкой до заданного количества знаков после точки.

### Решение
Для простого округления используйте встроенную функцию *round(value, ndigits)*. Например:
```python
>>> round(1.23, 1)
1.2
>>> round(1.27, 1)
1.3
>>> round(-1.27, 1)
-1.3
>>> round(1.25361,3)
1.254
>>>
``` 

Когда значение попадает точно между двух возможных выборов для округления, эта функция будет округлять к ближайшему чётному значению. То есть 1.5 или 2.5 будут округлены до 2.

Количество знаков, которое передается функции *round()*, может быть отрицательным. В этом случае округление будет идти до десятков, сотен, тысяч и т.д. Например:
```python
>>> a = 1627731
>>> round(a, -1)
1627730
>>> round(a, -2)
1627700
>>> round(a, -3)
1628000
>>>
```

### Обсуждение
Не перепутайте округление с форматированием значения для вывода. Если вы хотите просто вывести число с некоторым определенным количеством знаков после точки, обычно вам не требуется *round()*. Вместо этого просто задайте при форматировании, скоро знаков выводить. Пример:
```python
>>> x = 1.23456
>>> format(x, '0.2f')
'1.23'
>>> format(x, '0.3f')
'1.235'
>>> 'value is {:0.3f}'.format(x)
'value is 1.235'
>>>
```

Сопротивляйтесь желанию округлить числа с плавающей точкой, чтобы исправить проблемы с точностью вычислений. Например, вы можете склоняться поступить так:
```python
>>> a = 2.1
>>> b = 4.2
>>> c = a + b
>>> c
6.300000000000001
>>> c = round(c, 2)  # "Fix" result (???)
>>> c
6.3
>>>
```

Для большинства программ, работающих с числами с плавающей точкой, просто не нужно (и не рекомендуется) этого делать. Хотя есть незначительные ошибки в вычислениях, поведение этих ошибок понятно и терпимо. Если необходимо избежать таких ошибок (например, это может быть важно для финансовых приложений), попробуйте модуль *decimal*, который обсуждается в следующем рецепте.

## 3.2. Выполнение точных десятичных вычислений   
### Задача
Вам нужно выполнить точные вычисления с десятичными числами, и вы хотите избавиться от небольших ошибок, которые обычно возникают при работе с числами с плавающей точкой.

### Решение
Широко известный недостаток чисел с плавающей точкой в том, что они не могут точно представить все 10 базовых десятичных цифр. Более того, даже простые математические вычисления приводят к появлению небольших ошибок. Например:
```python
>>> a = 4.2
>>> b = 2.1
>>> a + b
6.300000000000001
>>> (a + b) == 6.3
False
>>>
```  

Эти ошибки — не «бага, а фича» процессора и стандарта представления чисел с плавающей точкой IEEE 754, на основе которого работает модуль процессора для выполнения вычислений с плавающей точкой. Поскольку тип данных «числа с плавающей точкой» Python хранит данные, используя нативное представление, вы ничего не можете сделать, чтобы избавиться от ошибок при использовании экземпляров *float*. 

Если вам нужна большая точность (и вы готовы в некоторой степени поступиться производительностью), вы можете использовать модуль *decimal*:
```python
>>> from decimal import Decimal
>>> a = Decimal('4.2')
>>> b = Decimal('2.1')
>>> a + b
Decimal('6.3')
>>> print(a + b)
6.3
>>> (a + b) == Decimal('6.3')
True
>>>
```

На первый взгляд он может показаться странным (например, определение чисел как строк). Однако объекты *Decimal* работают именно так, как вы можете ожидать (поддерживают все обычные математические операции и т.д.) Если вы выводите их или используете функциях форматирования строк, они выглядят как обычные числа.

Главное преимущество *decimal* в том, что он позволяет контролировать различные аспекты вычислений, такие как число знаков после точки и округление. Чтобы это сделать, вы создаете локальный контекст и меняете его установки. Например:
```python
>>> from decimal import localcontext
>>> a = Decimal('1.3')
>>> b = Decimal('1.7')
>>> print(a / b)
0.7647058823529411764705882353
>>> with localcontext() as ctx:
...   ctx.prec = 3
...   print(a / b)
...
0.765
>>> with localcontext() as ctx:
...   ctx.prec = 50
...   print(a / b)
...
0.76470588235294117647058823529411764705882352941176
>>>
```

### Обсуждение
Модуль *decimal* реализует «Общую спецификацию десятичной арифметики» компании IBM (“General Decimal Arithmetic Specification”). Нет нужды упоминать, что у него есть очень много различных опций для конфигурирования, описание которых лежит за пределами возможностей этой книги.

Новички в Python могут склоняться к повсеместному использованию модуля *decimal* для решения проблемы неточности, которая неизбежна при работе с типом данных *float*. Однако важно понимать область применения вашего приложения. Если вы работаете с научными или инженерными данными, компьютерной графикой, то вполне нормально использовать обычный тип данных чисел с плавающей точкой. В общем-то очень немногие вещи в реальном мире измеряются с точностью до 17-го знака после точки, которую предоставляет *float*. Так что небольшие ошибки не так уж важны. А производительность нативных чисел с плавающей точкой заметно выше, а это важно при выполнении большого количества вычислений.

Но вы не должны просто полностью игнорировать ошибки. Математики проводят немало времени, изучая различные алгоритмы, и некоторые обрабатывают ошибки лучше других. Вы также должны быть осторожными с эффектами таких штук как вычитательная потеря точности и сложение больших и маленьких чисел. Например:
```python
>>> nums = [1.23e+18, 1, -1.23e+18]
>>> sum(nums)  # Notice how 1 disappears
0.0
>>>
```

Ошибка из последнего примера может быть решена путем использования *math.fsum()*:
```python
>>> import math
>>> math.fsum(nums)
1.0
>>>
``` 

Однако для других алгоритмов вам придется изучить реализацию и понять, как он работает с точки зрения подобных ошибок. 

Подведем итог: модуль *decimal* используется в основном в финансовых и им подобных приложениях. В таких программах небольшие ошибки в вычислениях ужасно мешают, а *decimal* позволяет от них избавиться. Также часто можно встретить объекты класса *Decimal* в интерфейсах Python к базам данных — опять же, особенно часто их используют для доступа к финансовым данным.

## 3.3. Форматирование чисел для вывода
### Задача
Вам нужно отформатировать число для вывода, контролируя количество знаков, выравнивание, включение разделителя для разрядов и т.д.

### Решение
Чтобы отформатировать одно число для вывода, используйте встроенную функцию *format()*. Например:
```python
>>> x = 1234.56789

>>> # Two decimal places of accuracy
>>> format(x, '0.2f')
'1234.57'

>>> # Right justified in 10 chars, one-digit accuracy
>>> format(x, '>10.1f')
' 1234.6'

>>> # Left justified
>>> format(x, '<10.1f')
'1234.6 '

>>> # Centered
>>> format(x, '^10.1f')
' 1234.6 '

>>> # Inclusion of thousands separator
>>> format(x, ',')
'1,234.56789'
>>> format(x, '0,.1f')
'1,234.6'
>>>
```

Если вы хотите использовать экспоненциальную нотацию, измените f на e или E (в зависимости от регистра, который вы хотите использовать для обозначения экспоненты). Например:
```python
>>> format(x, 'e')
'1.234568e+03'
>>> format(x, '0.2E')
'1.23E+03'
>>>
```

Общая форма ширины и точности в обоих случаях такова: '[<>^]?width[,]?(.digits)?', где width и digits — целые числа, а ? обозначает необязательные части. Тот же формат используется в строковом методе *format()*. Например:
```python
>>> 'The value is {:0,.2f}'.format(x)
'The value is 1,234.57'
>>>
``` 

### Обсуждение
Форматирование чисел для вывода обычно является прямолинейным. Приём, показанный выше, работает и для чисел с плавающей точкой, и для экземпляров *Decimal* из модуля *decimal*. 

Когда количество знаков ограничено, значения округляются таким же образом, как и при использовании функции *round()*. Например:
```python
>>> x
1234.56789
>>> format(x, '0.1f')
'1234.6'
>>> format(-x, '0.1f')
'-1234.6'
>>>
``` 

Обычное форматирование значений с добавлением разделителя разрядов ничего не знает о принятых в конкретных странах традициях форматирования тысячных разрядов. Если вам нужно принять во внимание эти традиции, обратите внимание на функции модуля *locale*. Вы также можете заменить символ разделителя разрядов, используя строковый метод translate(). Например:
```python
>>> swap_separators = { ord('.'):',', ord(','):'.' }
>>> format(x, ',').translate(swap_separators)
'1.234,56789'
>>>
``` 

В мире всё ещё очень много кода, использующего форматирование чисел на основе оператора %. Например:
```python
>>> '%0.2f' % x
'1234.57'
>>> '%10.1f' % x
' 1234.6'
>>> '%-10.1f' % x
'1234.6 '
>>>
```

Это форматирование всё еще приемлемо, но обладает меньшими возможностями, нежели современный метод *format()*. Например, форматирование с помощью оператора % не поддерживает добавление разделителя разрядов.


## 3.4. Работа с бинарными, восьмеричными и шестнадцатеричными целыми числами
### Задача
Вам нужно преобразовать выводимые целые числа в бинарное, восьмеричное или шестнадцатеричное представление.

### Решение
Чтобы преобразовать целое число в бинарное, восьмеричное или шестнадцатеричное представление, используйте функции *bin()*, *oct()* или *hex()* соответственно:
```python
>>> x = 1234
>>> bin(x)
'0b10011010010'
>>> oct(x)
'0o2322'
>>> hex(x)
'0x4d2'
>>>
```

Или же вы можете использовать функцию *format()*, если не хотите, чтобы появлялись префиксы 0b, 0o или 0x. Например:
```python
>>> format(x, 'b')
'10011010010'
>>> format(x, 'o')
'2322'
>>> format(x, 'x')
'4d2'
>>>
```

Целые числа имеют знак, поэтому если вы работаете с отрицательными значениями, то вывод тоже будет включать знак. Например:
```python
>>> x = -1234
>>> format(x, 'b')
'-10011010010'
>>> format(x, 'x')
'-4d2'
>>>
``` 

Если вы хотите вывести значение без знака, вам нужно добавить максимальное значение, чтобы установить длину бита. Например, чтобы вывести 32-битное значение, можно поступить так:
```python
>>> x = -1234
>>> format(2**32 + x, 'b')
'11111111111111111111101100101110'
>>> format(2**32 + x, 'x')
'fffffb2e'
>>>
```

Чтобы преобразовать строки с целыми числами в числа с разными основаниями, используйте функцию *int()*, указав нужное основание. Например:
```python
>>> int('4d2', 16)
1234
>>> int('10011010010', 2)
1234
>>>
```

### Обсуждение
По большей части работа с бинарными, восьмеричными и шестнадцатеричными целыми числами прямолинейна. Просто запомните, что эти преобразования относятся только выводу разных текстовых представлений чисел. «Под капотом» это один и тот же тип целых чисел.

Предупреждение для программистов, работающих с восьмеричными числами: синтаксис Python для определения восьмеричных значений немного отличается от реализованного в большинстве других языков. Если вы попробуете сделать это так, то получите синтаксическую ошибку:
```python
>>> import os
>>> os.chmod('script.py', 0755)
    File "<stdin>", line 1
        os.chmod('script.py', 0755)
                               ^
SyntaxError: invalid token
>>
```   

Убедитесь, что вы вводите восьмеричное значение с префиксом 0o, как показано тут:
```python
>>> os.chmod('script.py', 0o755)
>>>
```

## 3.5. Упаковка и распаковка больших целых чисел из байтовых строк
### Задача
У вас есть строка байтов, и вам нужно распаковать ее в целочисленное значение. Или же вам нужно конвертировать большое целое число в байтовую строку.

### Решение
Предположим, ваша программа должна работать с 16-тиэлементной байтовой строкой, которая содержит 128-битное целочисленное значение. Например:
```python
data = b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
```

Чтобы перевести байты в целое число, используйте *int.from_bytes()*, определив порядок следования байтов таким образом:
```python
>>> len(data)
16
>>> int.from_bytes(data, 'little')
69120565665751139577663547927094891008
>>> int.from_bytes(data, 'big')
94522842520747284487117727783387188
>>>
```

Чтобы преобразовать большое целочисленное значение обратно в байтовую строку, используйте метод *int.to_bytes()*, определив количество байтов и порядок их следования. Например:
```python
>>> x = 94522842520747284487117727783387188
>>> x.to_bytes(16, 'big')
b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
>>> x.to_bytes(16, 'little')
b'4\x00#\x00\x01\xef\xcd\x00\xab\x90x\x00V4\x12\x00'
>>>
``` 

### Обсуждение
Преобразование больших целочисленных значений из и в байтовые строки — не самая обычная операция. Однако иногда такая задача возникает в некоторых областях, каких как криптография или работа с сетью. Например, сетевые адреса IPv6 представлены 128-битными целыми числами. Если вы пишете программу, в которой нужно вытягивать такие значения из данных, вы можете столкнуться с этой задачей. 

В качестве альтернативы вы можете попытаться распаковывать значения, используя модуль *struct*, как описано в **рецепте 6.11.** Это работает, но размер целых чисел, которые могут быть распакованы с помощью *struct*, ограничен. Поэтому вам понадобится распаковывать несколько значений и объединять их для создания итогового значения. Например:
```python
>>> data
b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
>>> import struct
>>> hi, lo = struct.unpack('>QQ', data)
>>> (hi << 64) + lo
94522842520747284487117727783387188
>>>
```

Определение порядка следования байтов (*little* или *big*), просто указывает, записаны ли байты, из которых составляется целое число, в порядке от старшего к младшему или наоборот. Это легко понять, рассмотрев пример такого специально составленного шестнадцатеричного значения:
```python
>>> x = 0x01020304
>>> x.to_bytes(4, 'big')
b'\x01\x02\x03\x04'
>>> x.to_bytes(4, 'little')
b'\x04\x03\x02\x01'
>>>
```    

Если вы хотите упаковать целое число в строку байтов, но оно не поместится, вы получите ошибку. При необходимости вы можете использовать метод *int.bit_length()*, чтобы определить, сколько байтов потребуется для хранения значения:
```python
>>> x = 523 ** 23
>>> x
335381300113661875107536852714019056160355655333978849017944067
>>> x.to_bytes(16, 'little')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
OverflowError: int too big to convert
>>> x.bit_length()
208
>>> nbytes, rem = divmod(x.bit_length(), 8)
>>> if rem:
...   nbytes += 1
...
>>>
>>> x.to_bytes(nbytes, 'little')
b'\x03X\xf1\x82iT\x96\xac\xc7c\x16\xf3\xb9\xcf...\xd0'
>>>
```

## 3.6. Вычисления с комплексными числами
### Задача
Возможно, ваша программа для взаимодействия с веб-сервисом для аутентификации последнего поколения столкнулась с сингулярностью, и ваш единственный способ обойти это лежит через комплексную плоскость... Или же вам просто нужно выполнить какие-то вычисления с использованием комплексных чисел.

### Решение
Комплексные числа могут быть определены с использованием функции *complex(real, imag)* или добавлением окончания j к числу с плавающей точкой. Например:
```python
>>> a = complex(2, 4)
>>> b = 3 - 5j
>>> a
(2+4j)
>>> b
(3-5j)
>>>
``` 

Реальное, мнимое и объединенное значения можно легко получить:
```python
>>> a.real
2.0
>>> a.imag
4.0
>>> a.conjugate()
(2-4j)
>>>
```

Работают все обычные математические операторы:
```python
>>> a + b
(5-1j)
>>> a * b
(26+2j)
>>> a / b
(-0.4117647058823529+0.6470588235294118j)
>>> abs(a)
4.47213595499958
>>>
```

Для специальных операций с комплексными числами, таких как синусы, косинусы или квадратные корни, используйте модуль *cmath*:
```python
>>> import cmath
>>> cmath.sin(a)
(24.83130584894638-11.356612711218174j)
>>> cmath.cos(a)
(-11.36423470640106-24.814651485634187j)
>>> cmath.exp(a)
(-4.829809383269385-5.5920560936409816j)
>>>
```   

### Обсуждение
Большинство связанных с математикой модулей Python умеют работать с комплексными числами. Например, если вы используете numpy, то сможете применить прямолинейный подход к созданию массивов комплексных чисел и операций над ними:
```python
>>> import numpy as np
>>> a = np.array([2+3j, 4+5j, 6-7j, 8+9j])
>>> a
array([ 2.+3.j, 4.+5.j, 6.-7.j, 8.+9.j])
>>> a + 2
array([ 4.+3.j, 6.+5.j, 8.-7.j, 10.+9.j])
>>> np.sin(a)
array([ 9.15449915 -4.16890696j, -56.16227422 -48.50245524j,
-153.20827755-526.47684926j, 4008.42651446-589.49948373j])
>>>
```

Стандартные математические функции, включенные в Python, не производят комплексные значения по умолчанию, так что они вряд ли случайно возникнут в вашем коде. Например:
```python
>>> import math
>>> math.sqrt(-1)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
ValueError: math domain error
>>>
```

Если вы хотите получать в результате вычислений комплексные числа, вы должны явно использовать cmath или соответствующим образом объявить это библиотекам, которые умеют с ними работать. Например:
```python
>>> import cmath
>>> cmath.sqrt(-1)
1j
>>>
```

## 3.7. Работа с бесконечными значениями и NaN
### Задача
Вам нужно создать создать или протестировать такие значения с плавающей точкой: бесконечность, минус бесконечность, NaN (not a number, «не число»).

### Решение
В Python нет специального синтаксиса для представления таких специальных значений с плавающей точкой, но они могут быть созданы с помощью *float()*. Например:
```python
>>> a = float('inf')
>>> b = float('-inf')
>>> c = float('nan')
>>> a
inf
>>> b
-inf
>>> c
nan
>>>
```

Чтобы проверить, не является ли значение таким, используйте функции *math.isinf()* и *math.isnan()*. Например:
```python
>>> math.isinf(a)
True
>>> math.isnan(c)
True
>>>
```

### Обсуждение
За подробностями об этих специальных значениях с плавающей точкой вы можете обратиться к спецификации IEEE 754. Однако здесь есть несколько хитрых деталей, о которых нужно знать, особенно связанные со сравнениями и операторами.

Бесконечные значения распространяются в вычислениях согласно математическим правилам. Например:
```python
>>> a = float('inf')
>>> a + 45
inf
>>> a * 10
inf
>>> 10 / a
0.0
>>>
```

Однако некоторые операции неопределены и выдают NaN. Например:
```python
>>> a = float('inf')
>>> a/a
nan
>>> b = float('-inf')
>>> a + b
nan
>>>
```

Значения NaN распространяются через все операции, не возбуждая исключений. Например:
```python
>>> c = float('nan')
>>> c + 23
nan
>>> c / 2
nan
>>> c * 2
nan
>>> math.sqrt(c)
nan
>>>
```

Тонкость с NaN заключается в том, что они никогда будут равны друг другу. Например:
```python
>>> c = float('nan')
>>> d = float('nan')
>>> c == d
False
>>> c is d
False
>>>
```

По причине этого единственный безопасный способ проверить значение на NaN — это использовать *math.isnan()*, как показано в этом рецепте.

Иногда программисты хотят изменить поведение Python таким образом, чтобы при возникновении в ходе вычислений бесконечностей или NaN возбуждались исключения. Для такого изменения поведения может быть использован модуль *fpectl*, но он не включен в стандартную поставку Python, является платформозависимым и на самом деле предназначен только программистов-экспертов. За деталями обратитесь к [онлайн-документации Python](https://docs.python.org/3/library/fpectl.html).

## 3.8. Вычисления с дробями
### Задача
Вы вошли в машину времени и внезапно обнаружили себя делающим домашку по математике с задачками про дроби. Или же вы просто пишете код, который будет обсчитывать измерения, сделанные в вашей столярной мастерской...

### Решение
Модуль *fractions* может быть использован для выполнения математических операций с дробями. Например:
```python
>>> from fractions import Fraction
>>> a = Fraction(5, 4)
>>> b = Fraction(7, 16)
>>> print(a + b)
27/16
>>> print(a * b)
35/64

>>> # Getting numerator/denominator
>>> c = a * b
>>> c.numerator
35
>>> c.denominator
64

>>> # Converting to a float
>>> float(c)
0.546875
>>> # Limiting the denominator of a value
>>> print(c.limit_denominator(8))
4/7

>>> # Converting a float to a fraction
>>> x = 3.75
>>> y = Fraction(*x.as_integer_ratio())
>>> y
Fraction(15, 4)
>>>
```

### Обсуждение
Вычисления с дробями нечасто возникают в обычных программах, но иногда имеет смысл ими воспользоваться. Например, если данные каких-то измерений поступают в виде дробей, то можно работать прямо с ними, что снимает необходимость конвертирования в десятичные дроби или числа с плавающей точкой.


## 3.9. Вычисления на больших массивах чисел
### Задача
Вам нужно произвести вычисления на больших объемах числовых данных, таких как массивы или решетки.

### Решение
Для любых объемных вычислений с использованием массивов используйте библиотеку [NumPy](http://www.numpy.org/). Ее главное преимущество в том, что она предоставляет Python объект массива, который намного эффективнее и лучше подходит для математических вычислений, нежели стандартный список Python. Вот короткий пример, иллюстрирующий важные различия между обычными списками и массивами NumPy:
```python
>>> # Python lists
>>> x = [1, 2, 3, 4]
>>> y = [5, 6, 7, 8]
>>> x * 2
[1, 2, 3, 4, 1, 2, 3, 4]
>>> x + 10
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
>>> x + y
[1, 2, 3, 4, 5, 6, 7, 8]

>>> # Numpy arrays
>>> import numpy as np
>>> ax = np.array([1, 2, 3, 4])
>>> ay = np.array([5, 6, 7, 8])
>>> ax * 2
array([2, 4, 6, 8])
>>> ax + 10
array([11, 12, 13, 14])
>>> ax + ay
array([ 6, 8, 10, 12])
>>> ax * ay
array([ 5, 12, 21, 32])
>>>
``` 

Как вы можете увидеть, базовые математические операции с использованием массивов выполняются по-разному. Конкретно скалярные операции (например, ax * 2 или ax + 10) применяют операцию элемент за элементом. Также отметим, что выполнение таких математических операций, где каждый из операндов является массивом, применяет операцию ко всем элементам и создает новый массив.

Тот факт, что математические операции применяются одновременно ко всем элементам, позволяет очень просто и быстро применить функции к всему массиву. Например, если вы хотите вычислить значение многочлена:
```python
>>> def f(x):
...   return 3*x**2 - 2*x + 7
...
>>> f(ax)
array([ 8, 15, 28, 47])
>>>
``` 

NumPy предоставляет набор «универсальных функций», которые также работают для операций над массивами. Они подменяют похожие функции, доступные в модуле *math*. Например:
```python
>>> np.sqrt(ax)
array([ 1. , 1.41421356, 1.73205081, 2. ])
>>> np.cos(ax)
array([ 0.54030231, -0.41614684, -0.9899925 , -0.65364362])
>>>
``` 

Использование универсальных функций позволяет выполнить вычисление в сотни раз быстрее, чем проход по массиву и применение функций из *math* к каждому элементу. Так что используйте их при любой возможности.

«Под капотом» массивы NumPy устроены похоже на массивы C или Fortran. А именно они представляют собой большие смежные области памяти, состоящие из однородных типов данных. Это позволяет делать массивы намного большими, чем позволяет обычный список Python. Например, если вы хотите создать двумерную решетку размером 10 000 на 10 000 чисел с плавающей точкой, это не проблема:
```python
>>> grid = np.zeros(shape=(10000,10000), dtype=float)
>>> grid
array([[ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       ...,
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.],
       [ 0., 0., 0., ..., 0., 0., 0.]])
>>>
```

Все обычные операции все еще применяются к элементам одновременно:
```python
>>> grid += 10
>>> grid
array([[ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       ...,
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.],
       [ 10., 10., 10., ..., 10., 10., 10.]])
>>> np.sin(grid)
array([[-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       ...,
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111],
       [-0.54402111, -0.54402111, -0.54402111, ..., -0.54402111,
        -0.54402111, -0.54402111]])
>>>
```

Важнейший момент в использовании NumPy — это способ, которым она расширяет функциональность индексирования списков Python (особенно для многомерных массивов). Чтобы проиллюстрировать это, создадим простой двумерный массив и поэкспериментируем:
```python
>>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
>>> a
array([[ 1, 2, 3, 4],
       [ 5, 6, 7, 8],
       [ 9, 10, 11, 12]])

>>> # Select row 1
>>> a[1]
array([5, 6, 7, 8])

>>> # Select column 1
>>> a[:,1]
array([ 2, 6, 10])

>>> # Select a subregion and change it
>>> a[1:3, 1:3]
array([[ 6, 7],
       [10, 11]])
>>> a[1:3, 1:3] += 10
>>> a
array([[ 1, 2, 3, 4],
       [ 5, 16, 17, 8],
       [ 9, 20, 21, 12]])

>>> # Broadcast a row vector across an operation on all rows
>>> a + [100, 101, 102, 103]
array([[101, 103, 105, 107],
       [105, 117, 119, 111],
       [109, 121, 123, 115]])
>>> a
array([[ 1, 2, 3, 4],
       [ 5, 16, 17, 8],
       [ 9, 20, 21, 12]])

>>> # Conditional assignment on an array
>>> np.where(a < 10, a, 10)
array([[ 1, 2, 3, 4],
       [ 5, 10, 10, 8],
       [ 9, 10, 10, 10]])
>>>
``` 

### Обсуждение
NumPy — это основа огромного количества научных и инженерных библиотек для Python. Это также один из крупнейших и самых сложных модулей (из тех, что широко используются). При этом можно делать полезные вещи с помощью NumPy, начинав экспериментировать с простыми примерами.

Стоит отметить, что часто используется конструкция *import numpy as np*, как и показано в нашем примере. Это сокращает название, чтобы было удобно вводить его снова и снова в вашей программе. 

Прочую информацию вы найдёте на [http://www.numpy.org](http://www.numpy.org).


## 3.10. Вычисления с матрицами и линейная алгебра  
### Задача
Вам нужно произвести матричные операции и операции линейной алгебры, такие как умножение матриц, поиск определителей, решение линейных уравнений и т.д.

### Решение
Библиотека [NumPy](http://www.numpy.org) содержит объект *matrix*. Матрицы — это нечто похожее на объекты массивов, описанные в **рецепте 3.9.**, но в вычисления над ними следуют законам линейной алгебры. Вот несколько примеров их основных возможностей:
```python
>>> import numpy as np
>>> m = np.matrix([[1,-2,3],[0,4,5],[7,8,-9]])
>>> m
matrix([[ 1, -2, 3],
        [ 0, 4, 5],
        [ 7, 8, -9]])

>>> # Return transpose
>>> m.T
matrix([[ 1, 0, 7],
        [-2, 4, 8],
        [ 3, 5, -9]])

>>> # Return inverse
>>> m.I
matrix([[ 0.33043478, -0.02608696, 0.09565217],
        [-0.15217391, 0.13043478, 0.02173913],
        [ 0.12173913, 0.09565217, -0.0173913 ]])

>>> # Create a vector and multiply
>>> v = np.matrix([[2],[3],[4]])
>>> v
matrix([[2],
        [3],
        [4]])
>>> m * v
matrix([[ 8],
        [32],
        [ 2]])
>>>
```

Другие операции можно найти в субпакете *numpy.linalg*. Например:
```python
>>> import numpy.linalg

>>> # Determinant
>>> numpy.linalg.det(m)
-229.99999999999983

>>> # Eigenvalues
>>> numpy.linalg.eigvals(m)
array([-13.11474312, 2.75956154, 6.35518158])

>>> # Solve for x in mx = v
>>> x = numpy.linalg.solve(m, v)
>>> x
matrix([[ 0.96521739],
        [ 0.17391304],
        [ 0.46086957]])
>>> m * x
matrix([[ 2.],
        [ 3.],
        [ 4.]])
>>> v
matrix([[2],
        [3],
        [4]])
>>>
```

### Обсуждение
Линейная алгебра, очевидно, является слишком обширной темой, чтобы обсуждать ее в этом сборнике рецептов. Однако если вам нужно работать с матрицами и векторами, начните именно с NumPy. За информацией о библиотеке обращайтесь на [http://www.numpy.org](http://www.numpy.org).


## 3.11. Случайный выбор
### Задача
Вы хотите выбрать случайные элементы из последовательности или сгенерировать случайные числа.

### Решение
Модуль random содержит разнообразные функции для генерации случайных чисел и выбора случайных элементов. Например, чтобы выбрать случайный элемент последовательности используйте *random.choice()*:
```python
>>> import random
>>> values = [1, 2, 3, 4, 5, 6]
>>> random.choice(values)
2
>>> random.choice(values)
3
>>> random.choice(values)
1
>>> random.choice(values)
4
>>> random.choice(values)
6
>>>
```

Чтобы получить выборку из N элементов, используйте *random.sample()*. Каждый элемент выбирается один раз, так что если значения в полученной выборке повторяются, то это разные элементы оригинальной последовательности, имеющие одинаковое значение:
```python
>>> random.sample(values, 2)
[6, 2]
>>> random.sample(values, 2)
[4, 3]
>>> random.sample(values, 3)
[4, 3, 1]
>>> random.sample(values, 3)
[5, 4, 1]
>>>
```

Если вы хотите перемешать элементы в последовательности, используйте *random.shuffle()*:
```python
>>> random.shuffle(values)
>>> values
[2, 4, 6, 5, 3, 1]
>>> random.shuffle(values)
>>> values
[3, 5, 2, 1, 6, 4]
>>>
``` 

Чтобы сгенерировать случайные целые числа, используйте *random.randint()*:
```python
>>> random.randint(0,10)
2
>>> random.randint(0,10)
5
>>> random.randint(0,10)
0
>>> random.randint(0,10)
7
>>> random.randint(0,10)
10
>>> random.randint(0,10)
3
>>>
```

Чтобы сгенерировать одинаковые по формату числа с плавающей точкой в диапазоне от 0 до 1, используйте *random.random()*:
```python
>>> random.random()
0.9406677561675867
>>> random.random()
0.133129581343897
>>> random.random()
0.4144991136919316
>>>
```

Чтобы получить целое число из N случайных битов, используйте *random.getrandbits()*:
```python
>>> random.getrandbits(200)
335837000776573622800628485064121869519521710558559406913275
>>>
```  

### Обсуждение
Модуль *random* вычисляет случайные числа, используя алгоритм «вихрь Мерсенна» (Mersenne twister, MT). Это детерминистский алгоритм, но вы можете изменить начальную инциализацию с помощью функции random.seed():
```python
random.seed() # Seed based on system time or os.urandom()
random.seed(12345) # Seed based on integer given
random.seed(b'bytedata') # Seed based on byte data
```

Вдобавок к уже продемонстрированной функциональности, *random* включает функции для равномерного, гауссового и других распределений вероятности. Например, *random.uniform()* вычисляет равномерно распределенные числа, а *random.gauss()* — нормально распределенные. За описанием других поддерживаемых распределений обратитесь к документации.

Функции в *random* не должны быть использованы в криптографических программах. Если вам нужна такая функциональность, обратитесь к функциям из модуля *ssl*. Например, *ssl.RAND_bytes()* может быть использована для генерации криптографически безопасных последовательностей случайных байтов.


## 3.12. Перевод дней в секунды и другие базовые методы конвертации времени
### Задача
Вашей программе требуется производить простые преобразования времени, такие как выражение дней в секундах, часов в минутах и т.д.

### Решение
Чтобы производить конвертирование и арифметические операции над различными единицами времени, используйте модуль *datetime*. Например, чтобы представить интервал времени, создайте экземпляр *timedelta*:
```python
>>> from datetime import timedelta
>>> a = timedelta(days=2, hours=6)
>>> b = timedelta(hours=4.5)
>>> c = a + b
>>> c.days
2
>>> c.seconds
37800
>>> c.seconds / 3600
10.5
>>> c.total_seconds() / 3600
58.5
>>>
```

Если вам нужно представить определенные даты и определенное время, создайте экземпляры *datetime* и проводите над ними обычные арифметические операции. Например:
```python
>>> from datetime import datetime
>>> a = datetime(2012, 9, 23)
>>> print(a + timedelta(days=10))
2012-10-03 00:00:00
>>>
>>> b = datetime(2012, 12, 21)
>>> d = b - a
>>> d.days
89
>>> now = datetime.today()
>>> print(now)
2012-12-21 14:54:43.094063
>>> print(now + timedelta(minutes=10))
2012-12-21 15:04:43.094063
>>>
```

Стоит отметить, что *datetime* знает о существовании високосных годов. Например:
```python
>>> a = datetime(2012, 3, 1)
>>> b = datetime(2012, 2, 28)
>>> a - b
datetime.timedelta(2)
>>> (a - b).days
2
>>> c = datetime(2013, 3, 1)
>>> d = datetime(2013, 2, 28)
>>> (c - d).days
1
>>>
```

### Обсуждение
Для самых базовых операций над датой и временем модуля *datetime* достаточно. Если перед вами стоят более сложные задачи, такие как работа с временными зонами, нечеткими интервалами времени, подсчет дат выходных дней и так далее, посмотрите на модуль [dateutil](https://pypi.python.org/pypi/python-dateutil).

Например, множество похожих вычислений над временем может быть выполнено с помощью функции *dateutil.relativedelta()*. Одна важная возможность заключается в том, что она заполняет разрывы, которые возникают при работе с месяцами (и отличающимся количеством дней в них). Например:
```python
>>> a = datetime(2012, 9, 23)
>>> a + timedelta(months=1)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'months' is an invalid keyword argument for this function
>>>

>>> from dateutil.relativedelta import relativedelta
>>> a + relativedelta(months=+1)
datetime.datetime(2012, 10, 23, 0, 0)
>>> a + relativedelta(months=+4)
datetime.datetime(2013, 1, 23, 0, 0)
>>>

>>> # Time between two dates
>>> b = datetime(2012, 12, 21)
>>> d = b - a
>>> d
datetime.timedelta(89)
>>> d = relativedelta(b, a)
>>> d
relativedelta(months=+2, days=+28)
>>> d.months
2
>>> d.days
28
>>>
```

## 3.13. Определение даты последней пятницы
### Задача
Вы хотите создать общее решение для нахождения даты ближайшего прошедшего дня недели — например, последней прошедшей пятницы.

### Решение
В модуле *datetime* есть полезные функции и классы, которые помогают проводить такого рода вычисления. Хорошее обобщенное решение этой задачи выглядит как-то так:
```python
from datetime import datetime, timedelta

weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
            'Friday', 'Saturday', 'Sunday']

def get_previous_byday(dayname, start_date=None):
    if start_date is None:
        start_date = datetime.today()
    day_num = start_date.weekday()
    day_num_target = weekdays.index(dayname)
    days_ago = (7 + day_num - day_num_target) % 7
    if days_ago == 0:
        days_ago = 7
    target_date = start_date - timedelta(days=days_ago)
    return target_date
```     

Использование этой функции в строке интерпретатора выглядит так:
```python
>>> datetime.today()  # For reference
datetime.datetime(2012, 8, 28, 22, 4, 30, 263076)
>>> get_previous_byday('Monday')
datetime.datetime(2012, 8, 27, 22, 3, 57, 29045)
>>> get_previous_byday('Tuesday') # Previous week, not today
datetime.datetime(2012, 8, 21, 22, 4, 12, 629771)
>>> get_previous_byday('Friday')
datetime.datetime(2012, 8, 24, 22, 5, 9, 911393)
>>>
```

Необязательный параметр *start_date* может быть предоставлен с использованием другого экземпляра *datetime*. Например:
```python
>>> get_previous_byday('Sunday', datetime(2012, 12, 21))
datetime.datetime(2012, 12, 16, 0, 0)
>>>
```

### Обсуждение
Этот рецепт работает путем отображения стартовой и нужной даты на номера их позиций в неделе (где понедельник — это 0). Далее используется модульная арифметика, с её помощью мы вычисляем, сколько дней назад была нужная дата. Далее нужная дата высчитывается от стартовой даты путем вычитания соответствующего экземпляра *timedelta*.

Если вы выполняете много подобных вычислений, рекомендуем установить пакет [python-dateutil](https://pypi.python.org/pypi/python-dateutil). Например, вот так можно выполнить аналогичную работу с использованием функции *relativedata()* из модуля *dateutil*:
```python
>>> from datetime import datetime
>>> from dateutil.relativedelta import relativedelta
>>> from dateutil.rrule import *
>>> d = datetime.now()
>>> print(d)
2012-12-23 16:31:52.718111
>>> # Next Friday
>>> print(d + relativedelta(weekday=FR))
2012-12-28 16:31:52.718111
>>>
>>> # Last Friday
>>> print(d + relativedelta(weekday=FR(-1)))
2012-12-21 16:31:52.718111
>>>
```

## 3.14. Поиск диапазона дат для текущего месяца
### Задача
У вас есть код, которому необходимо пройти в цикле по каждой дате текущего месяца, и вы хотите узнать эффективный способ поиска диапазонов дат.

### Решение
Прохождение в цикле по датам не требует предварительного создания списка всех дат. Вы можете просто вычислить стартовую и конечную дату в диапазоне, а затем использовать объекты *datetime.timedelta*, инкрементируя дату.

Вот функция, которая принимает любой объект *datetime* и возвращает кортеж, содержащий первую дату месяца и начальную дату следующего месяца:
```python
from datetime import datetime, date, timedelta
import calendar

def get_month_range(start_date=None):
	if start_date is None:
	start_date = date.today().replace(day=1)
_, days_in_month = calendar.monthrange(start_date.year, start_date.month)
end_date = start_date + timedelta(days=days_in_month)
return (start_date, end_date)
```

Получив эти данные, очень просто пройти в цикле по диапазону дат:
```python
>>> a_day = timedelta(days=1)
>>> first_day, last_day = get_month_range()
>>> while first_day < last_day:
...  print(first_day)
...  first_day += a_day
...
2012-08-01
2012-08-02
2012-08-03
2012-08-04
2012-08-05
2012-08-06
2012-08-07
2012-08-08
2012-08-09
#... and so on...
```

### Обсуждение
Этот рецепт работает так: сначала вычисляется дата, соответствующая первому дню месяца. Быстрый способ сделать это — использовать метод *replace()* объектов *date* или *datetime*, чтобы присвоить атрибуту *days* значение 1. Приятно, что метод *replace()* создает объект того же типа, к которому он был применен. В данном случае, поскольку на входе у нас был экземпляр *date*, результат тоже является экземпляром *date*. Точно так же мы бы получили экземпляр *datetime*, если бы на входе у нас был экземпляр *datetime*. 

Затем функция *calendar.monthrange()* используется для нахождения количества дней в рассматриваемом месяце. Модуль calendar весьма полезен для получения базовых данных о календарях. Функция *monthrange()* возвращает кортеж, который содержит день недели и количество дней в месяце. 

Когда мы знаем количество дней в месяце, конечная дата вычисляется путём добавления соответствующего *timedelta* к стартовой дате.  Тонкий, но важный аспект этого рецепта — конечная дата не включается в диапазон (на самом деле это первая дата следующего месяца). Это отражает присущее срезам и диапазонам Python поведение, которое также не подразумевает включение последнего элемента.

Чтобы пройти в цикле по диапазону дат, используются стандартные математические операции и операторы сравнения. Например, экземпляр timedelta может быть использован для инкрементирования даты. Оператор < используется для проверки того, не достигнута ли конечная дата.

В идеальном случае стоит создать функцию, которая будет работать как встроенная *range()*, но с датами. К счастью, есть чрезвычайно простой способ сделать это с помощью генератора:
```python
def date_range(start, stop, step):
	while start < stop:
		yield start
		start += step
```

Вот пример её использования:
```python
>>> for d in date_range(datetime(2012, 9, 1), datetime(2012,10,1),
timedelta(hours=6)):
... print(d)
...
2012-09-01 00:00:00
2012-09-01 06:00:00
2012-09-01 12:00:00
2012-09-01 18:00:00
2012-09-02 00:00:00
2012-09-02 06:00:00
...
>>>
```

Повторимся, самое большое преимущество такой реализации в том, что датами и временем можно манипулировать с помощью стандартных математических операторов и операторов сравнения.

## 3.15. Конвертирование строк в даты и время
### Задача
Ваше приложение получает временные данные в строковом формате, но вы хотите конвертировать их в объекты *datetime*, чтобы выполнять над ними нестроковые операции.

### Решение
Стандартный модуль *datetime* обычно легко справляется с этой задачей. Например:
```python
>>> from datetime import datetime
>>> text = '2012-09-20'
>>> y = datetime.strptime(text, '%Y-%m-%d')
>>> z = datetime.now()
>>> diff = z - y
>>> diff
datetime.timedelta(3, 77824, 177393)
>>>
```

### Обсуждение
Метод *datetime.strptime()* поддерживает множество параметров форматирования, такие как %Y для года из четырёх цифр и %m для месяца из двух цифр. Также стоит отметить, что эти параметры-плейсхолдеры работают в обратном направлении, что поможет, если вам нужно вывести объект *datetime* в строке и при этом заставить его красиво выглядеть.

Предположим, например, что у ваша программа генерирует объект *datetime*, но вам нужно создать из него красивую, понятную людям дату, чтобы потом вставить ее в заголовок автоматически создаваемого письма или отчёта:
```python
>>> z
datetime.datetime(2012, 9, 23, 21, 37, 4, 177393)
>>> nice_z = datetime.strftime(z, '%A %B %d, %Y')
>>> nice_z
'Sunday September 23, 2012'
>>>
```

Стоит отметить, что производительность метода *strptime()* часто оказывается намного хуже, чем вы могли бы ожидать, поскольку функция написана на чистом Python и должна работать со всеми установками системной локализации. Если вы парсите множество дат в своей программе и знаете их точный формат, вы можете добиться намного более высокой производительности путём написания собственного решения. Например, если вы знаете, что даты представлены в формате “YYYY-MM-DD”, вы могли бы написать такую функцию:
```python
from datetime import datetime
def parse_ymd(s):
	year_s, mon_s, day_s = s.split('-')
	return datetime(int(year_s), int(mon_s), int(day_s))
``` 

При тестировании эта функции оказалась более чем в семь раз быстрее метода *datetime.strptime()*. Это стоит держать в голове, если вы обрабатываете большие объемы данных с датами.

## 3.16. Манипулирование датами с учётом таймзон
### Задача
У вас назначена телефонная конференция на 21 декабря 2012 года в 9:30 a.m. по чикагскому времени. В какое локальное время ваш друг из индийского города Бангалор должен выйти на связь?

### Решение
Для практических любых задач, связанных с таймзонами, вы можете использовать модуль [pytz](https://pypi.python.org/pypi/pytz). Этот пакет предоставляет базу таймзон Олсона (tz databaze), которая является стандартом де-факто для многих языков программирования и операционных систем.

Большая часть случаев использования *pytz* приходится на приведение к локальному времени дат, созданных с помощью библиотеки *datetime*. Например, вот как вы могли бы представить дату с чикагским местным временем:
```python
>>> from datetime import datetime
>>> from pytz import timezone
>>> d = datetime(2012, 12, 21, 9, 30, 0)
>>> print(d)
2012-12-21 09:30:00
>>>

>>> # Localize the date for Chicago
>>> central = timezone('US/Central')
>>> loc_d = central.localize(d)
>>> print(loc_d)
2012-12-21 09:30:00-06:00
>>>
```

Когда дата локализована (привязана к местному времени), ее можно конвертировать в другие таймзоны. Чтобы найти то же бангалорское время, вы можете сделать так:
```python
>>> # Convert to Bangalore time
>>> bang_d = loc_d.astimezone(timezone('Asia/Kolkata'))
>>> print(bang_d)
2012-12-21 21:00:00+05:30
>>>
``` 

Если вы собираетесь выполнять арифметические операции над локализованными датами, вам нужно знать о переводах времени с летнего на зимнее и прочих подобных деталях. Например, в 2013 году стандартное летнее время США началось 13 марта в 2:00 ночи по местному времени городов (время было переведено на час вперед). Если бы провели стандартную арифметическую операцию над датами, то получили бы неверный результат. Например:
```python
>>> d = datetime(2013, 3, 10, 1, 45)
>>> loc_d = central.localize(d)
>>> print(loc_d)
2013-03-10 01:45:00-06:00
>>> later = loc_d + timedelta(minutes=30)
>>> print(later)
2013-03-10 02:15:00-06:00
# WRONG! WRONG!
>>>
```

Ответ получается неверным, поскольку он не учитывает перевод местного времени на один час. Чтобы исправить это, используйте метод таймзон *normalize()*. Например:
```python
>>> from datetime import timedelta
>>> later = central.normalize(loc_d + timedelta(minutes=30))
>>> print(later)
2013-03-10 03:15:00-05:00
>>>
```

### Обсуждение
Чтобы предотвратить взрыв головы, используйте обычную стратегию работы с локальным временем: преобразование всех дат в UTC и использование уже их для хранения и обработки. Например:
```python
>>> print(loc_d)
2013-03-10 01:45:00-06:00
>>> utc_d = loc_d.astimezone(pytz.utc)
>>> print(utc_d)
2013-03-10 07:45:00+00:00
>>>
```
Если время уже в UTC, вы можете не волноваться по поводу проблем, связанных с переходом на летнее время, а также прочих подобных вещах. Вы свободно можете выполнять арифметические операции с датами. Если же вы хотите вывести дату в локальном времени, просто сконвертируйте в нужную таймзону. Например:
```python
>>> later_utc = utc_d + timedelta(minutes=30)
>>> print(later_utc.astimezone(central))
2013-03-10 03:15:00-05:00
>>>
```

С использованием таймзон есть одна проблема: какие имена таймзон использовать? Например, в этом рецепте мы как-то узнали, что “Asia/Kolkata” — это правильное название таймзоны для Индии. Чтобы узнать название нужной зоны, поищите в словаре *pytz.country_timezones*, указывая в качестве ключа код страны по ISO 3166. Например:
```python
>>> pytz.country_timezones['IN']
['Asia/Kolkata']
>>>
```

*К тому времени, как вы это прочтёте, модуль *pytz* может быть признан устаревшим, а ему на смену придёт улучшенная поддержка таймзон по [PEP 431](http://www.python.org/dev/peps/pep-0431). Однако многие из описанных проблем все равно нужно будет учитывать (вопросы работы с UTC и т.п.)*

# 4. Итераторы и генераторы
Итерации — одна из сильнейших сторон Python. На высшем уровне абстракции вы можете рассматривать интерации как способ обработки элементов последовательности. Однако возможности намного шире: они включают создание собственных объектов-итераторов, применение полезных паттернов итераций из модуля *itertools*, создание функций-генераторов и т.д. Эта глава рассматривает типичные задачи, связанные с итерациями.

## 4.1. Ручное прохождение по итератору
### Задача
Вам нужно обработать элементы итерируемого объекта, но по какой-то причине
вы не хотите использовать цикл.

### Решение
Чтобы вручную пройти по итерируемому объекту, используйте функцию *next()* и напишите код так, чтобы он ловил исключение *StopIteration*. Например, в этом случае мы вручную читаем строки из файла:
```python
with open('/etc/passwd') as f:
	try:
		while True:
		line = next(f)
		print(line, end='')
	except StopIteration:
		pass
``` 

Обычно *StopIteration* используется для передачи сигнала о конце итерирования. Однако если вы используете *next()* вручную, вы вместо этого можете запрограммировать возвращение конечного значения, такого как *None*. Например:
```python
with open('/etc/passwd') as f:
	while True:
	line = next(f, None)
		if line is None:
			break
	print(line, end='')
``` 

### Обсуждение
В большинстве случаев для прохода по итерируемому объекту используется цикл *for*. Однако задачи иногда требуют более точного контроля «подкапотного» механизма итераций. Также это полезно для того, чтобы разобраться, как он работает.

Следующий интерактивный пример иллюстрирует базовые механизмы того, что происходит во время итерирования:
```python
>>> items = [1, 2, 3]
>>> # Get the iterator
# Invokes items.__iter__()
>>> it = iter(items)
>>> # Run the iterator
>>> next(it)
# Invokes it.__next__()
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
StopIteration
>>>
```

Последующие рецепты в этой главе раскрывают подробности о приёмах итерирования, что предполагает знание базового протокола итераторов. Убедитесь, что этот первый рецепт прочно улёгся у вас в памяти.

## 4.2. Делегирование итерации
### Задача
Вы создали нестандартный объект-контейнер, который внутри содержит список, кортеж или какой-то другой итерируемый объект. Вы хотите заставить итерации работать с вашим новым контейнером.

### Решение
В типичном случае вам нужно определить метод __iter()__, который делегирует итерацию внутреннему содержимому контейнера. Например:
```python
class Node:
	def __init__(self, value):
		self._value = value
		self._children = []

	def __repr__(self):
		return 'Node({!r})'.format(self._value)

	def add_child(self, node):
		self._children.append(node)

def __iter__(self):
		return iter(self._children)

# Example
if __name__ == '__main__':
	root = Node(0)
	child1 = Node(1)
	child2 = Node(2)
	root.add_child(child1)
	root.add_child(child2)
	for ch in root:
	print(ch)
	# Outputs Node(1), Node(2)
```

В этой программе метод *__iter()__* просто перенаправляет запрос на итерацию содержащемус внутри атрибуту *_children*. 

### Обсуждение
Протокол итераций Python требует, чтобы *__iter()__* возвращал специальный объект-итератор, в котором реализован метод *__next()__*, который и выполняет итерацию. Если вы просто итерируете по содержимому другого контейнера, вам не стоит беспокоиться о деталях внутреннего механизма процесса. Вам нужно просто передать запрос на итерацию.

Использование функции *iter()* здесь позволяет «срезать путь» и написать более чистый код. *iter(s)* просто возвращает внутренний итератор, вызывая *s.__iter__()* — примерно так же, как *len(s)* вызывает *s.__len__()*.


## 4.3. Создание новых итерационных паттернов с помощью генераторов
### Задача
Вы хотите реализовать собственный паттерн итераций, который будет отличаться от обычных встроенных функций (таких как *range()*, *reversed()* и т.п.)

### Решение
Если вы хотите реализовать новый тип итерационного паттерна, определите его с помощью генератора. Вот, например, генератор, который создает диапазон чисел с плавающей точкой:
```python
def frange(start, stop, increment):
	x = start
	while x < stop:
		yield x
		x += increment
```

Чтобы использовать такую функцию, вы должны проитерировать по ней в цикле или применить ее с какой-то другой функцией, которая потребляет итерируемый объект (например, *sum()*, *list()* и т.п.) Например:
```python
>>> for n in frange(0, 4, 0.5):
... 	print(n)
...
0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
>>> list(frange(0, 1, 0.125))
[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]
>>>
```

### Обсуждение
Само присутствие инструкции *yield* в функции превращает её в генератор. В отличие от обычной функции, генератор запускается только в ответ на итерацию. Вот эксперимент, который вы можете провести, чтобы понять внутренний механизм работы таких функций:
```python
>>> def countdown(n):
...print('Starting to count from', n)
...while n > 0:
...	yield n
...	n -= 1
...print('Done!')
...

>>> # Create the generator, notice no output appears
>>> c = countdown(3)
>>> c
<generator object countdown at 0x1006a0af0>

>>> # Run to first yield and emit a value
>>> next(c)
Starting to count from 3
3

>>> # Run to the next yield
>>> next(c)
2

>>> # Run to next yield
>>> next(c)
1

>>> # Run to next yield (iteration stops)
>>> next(c)
Done!
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
StopIteration
>>>
``` 

Ключевая особенность функции-генератора состоит в том, что она запускается только в ответ на операции *next* в ходе итерирования. Когда генератор возвращает значение, итерирование останавливается. Однако цикл *for*, который обычно используется для выполнения итераций, сам заботится об этих деталях, поэтому в большинстве случаев вам не стоит волноваться о них. 

## 4.4. Реализация протокола итератора
### Задача
Вы создаете собственные объекты, которые вы хотите сделать итерируемыми, и ищете простой способ реализовать протокол итератора.

### Решение
На текущий момент простейший способ имплементации итерируемости в объекте — это использование генератора. В **рецепте 4.2.** был представлен класс *Node*, представляющий древовидные структуры. Возможно, вы захотите реализовать итератор, который будет обходить узлы поиском в глубину. Вот как можно это сделать:
```python
class Node:
	def __init__(self, value):
		self._value = value
		self._children = []

	def __repr__(self):
		return 'Node({!r})'.format(self._value)

	def add_child(self, node):
		self._children.append(node)

	def __iter__(self):
		return iter(self._children)

	def depth_first(self):
		yield self
		for c in self:
			yield from c.depth_first()

# Example
if __name__ == '__main__':
	root = Node(0)
	child1 = Node(1)
	child2 = Node(2)
	root.add_child(child1)
	root.add_child(child2)
	child1.add_child(Node(3))
	child1.add_child(Node(4))
	child2.add_child(Node(5))

	for ch in root.depth_first():
		print(ch)
	# Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
``` 

В этой программе метод *depth_first()* просто прочесть и описать. Сначала он выдает себя, а затем итерируется по каждому потомку, выдавая элементы, производимые методом *depth_first()* потомка (используя *yield from*). 

### Обсуждение
Протокол итератора Python требует *__iter()__*, чтобы вернуть специальный объект итератора, в котором реализована операция *__next()__*, а исключение *StopIteration* используется для подачи сигнала о завершении. Однако создание таких объектов частов может быть запутанным делом. Например, следующая программа демонстрирует альтернативную имплементацию метода *depth_first()*, использующую связанный класс итератора:
```python
class Node:
	def __init__(self, value):
		self._value = value
		self._children = []
	
	def __repr__(self):
		return 'Node({!r})'.format(self._value)
	
	def add_child(self, other_node):
		self._children.append(other_node)
	
	def __iter__(self):
		return iter(self._children)
	
	def depth_first(self):
		return DepthFirstIterator(self)

class DepthFirstIterator(object):
	'''
	Depth-first traversal
	'''
	
	def __init__(self, start_node):
		self._node = start_node
		self._children_iter = None
		self._child_iter = None
	
	def __iter__(self):
		return self
	
	def __next__(self):
		# Return myself if just started; create an iterator for children
		if self._children_iter is None:
			self._children_iter = iter(self._node)
			return self._node
	
		# If processing a child, return its next item
		elif self._child_iter:
		try:
			nextchild = next(self._child_iter)
			return nextchild
		except StopIteration:
			self._child_iter = None
			return next(self)
		
		# Advance to the next child and start its iteration
		else:
			self._child_iter = next(self._children_iter).depth_first()
			return next(self)
``` 

Класс DepthFirstIterator работает так же, как и версия на основе генератора, но он беспорядочен и некрасив, поскольку итератор вынужден хранить много сложных состояний о состоянии итерационного процесса. Откровенно говоря, никому не нравится писать такой мозговыносящий код. Реализуйте итератор на базе генератора и успокойтесь на этом.

## 4.5. Итерирование в обратном порядке
### Задача
Вы хотите проитерировать по последовательности в обратном порядке.

### Решение
Используйте встроенную функцию *reversed()*. Например:
```python
>>> a = [1, 2, 3, 4]
>>> for x in reversed(a):
... 	print(x)
...
4
3
2
1
```

Обратная итерация сработает только в том случае, если объект имеет определенный размер, или если в нём реализован специальный метод *__reversed__()*. Если ни одно из этих условий не выполнено, вы должны будете сначала конвертировать объект в список. Например:
```python
# Print a file backwards
f = open('somefile')
for line in reversed(list(f)):
	print(line, end='')
```

Обратите внимание, что конвертирование итерируемого объекта в список может съесть много памяти, если список получится большим. 

### Обсуждение
Многие программисты не знают, что итерирование в обратном порядке может быть переопределено в собственном классе, если он реализует метод *__reversed__()*. Например
```python
class Countdown:
	def __init__(self, start):
		self.start = start
	
	# Forward iterator
	def __iter__(self):
		n = self.start
		while n > 0:
			yield n
			n -= 1
	
	# Reverse iterator
	def __reversed__(self):
		n = 1
		while n <= self.start:
			yield n
			n += 1
``` 

Определение обратного итератора делает код намного более эффективным, а также отпадает необходимость предварительного помещения данных в список для выполнения итераций в обратном порядке.

## 4.6. Определение генератора с дополнительным состоянием
### Задача
Вы хотите написать генератор, но функция работает с дополнительным состоянием, которое вам хотелось бы каким-то образом показать пользователю.

### Решение
Если вам нужен генератор, который показывает пользователю дополнительное состояние, не забудьте, что вы можете легко реализовать его в форме класса, поместив код генератора в метод *__iter__()*. Например:
```python
from collections import deque

class linehistory:
	def __init__(self, lines, histlen=3):
		self.lines = lines
		self.history = deque(maxlen=histlen)
	
	def __iter__(self):
		for lineno, line in enumerate(self.lines,1):
			self.history.append((lineno, line))
			yield line
	
	def clear(self):
		self.history.clear()
```

Вы можете обращаться с этим классом так же, как с обычным генератором. Однако, поскольку он создает экземпляр, вы можете обращаться к внутренним атрибутам, таким как *history* или метод *clear()*. Например:
```python
with open('somefile.txt') as f:
	lines = linehistory(f)
	for line in lines:
		if 'python' in line:
			for lineno, hline in lines.history:
				print('{}:{}'.format(lineno, hline), end='')
```

### Обсуждение
С генераторами легко попасть в ловушку, если пытаться делать всё только с помощью функций. В результате может получиться сложный код, если генератору нужно взаимодействовать с другими частями программы некими необычнымыми способами (раскрытие атрибутов, разрешение на управление через вызов методов и т.п.) В этом случае просто используйте определение класса, как показано выше. Определение генератора в методе *__iter__()* не изменит ничего в том, как вы напишете алгоритм. Но тот факт, что генератор станет частью класса, сделает простым предоставление юзерам атрибутов и методов для каких-то взаимодействий.

Потенциально хрупкость в показанном приёме заключается в том, что он может потребовать дополнительного шага: вызова *iter()*, если вы собираетесь провести итерацию не через цикл *for*. Например:
```python
>>> f = open('somefile.txt')
>>> lines = linehistory(f)
>>> next(lines)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'linehistory' object is not an iterator

>>> # Call iter() first, then start iterating
>>> it = iter(lines)
>>> next(it)
'hello world\n'
>>> next(it)
'this is a test\n'
>>>
```

## 4.7. Получение среза итератора
### Задача
Вы хотите получить срез данных, производимых итератором, но обычный оператор среза не работает.

### Решение
Функция *itertools.islice()* отлично подходит для получения срезов генераторов и итераторов. Например:
```python
>>> def count(n):
... 	while True:
...			yield n
...			n += 1
...
>>> c = count(0)
>>> c[10:20]
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'generator' object is not subscriptable

>>> # Now using islice()
>>> import itertools
>>> for x in itertools.islice(c, 10, 20):
... 	print(x)
...
10
11
12
13
14
15
16
17
18
19
>>>
```

### Обсуждение
Из итераторов и генераторов получить срез напрямую нельзя, потому что отсутствует информация об их длине (и в них не реализовано индексирование). Результат *islice()* — это итератор, который создает элементы нужного среза, но делает это путем потребления и выбрасывания всех элементов до стартового индекса среза. Следующие элементы затем производятся объектом *islice*, пока не будет достигнут конечный индекс среза. 

Важно отметить, что *islice()* будут потреблять данные, предоставляемые итератором. Это важно, поскольку итераторы не могут быть отмотаны назад. Если вам нужно возвращаться назад, то вам, наверное, лучше сначала конвертировать данные в список.

## 4.8. Пропуск первой части итерируемого объекта
### Задача
Вы хотите итерировать по элементам в последовательности, но первые несколько элементов вам неинтересны, и вы хотите их опустить.

### Решение
В модуле *itertools* есть несколько функций, которые могут быть использованы для решения этой задачи. Первая — *itertools.dropwhile()*. Чтобы использовать её, вы предоставляете функцию и итерируемый объект. Возвращаемый итератор отбрасывает первые элементы в последовательности до тех пор, пока предоставленная функция возвращает True. А затем выдается вся оставшаяся последовательность. 

Предположим, что вы читаете файл, который начинается со строчек с комментариями:
```python
>>> with open('/etc/passwd') as f:
... for line in f:
... 	print(line, end='')
...
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode. At other times, this information is provided by
# Open Directory.
...
##
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
>>>
```

Если вы хотите пропустить все начальные закомментированные строчки, вот как это можно сделать:
```python
>>> from itertools import dropwhile
>>> with open('/etc/passwd') as f:
...		for line in dropwhile(lambda line: line.startswith('#'), f):
...			print(line, end='')
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
>>>
```

Этот пример показывает, как можно пропустить первые элементы в соответствии с возвращаемым значением проверочной функции. Если так случилось, что вы знаете точное количество элементов, которые вы хотите пропустить, то вы можете вместо вышеописанного способа использовать *itertools.islice()*. Например:
```python
>>> from itertools import islice
>>> items = ['a', 'b', 'c', 1, 4, 10, 15]
>>> for x in islice(items, 3, None):
...		print(x)
...
1
4
10
15
>>>
```

В этом примере последний аргумент *islice()* *None* необходим для того, чтобы обозначить, что вам нужно всё за пределами первых трёх элементов (а не первые три элемента). То есть срез [3:0], а не [:3].

### Обсуждение
Главное преимущество функций *dropwhile()* и *islice()* в том, что они позволяют избажеть написания грязного кода наподобие вот такого:
```python
with open('/etc/passwd') as f:
	# Skip over initial comments
	while True:
		line = next(f, '')
		if not line.startswith('#'):
			break

# Process remaining lines
while line:
	# Replace with useful processing	
	print(line, end='')
	line = next(f, None)
```

Отбрасывание первой части итерируемого объекта также немного отличается от простого фильтрования. Например, первая часть этого рецепта может быть переписана вот так:
```python
with open('/etc/passwd') as f:
	lines = (line for line in f if not line.startswith('#'))
	for line in lines:
		print(line, end='')
```

Очевидно, что это отбросит все закомментированные строчки в начале файла, но такое решение отбросит и все остальные такие строчки во всём файле. С другой стороны, решение, которое отбрасывает все элементы до тех пор, пока не будет встречен элемент, не соответствующий условиям отбрасывания, удовлетворяет нашим требованиям: все последующие элементы будут возвращены без фильтрования.

Стоит отметить, что этот рецепт работает со всеми итерируемыми объектами, включая те, размер которых нельзя оценить предварительно: генераторами, файлами и другими подобными объектами.

## 4.9. Итерирование по всем возможным комбинациям и перестановкам
### Задача
Вы хотите проитерировать по всем возможным комбинациям и перестановкам коллекции элементов.

### Решение
Модуль *itertools* предоставляет три функции, подходящие для этой задачи. Первая, *itertools.permutations()*, принимает коллекцию элементов и создает последовательность кортежей со всеми возможными перестановками (то есть она тасует их во всех возможных конфигурациях). Например:
```python
>>> items = ['a', 'b', 'c']
>>> from itertools import permutations
>>> for p in permutations(items):
... 	print(p)
...
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
>>>
```

Если вы хотите получить все возможные перестановки меньшей длины, вы можете передать функции необязательный аргумент со значением длины. Например:
```python
>>> for p in permutations(items, 2):
...		print(p)
...
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
>>>
```

Используйте *itertools.combinations()*, чтобы создать последовательность комбинаций элементов входной последовательности. Например:
```python
>>> from itertools import combinations
>>> for c in combinations(items, 3):
...		print(c)
...
('a', 'b', 'c')
>>> for c in combinations(items, 2):
... 	print(c)
...
('a', 'b')
('a', 'c')
('b', 'c')
>>> for c in combinations(items, 1):
...		print(c)
...
('a',)
('b',)
('c',)
>>>
```

Для функции *combinations()* порядок элементов не имеет значения. Поэтому комбинация ('a', 'b') она считает аналогичной ('b', 'a') — поэтому вторая в выводимых результатах отсутствует.

При создании комбинаций выбранные элементы удаляются из коллекции возможных кандидатов (то есть если 'a' уже выбран, он больше не будет рассматриваться). А функция itertools.combinations_with_replacement() выбирает один и тот же элемент более одного раза. Например:
```python
>>> for c in combinations_with_replacement(items, 3):
...		print(c)
...
('a', 'a', 'a')
('a', 'a', 'b')
('a', 'a', 'c')
('a', 'b', 'b')
('a', 'b', 'c')
('a', 'c', 'c')
('b', 'b', 'b')
('b', 'b', 'c')
('b', 'c', 'c')
('c', 'c', 'c')
>>>
``` 

### Обсуждение
Этот рецепт показывает лишь небольшую часть мощи модуля *itertools*. Хотя вы могли бы самостоятельно написать код, который выполняет перестановки и комбинации, это, вероятно, отняло бы у вас больше пары секунд времени. Когда вы сталкиваетесь с нетривиальными задачами итераций, обратитесь к *itertools*, это всегда окупается. Если задача типичная, велик шанс того, что вы найдете готовое решение.

## 4.10. Итерирование по парам «индекс-значение» последовательности 

### Задача
Вы хотите проитерировать по последовательности и при этом хранить информацию о том, какой по счёту элемент сейчас обрабатывается.

### Решение
Встроенная функция enumerate() изящно справляется с этой задачей:
```python
>>> my_list = ['a', 'b', 'c']
>>> for idx, val in enumerate(my_list):
...		print(idx, val)
...
0 a
1 b
2 c
``` 

Для печати вывода с привычными номерами строк (то есть с нумерацией, начинающейся с 1, а не с 0), вы можете передать соответствующий аргумент start:
```python
>>> my_list = ['a', 'b', 'c']
>>> for idx, val in enumerate(my_list, 1):
...		print(idx, val)
...
1 a
2 b
3 c
```

Этот приём особенно полезен для учёта номеров строк в файлах, если нужно будет вывести номер строки в сообщении об ошибке:
```python
def parse_data(filename):
	with open(filename, 'rt') as f:
		for lineno, line in enumerate(f, 1):
			fields = line.split()
			try:
				count = int(fields[1])
				...
				except ValueError as e:
					print('Line {}: Parse error: {}'.format(lineno, e))
```

*enumerate()* удобна, например, для отслеживания смещения (offset) в списке для вхождений определенных значений. Так что если вы хотите отобразить слова в файле к строчкам, в которых они встречаются, это легко сделать с помощью enumerate() — функция отображает каждое слово на смещение строки в файле, где оно найдено:
```python
word_summary = defaultdict(list)

with open('myfile.txt', 'r') as f:
	lines = f.readlines()

for idx, line in enumerate(lines):
	# Create a list of words in current line
	words = [w.strip().lower() for w in line.split()]
	for word in words:
		word_summary[word].append(idx)
```

Если вы выведете *word_summary* после обработки файла, это будет словарь (*default dict*, если быть точными), и каждое слово будет ключом. Значение для каждого ключа — список номеров строк, где встретилось это слово. Если слово встретилось дважды в одной строке, этот номер строки будет записан в список дважды, что делает возможным получение разнообразных простых метрик текста.

### Обсуждение
*enumerate()* — симпатичное решение для ситуаций, где вы могли бы склоняться использованию собственной переменной-счетчика. Вы могли бы написать такой код:
```python
lineno = 1
	for line in f:
	# Process line
	...
	lineno += 1
```

Но часто более элегантным (и менее подверженным ошибкам) способом становится использование *enumerate()*:
```python
for lineno, line in enumerate(f):
	# Process line
	...
```

Значение, возвращаемое функцией *enumerate()*, является объектом *enumerate*. Это итератор, который последовательно возвращает кортежи, состоящие из счётчика и значения, возвращаемого вызовом функции *next()* для последовательности, которую вы обходите.

Стоит отметить, что иногда можно запутаться при применении *enumerate()* к последовательности кортежей, которые при этом распаковываются:
```python
data = [ (1, 2), (3, 4), (5, 6), (7, 8) ]

# Correct!
for n, (x, y) in enumerate(data):
	...

# Error!
	for n, x, y in enumerate(data):
	...
```

## 4.11. Одновременное итерирование по нескольким последовательностям
### Задача
Вы хотите за один раз проитерировать по элементам, содержащимися более чем в одной последовательности.

### Решение
Чтобы итерировать по более чем одной последовательности за раз, используйте функцию *zip()*. Например:
```python
>>> xpts = [1, 5, 4, 2, 10, 7]
>>> ypts = [101, 78, 37, 15, 62, 99]
>>> for x, y in zip(xpts, ypts):
... 	print(x,y)
...
1 101
5 78
4 37
2 15
10 62
7 99
>>>
```

*zip(a, b)* работает путём создания итератора, который производит кортежи (x, y), где x берётся из a, а y — из b. Итерирование останавливается, когда заканчивается одна из последовательностей. Поэтому результат будет таким же по длине, как и самая короткая из входных последовательностей. Например:
```python
>>> a = [1, 2, 3]
>>> b = ['w', 'x', 'y', 'z']
>>> for i in zip(a,b):
...		print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
```

Если такое поведение нежелательно, используйте функцию *itertools.zip_longest()*. Например:
```python
>>> from itertools import zip_longest
>>> for i in zip_longest(a,b):
...		print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(None, 'z')
>>> for i in zip_longest(a, b, fillvalue=0):
... 	print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(0, 'z')
>>>
```

### Обсуждение
*zip()* обычно используется тогда, когда вам нужно создать пары из данных. Предположим, например, что у вас есть список заголовков столбцов и значения столбцов:
```python
headers = ['name', 'shares', 'price']
values = ['ACME', 100, 490.1]
```

Используя *zip()*, вы можете создать пары значений и поместить их в словарь:
```python
s = dict(zip(headers,values))
```

Если вы хотите вывести результат, можно поступить так:
```python
for name, val in zip(headers, values):
	print(name, '=', val)
```

Менее распространённое применение *zip()* заключается в том, что функции может быть передано не две последовательности, а больше. В этом случае кортежи результата будут иметь такое количество элементов, каким было количество последовательностей. Например:
```python
>>> a = [1, 2, 3]
>>> b = [10, 11, 12]
>>> c = ['x', 'y', 'z']
>>> for i in zip(a, b, c):
...		print(i)
...
(1, 10, 'x')
(2, 11, 'y')
(3, 12, 'z')
>>>
```

И последнее: важно подчеркнуть, что *zip()* возвращает итератор. Если вам нужны сохраненные в списке спаренные значения, используйте функцию *list()*. Например:
```python
>>> zip(a, b)
<zip object at 0x1007001b8>
>>> list(zip(a, b))
[(1, 10), (2, 11), (3, 12)]
>>>
```

## 4.12. Интерирования по элементам, находящимся в отдельных контейнерах
### Проблема
Вам нужно выполнить одинаковую операцию над большим количеством объектов, но объекты находятся в различных контейнерах, а вам хотелось бы избежать написания вложенных циклов, причем без потери читабельности кода.

### Решение
Для упрощения этой задачи может быть использовать метод *itertools.chain()*. Он принимает список итерируемых объектов и возвращает итератор, который эффективно скрывает тот факт, что вы на самом деле работаете с несколькими контейнерами. Рассмотрим пример:
```python
>>> from itertools import chain
>>> a = [1, 2, 3, 4]
>>> b = ['x', 'y', 'z']
>>> for x in chain(a, b):
... 	print(x)
...
1
2
3
4
x
y
z
>>>
```

Обычно *chain()* используется, если вы хотите выполнить некоторые операции над всеми элементами за один раз, но элементы разнесены по разным рабочим наборам. Например:
```python
# Various working sets of items
active_items = set()
inactive_items = set()

# Iterate over all items
for item in chain(active_items, inactive_items):
	# Process item
	...
``` 

Это решение намного более элегантно, нежели использование двух отдельных циклов, как показано в этом примере:
```python
for item in active_items:
	# Process item
	...

for item in inactive_items:
	# Process item
	...
```

### Обсуждение
*itertools.chain()* принимает один или более итерируемых объектов в качестве аргументов. Далее она создает итератор, который последовательно потребляет и возвращает элементы, производимые каждым из предоставленных итерируемых объектов. Это тонкое различие, но *chain()* эффективнее, чем итерирование по предварительно объединенным последовательностям. Например:
```python
# Inefficent
	for x in a + b:
	...

# Better
	for x in chain(a, b):
	...
```

В первом случае операция a + b создает новую последовательность и дополнительно требует, чтобы a и b относились к одному типу. *chain()* не выполняет такую операцию, намного эффективнее обращается с памятью, если входные последовательности большие, а также легко применяется к итерируемым объектов различных типов.

## 4.13. Создание каналов для обработки данных
### Задача
Вы хотите обрабатывать данные итеративно, в стиле обрабатывающего данные канала (похожего на канал — он же конвейер — Unix). Например, у вас есть огромный объем данных для обработки, который просто не поместится в память целиком.

### Решение
Генераторы хорошо подходят для реализации обрабатывающих каналов. Предположим, например, что у вас есть огромный каталог с файлами логов, который вы хотите обработать:
```
foo/
	access-log-012007.gz
	access-log-022007.gz
	access-log-032007.gz
	...
	access-log-012008
bar/
	access-log-092007.bz2
	...
	access-log-022008
``` 

Предположим, каждый файл содержит такие строки данных:
```
124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] "GET /robots.txt ..." 200 71
210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] "GET /ply/ ..." 200 11875
210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] "GET /favicon.ico ..." 404 369
61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] "GET /blog/atom.xml ..." 304 -
...
```

Чтобы обработать эти файлы, вы могли бы создать коллекцию небольших генераторов, которые будут выполнять специфические замкнутые в себе задачи:
```python
import os
import fnmatch
import gzip
import bz2
import re

def gen_find(filepat, top):
	'''
	Find all filenames in a directory tree that match a shell wildcard pattern
	'''
	for path, dirlist, filelist in os.walk(top):
		for name in fnmatch.filter(filelist, filepat):
			yield os.path.join(path,name)

def gen_opener(filenames):
	'''
	Open a sequence of filenames one at a time producing a file object.
	The file is closed immediately when proceeding to the next iteration.
	'''
	for filename in filenames:
		if filename.endswith('.gz'):
			f = gzip.open(filename, 'rt')
		elif filename.endswith('.bz2'):
			f = bz2.open(filename, 'rt')
		else:
			f = open(filename, 'rt')
		yield f
		f.close()


def gen_concatenate(iterators):
	'''
	Chain a sequence of iterators together into a single sequence.
	'''
	for it in iterators:
		yield from it
	
def gen_grep(pattern, lines):
	'''
	Look for a regex pattern in a sequence of lines
	'''
	pat = re.compile(pattern)
	for line in lines:
		if pat.search(line):
			yield line
```

Теперь вы можете легко совместить эти функции для создания обрабатывающего канала. Например, чтобы найти все файлы логов, которые содержат слово *python*, вы можете поступить так:
```python
lognames = gen_find('access-log*', 'www')
files = gen_opener(lognames)
lines = gen_concatenate(files)
pylines = gen_grep('(?i)python', lines)
for line in pylines:
	print(line)
```

Если вы хотите еще расширить канал, вы можете скармливать данные выражениям-генераторам. Например, эта версия находит количество переданных байтов и подсчитывает общую сумму:
```python
lognames = gen_find('access-log*', 'www')
files = gen_opener(lognames)
lines = gen_concatenate(files)
pylines = gen_grep('(?i)python', lines)
bytecolumn = (line.rsplit(None,1)[1] for line in pylines)
bytes = (int(x) for x in bytecolumn if x != '-')
print('Total', sum(bytes))
```

### Обсуждение
Обработка данных в «каналообразной» манере отлично работает для решения широкого спектра задач: парсинга, чтения из риалтаймовых источников данных, периодического опрашивания и т.д.

В понимании представленного выше кода главное уловить, что инструкция *yield* действует как своего рода производитель данных для цикла *for*, который действует как потребитель данных. Когда генераторы соединены, каждый *yield* скармливает один элемент данных следующему этапу канала, который потребляет его, совершая итерацию. В последнем примере функция *sum()* управляет всей программой, вытягивая один элемент за другим из канала (конвейера) генераторов.

Приятная возможность этого подхода заключается в том, что каждый генератор является маленьким и замкнутым на себе, поэтому их легко писать и поддерживать. Во многих случаях они получаются настолько универсальными, что могут быть переиспользованы в других контекстах. Получающийся код, который «склеивает» компоненты вместе, тоже обычно читается как простой для понимания рецепт. 

Есть небольшая тонкость с использованием функции *gen_concatenate()*. Ее назначение — конкатенировать входные последовательности в одну длинную последовательность строк. *itertools.chain()* выполняет похожую функцию, но требует, чтобы все объединяемые итерируемые объекты были определены в качестве аргументов. В случае этого конкретного рецепта, такой подход потребовал бы инструкции типа *lines = itertools.chain(\*files)*, которая заставила бы генератор *gen_opener()* быть полностью потребленным. Поскольку генератор производит последовательность открытых файлов, которые немедленно закрываются на следующем шаге итерации, *chain()* использовать нельзя. Показанное решение позволяет решить эту проблему.

Также в функции *gen_concatenate()* используется *yield from* для делегирования субгенератору. Объявление *yield from it* просто заставляет *gen_concatenate()* выдать все значения, произведенные генератором *it*. Это описано далее, в **рецепте 4.14.**

И последнее: стоит отметить, что «конвейерный» («канальный») подход не работает для всех на свете задач обработки данных. Иногда вам просто необходимо работать со всеми данными сразу. Однако, даже в этом случае, использование каналов генераторов может стать путём логического разбиения задачи. 

Дэвид Бизли подробно написать об этих приёмах в обучающющей презентации [«Трюки с генераторами для системных программистов»](http://www.dabeaz.com/generators). Если вам нужны дополнительные примеры, обратитесь к ней.

## 4.14. Превращение вложенной последовательности в плоскую 
### Задача
У вас есть вложенная последовательность, и вы хотите превратить ее в один плоский список значений.

### Решение
Это легко решается с помощью рекурсивного генератора с инструкцией *yield from*. Например:
```python
from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
	for x in items:
		if isinstance(x, Iterable) and not isinstance(x, ignore_types):
			yield from flatten(x)
		else:
			yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]

# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
	print(x)
```

В этой программе *isinstance(x, Iterable)* просто проверяет, является ли элемент итерируемым объектом. Если это так, то *yield from* используется в качестве некой подпрограммы, чтобы выдать все его значения. Конечный результат — одна последовательность без вложенности.

Дополнительный аргументы *ignore_types* и проверка *not isinstance(x, ignore_types)* нужны для предотвращения определения строк и байтов как итерируемых последовательностей, без чего они были бы разбиты на отдельные символы. Это позволяет вложенным спискам строк работать так, как большинство людей этого и ожидают:
```python
>>> items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
>>> for x in flatten(items):
... 	print(x)
...
Dave
Paula
Thomas
Lewis
>>>
```

### Обсуждение
Инструкция *yield from* — отличный способ написания генераторов, которые вызывают другие генераторы в качестве подпроцедуры. Без использования этой инструкции вам придется вставить в код дополнительный цикл. Например:
```python
def flatten(items, ignore_types=(str, bytes)):
	for x in items:
		if isinstance(x, Iterable) and not isinstance(x, ignore_types):
			for i in flatten(x):
				yield i
		else:
			yield x
```

Хотя это незначительное изменение, инструкция *yield from* просто приятнее и делает код чище.

Как было отмечено, дополнительная проверка на строки и байты нужна для предотвращения их разбивки на отдельные символы. Если есть еще какие-то типы, которые вы не хотите раскрывать, вы просто можете передать другие значения в *ignore_types*.

Стоит отметить, что *yield from* играет более важную роль в продвинутых программах, использующих корутины и основанную на генераторах многопоточность. См. другой пример в **рецепте 12.12.**

## 4.15. Последовательное итерирование по слитым отсортированным итерируемым объектам
### Задача
У вас есть коллекция отсортированных последовательностей, и вы хотите проитерировать по отсортированной последовательности этих последовательностей, слитых воедино.

### Решение
Функция *heapq.merge()* делает именно это:
```python
>>> import heapq
>>> a = [1, 4, 7, 10]
>>> b = [2, 5, 6, 11]
>>> for c in heapq.merge(a, b):
...		print(c)
...
1
2
4
5
6
7
10
11
```

### Обсуждение
Итеративная природа *heapq.merge()* подразумевает, что она никогда не читает одну из переданных ей последовательностей сразу до конца. Это значит, что вы можете использовать ее на длинных последовательностях с очень незначительным оверхедом. Вот, например, как вы можете слить воедино два отсортированных файла:
```python
import heapq
with open('sorted_file_1', 'rt') as file1, \
	open('sorted_file_2') 'rt' as file2, \
	open('merged_file', 'wt') as outf:

for line in heapq.merge(file1, file2):
	outf.write(line)
```

Важно отметить, что *heapq.merge()* требует, чтобы все передаваемые ей последовательности уже были отсортированы. Она не читает предварительно данные в кучу, не выполняет предварительную сортировку. Также она не выполняет никакой валидации входных данных на соответствие требованиям упорядоченности. Она просто проверяет набор элементов из «голов» каждой переданной последовательности и выдает минимальный из найденных. Далее читается новый элемент из выбранной последовательности, и процесс повторяется до тех пор, пока все входные последовательности не будут полностью потреблены.

## 4.16. Замена бесконечных циклов while итератором
### Задача
У вас есть код, который использует цикл while для итеративной обработки данных, потому что в программе присутствует функция или какое-то необычное проверочное условие, которое нельзя вместить в стандартный итерационный паттерн. 

### Решение
Вполне обычный код для программ, работающих с вводом-выводом:
```python
CHUNKSIZE = 8192

def reader(s):
	while True:
		data = s.recv(CHUNKSIZE)
		if data == b'':
			break
		process_data(data)
``` 

Такой код часто можно заменить использованием *iter()*, как показано ниже:
```python
def reader(s):
	for chunk in iter(lambda: s.recv(CHUNKSIZE), b''):
		process_data(data)
```

Если вы сомневаетесь, будет ли это работать, вы можете попробовать похожий пример для обработки файлов:
```python
>>> import sys
>>> f = open('/etc/passwd')
>>> for chunk in iter(lambda: f.read(10), ''):
... 	n = sys.stdout.write(chunk)
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
daemon:*:1:1:System Services:/var/root:/usr/bin/false
_uucp:*:4:4:Unix to Unix Copy Protocol:/var/spool/uucp:/usr/sbin/uucico
...
>>>
```

### Обсуждение
Малоизвестная возможность встроенной функции *iter()* заключается в том, что она может опционально принимать вызываемый (callable) аргумент и «стража» (завершающее значение). При таком использовании функция создает итератор, который снова и снова повторяет вызов предоставленного вызываемого объекта, пока он не вернет значение, равное «стражу».

Этот конкретный подход хорошо работает с некоторыми типами многократно вызываемых функций, таких как операции ввода-вывода. Например, если вы хотите читать данные кусочками (чанками) из файлов или сокетов, вы обычно должны многократно вызывать *read()* или *recv()* с последующей проверкой достижения конца файла. Представленный выше рецепт просто берет эти две функциональности и совмещает в единственном вызове *iter()*. Использование *lambda* в решении необходимо для создания вызываемого объекта, который не принимает аргументов, но при этом поставляет аргумент нужного размера в *recv()* или *read()*.

# 5. Файлы и ввод-вывод
Всем программам нужно производить ввод и вывод. Эта глава покрывает типичные идиомы для работы с различными типами файлов, включая текстовые и бинарные, кодировки файлов и прочие связанные темы. Также тут освещены приёмы манипулирования именами файлов и каталогов.

## 5.1. Чтение и запись текстовых данных
### Решение
Вам нужно прочитать или записать текстовые данные, возможно представленные в различных кодировках, таких как ASCII, UTF-8 или UTF-16.

### Решение
Используйте функцию *open()* в режиме *rt* для чтения текстового файла. Например:
```python
# Read the entire file as a single string
with open('somefile.txt', 'rt') as f:
	data = f.read()

# Iterate over the lines of the file
with open('somefile.txt', 'rt') as f:
	for line in f:
	# process line
	...
``` 

Похожим образом для записи в текстовый файл используйте *open()* в режиме *wt* (стирает и перезаписывает любое предыдущее содержание файла, если оно было):
```python
# Write chunks of text data
with open('somefile.txt', 'wt') as f:
	f.write(text1)
	f.write(text2)
	...

# Redirected print statement
with open('somefile.txt', 'wt') as f:
	print(line1, file=f)
	print(line2, file=f)
	...
```

Чтобы добавить записываемый текст к концу существующего файла, используйте *open()* в режиме *at*.

По умолчанию файлы читаются и записываются в дефолтной системной кодировке, информацию о которой можно получить из *sys.getdefaultencoding()*. На большинстве компьютеров это будет *utf-8*. Если вы знаете, что текст, который вы читаете или пишите, представлен в другой кодировке, передайте необязательный параметр *encoding* функции *open()*. Например:
```python
with open('somefile.txt', 'rt', encoding='latin-1') as f:
	...
``` 

Python понимает несколько сотен текстовых кодировок. Однако самые распространенные — ascii, latin-1, utf-8 и utf-16. utf-8 обычно является безопасным выбором для работы с веб-приложениями. ascii соответствует 7-битным символам в диапазоне от U+0000 до U+007F. latin-1 — это прямое отображение байтов 0-255 на символы Unicode от U-0000 до U-00FF. latin-1 известна тем, что она никогда не вызовет ошибку декодирования при чтении текста в возможно неизвестной кодировке. Чтение файла как latin-1 может не привести к получению полностью правильно декодированного текста, но этого бывает достаточно для извлечения полезных данных. Также, если вы позже запишете данные обратно, первоначальные данные будут сохранены.

### Обсуждение
Чтение и запись файлов в большинстве случаев совершенно прямолинейны. Однако есть и тонкости. Во-первых, использование инструкции *with* в примере устанавливает контекст, в котором будут использованы файлы. Когда поток управления покидает блок *with*, файл будет автоматически закрыт.  Вы не обязаны использовать инструкцию *with*, но если вы ее не применяете, то не забудьте закрыть файл:
```python
f = open('somefile.txt', 'rt')
data = f.read()
f.close()
``` 

Ещё одна небольшая сложность касается распознавания новых строк, символы которых отличаются в Unix и Windows (\\n и \\r\\n). По умолчанию Python работает в так называемом «универсальном режиме новых строк». В этом режиме все распространённые символы новой строки распознаются, и все они конвертируются в единственный \\n при чтении. Похожим образом символ новой строки \\n конверируется в дефолтный системный символ при выводе. Если вы не хотите использовать такую трансляцию, передайте функции *open()* аргумент *newline=''*:
```pytnon
# Read with disabled newline translation
with open('somefile.txt', 'rt', newline='') as f:
	...
```  

Чтобы продемонстрировать разницу, покажем, что вы увидите на компьютере с Unix, если вы читаете содержание файла в Windows-кодировке, в котором присутствуют сырые данные *hello world!\\r\\n*:
```python
Contents of a Windows-encoded text file containing the raw data hello world!\r\n :
>>> # Newline translation enabled (the default)
>>> f = open('hello.txt', 'rt')
>>> f.read()
'hello world!\n'

>>> # Newline translation disabled
>>> g = open('hello.txt', 'rt', newline='')
>>> g.read()
'hello world!\r\n'
>>>
```

Последняя проблема касается возможных ошибок кодировки в текстовых файлах. При чтении или записи текстового файла вы можете натолкнуться на ошибку кодирования или декодирования. Например:
```python
>>> f = open('sample.txt', 'rt', encoding='ascii')
>>> f.read()
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "/usr/local/lib/python3.3/encodings/ascii.py", line 26, in decode
		return codecs.ascii_decode(input, self.errors)[0]
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
12: ordinal not in range(128)
>>>
```

Если вы получили эту ошибку, это обычно означает, что вы не используете правильную кодировку для чтения файла. Вы должны внимательно прочитать спецификацию того, что вы пытаетесь прочесть, и удостовериться, что вы делаете это правильно (то есть не читаете данные как UTF-8 вместо Latin-1 и т.п.) Если ошибки кодирования все еще возникают, вы можете передать необязательный аргумент *errors* функции *open()*, чтобы обрабатывать ошибки. Вот несколько примеров типичных схем обработки ошибок:
```python
>>> # Replace bad chars with Unicode U+fffd replacement char
>>> f = open('sample.txt', 'rt', encoding='ascii', errors='replace')
>>> f.read()
'Spicy Jalape?o!'
>>> # Ignore bad chars entirely
>>> g = open('sample.txt', 'rt', encoding='ascii', errors='ignore')
>>> g.read()
'Spicy Jalapeo!'
>>>
```

Если вы постоянно ловите блох с кодировками, аргументами *errors* функции *open()* и изобретаете хаки, вы, вероятно, зря усложняете себе жизнь. Первое правило работы с текстом: убедитесь, что вы используете правильную кодировку. А если сомневаетесь, какую выбрать, используйте системную установку по умолчанию (обычно это UTF-8). 


## 5.2. Перенаправление вывода в файл
### Задача
Вы хотите перенаправить в файл вывод функции *print()*.

### Решение
Используйте *print()* c именованным аргументом *file*:
```python
with open('somefile.txt', 'rt') as f:
	print('Hello World!', file=f)
```

### Обсуждение
Про вывод в файл добавить больше и нечего. Разве что убедитесь, что файл открыт в текстовом режиме. Выводить в бинарном режиме так нельзя.

## 5.3. Вывод с другим разделителем или символом конца строки
### Задача
Вы хотите вывести данные с помощью *print()*, но вы также хотите поменять символ-разделитель или символ конца строки.

### Решение
Используйте именнованые аргументы *sep* и *end* с функцией *print()*, чтобы изменить вывод так, как вам нужно. Например:
```python
>>> print('ACME', 50, 91.5)
ACME 50 91.5
>>> print('ACME', 50, 91.5, sep=',')
ACME,50,91.5
>>> print('ACME', 50, 91.5, sep=',', end='!!\n')
ACME,50,91.5!!
>>>
```

Использование аргумента *end* также позволяет подавить добавление символа новой строки при выводе. Например:
```python
>>> for i in range(5):
...		print(i)
...
0
1
2
3
4
>>> for i in range(5):
...		print(i, end=' ')
...
0 1 2 3 4 >>>
```

### Обсуждение
Использование *print()* с разными разделителями элементов часто является самым простым способом вывести данные, когда вам нужно вывести данные с другим разделителем элементов. Однако иногда вы можете увидеть, как программисты используют *str.join()* для выполнения этой же задачи:
```python
>>> print(','.join('ACME','50','91.5'))
ACME,50,91.5
>>>
```

Проблема *str.join()* в том, что он работает только со строками. Это значит, что часто необходимо выполнить различные акробатические трюки, чтобы заставить его работать. Например:
```python
>>> row = ('ACME', 50, 91.5)
>>> print(','.join(row))
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: sequence item 1: expected str instance, int found
>>> print(','.join(str(x) for x in row))
ACME,50,91.5
>>>
```

Вместо этого вы могли бы просто написать так:
```python
>>> print(*row, sep=',')
ACME,50,91.5
>>>
```

## 5.4. Чтение и запись бинарных данных
### Задача 
Вам нужно прочесть или записать бинарные данные, такие как содержание картинок, звуковых файлов и т.п.

### Решение
Используйте функцию *open()* в режиме *rb* или *wb*, чтобы читать и записывать бинарные данные. Например:
```python
# Read the entire file as a single byte string
with open('somefile.bin', 'rb') as f:
	data = f.read()

# Write binary data to a file
with open('somefile.bin', 'wb') as f:
	f.write(b'Hello World')
```

При чтении бинарных данных важно подчеркнуть, что все получаемые данные будут в форме байтовых, а не текстовых строк. Похожим образом, при записи вы должны предоставить данные в форме объектов, которые представляют данные в форме байтов (байтовые строки, объекты *bytearray* и т.д.)

### Обсуждение
При чтении бинарных данных тонкие сематические различия между байтовыми и текстовыми строками могут привести к проблемам. Нужно помнить, что индексирование и итерирование возвращают целочисленное байтовое значение, а не байтовые строки. Например:
```python
>>> # Text string
>>> t = 'Hello World'
>>> t[0]
'H'
>>> for c in t:
...		print(c)
...
H
e
l
l
o
...
>>> # Byte string
>>> b = b'Hello World'
>>> b[0]
72
>>> for c in b:
... 	print(c)
...
72
101
108
108
111
...
>>>
```

Если вам когда-либо потребуется прочесть или записать текст из или в открытый в бинарном режиме файл, убедитесь, что не забыли декодировать или закодировать его. Например:
```python
with open('somefile.bin', 'rb') as f:
	data = f.read(16)
	text = data.decode('utf-8')

with open('somefile.bin', 'wb') as f:
	text = 'Hello World'
	f.write(text.encode('utf-8'))
```

Менее известный аспект бинарного ввода-вывода заключается в том, что такие объекты как массивы и структуры языка C могут быть использованы для записи без какого-либо промежуточного преобразования в объект *bytes*. Например:
```python
import array
nums = array.array('i', [1, 2, 3, 4])
with open('data.bin','wb') as f:
	f.write(nums)
```

Это применимо к любому объекту, в котором реализован так называемый «буферный интерфейс», который напрямую дает доступ к собственному буферу памяти операциям, которые могут с ним работать. Запись бинарных данных — одна из таких операций.

Многие объекты также позволяют бинарным данным напрямую быть прочитанными в их память с помощью файлового метода *readinto()*. Например:
```python
>>> import array
>>> a = array.array('i', [0, 0, 0, 0, 0, 0, 0, 0])
>>> with open('data.bin', 'rb') as f:
... 	f.readinto(a)
...
16
>>> a
array('i', [1, 2, 3, 4, 0, 0, 0, 0])
>>>
```

Однако нужно принять все меры предосторожности при использовании этого приёма, поскольку он часто является платформозависимым и зависит от таких вещей как размер слова, порядок следования байтов (big-endian или little-endian). См. рецепт *5.9.* для другого примера чтения бинарных данных в изменяемый (mutable) буфер.

## 5.5. Запись в файл, которого ещё нет
### Задача
Вы хотите записать данные в файл, но только в том случае, если его ещё нет в файловой системе.

### Решение
Эта задача легко решается с помощью использования малоизвестного режима *x* работы *open()* (вместо обычного режима *w*):
```python
>>> with open('somefile', 'wt') as f:
...		f.write('Hello\n')
...
>>> with open('somefile', 'xt') as f:
...		f.write('Hello\n')
...
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
FileExistsError: [Errno 17] File exists: 'somefile'
>>>
```

Если файл в бинарном режиме, используйте режим *xb* вместо *xt*.

### Обсуждение
Этот рецепт демонстрирует удивительно элегантное решение задачи, иногда возникающей при записи в файлы (например, случайной перезаписи существующего файла). Альтернативное решение — предварительная проверка:
```python
>>> import os
>>> if not os.path.exists('somefile'):
... 	with open('somefile', 'wt') as f:
...			f.write('Hello\n')
... else:
...		print('File already exists!')
...
... File already exists!
>>>
```

Очевидно, что использование режима *x* намного более прямолинейно. Важно отметить, что режим *x* доступен для функции *open()* только в Python 3. Этот режим не существовал в ранних версиях Python или низкоуровневневых библиотеках на языке C, использованных в реализации Python.

## 5.6. Выполнение операций ввода-вывода над строками
### Задача
Вы хотите скормить текст или бинарную строку программе, которая способна работать с файлоподобными объектами.

### Решение
Используйте классы *io.StringIO()* и *io.BytesIO()* для создания файлоподобных объектов, которые могут работать со строковыми данными. Например:
```python
>>> s = io.StringIO()
>>> s.write('Hello World\n')
12
>>> print('This is a test', file=s)
15
>>> # Get all of the data written so far
>>> s.getvalue()
'Hello World\nThis is a test\n'
>>>

>>> # Wrap a file interface around an existing string
>>> s = io.StringIO('Hello\nWorld\n')
>>> s.read(4)
'Hell'
>>> s.read()
'o\nWorld\n'
>>>
```  

Класс *io.StringIO* должен быть использован только для работы с текстом. Если вы работаете с бинарными данными, используйте *io.BytesIO*. Например:
```python
>>> s = io.BytesIO()
>>> s.write(b'binary data')
>>> s.getvalue()
b'binary data'
>>>
``` 

### Обсуждение
Классы *StringIO* и *BytesIO* наиболее полезны в случаях, когда вам нужно подменить обычный файл. Например, в юнит-тестах вы могли бы использовать *StringIO* для создания файлоподобного объекта, содержащего тестовые данные, которые скармливаются функции, которая приспособлена для работы с файлами.

Обратите внимание, что экземпляры *StringIO* и *BytesIO* не имеют настоящего целочисленного файлового дескриптора. Поэтому они будут работать с программами, которые требуют использования настоящих системных файлов (файлов, каналов, сокетов).

## 5.7. Чтение и запись сжатых файлов с данными
### Задача
Вам нужно прочесть или записать данные в файл, сжатый gzip или bz2.

### Решение
Модули *gzip* и *bz2* делают работу с такими файлами очень лёгкой. Оба модуля предоставляют альтернативную реализацию функции *open()*, которые могут быть использованы для этой цели. Например, чтобы прочесть сжатые файлы как текст, сделайте так:
```python
# gzip compression
import gzip
with gzip.open('somefile.gz', 'rt') as f:
	text = f.read()

# bz2 compression
import bz2
with bz2.open('somefile.bz2', 'rt') as f:
	text = f.read()
```

Как показано выше, весь ввод и вывод будет использовать текст и проводить кодирование/декодирование в Unicode. Если же вы хотите работать с бинарными данными, используйте файловые режимы *rb* или *wb*. 

### Обсуждение
Чтение и запись сжатых данных по большей части просты. Однако стоит знать, что выбор правильного файлового режима критически важен. Если вы не обозначите режим явно, то будет выбран режим по умолчанию, то есть бинарный, а это сломает программы, которые ожидают получить текст. *gzip.open()* и *bz2.open()* принимают те же параметры, что и встроенная функция *open()*, включая *encoding*, *errors*, *newline* и т.д.

При записи сжатных данных с помощью необязательного именованного аргумента *compresslevel* может быть установлен уровень компрессии. Например:
```python
with gzip.open('somefile.gz', 'wt', compresslevel=5) as f:
	f.write(text)
```

Уровень по умолчанию — это 9, то есть наивысший. Более низкие уровни увеличивают скорость, но снижают степень сжатия данных.

И последнее: малоизвестная особенность *gzip.open()* и *bz2.open()* заключается в том, что они могут работать уровнем выше существующего файла, открытого в бинарном режиме. Например, такой код работает:
```
import 

f = open('somefile.gz', 'rb')
with gzip.open(f, 'rt') as g:
	text = g.read()
```

Это позволяет модулям *gzip* и *bz2* работать с различными файлоподобными объектами, такими как сокеты, каналы и файлы в оперативной памяти.

## 5.8. Итерирование по записям фиксированного размера
### Задача
Вместо того, чтобы итерировать по файлу построчно, вы хотите итерировать по коллекции записей фиксированного размера или кусочкам (чанкам).

### Решение
Используйте функции *iter()* и *functools.partial()*, чтобы выполнить этот клёвый фокус:
```python
from functools import partial

RECORD_SIZE = 32

with open('somefile.data', 'rb') as f:
	records = iter(partial(f.read, RECORD_SIZE), b'')
	for r in records:
		...
```

Объект *records* в этом примере является итерируемым; он будет производить кусочки (чанки) фиксированного размера, пока не будет достигнут конец файла. Однако стоит отметить, что в последнем элементе может быть на несколько байтов меньше, чем ожидается, если размер файла не делится на точную длину размера записи.

### Обсуждение
Малоизвестная возможность функции *iter()* заключается в том, что она може создать итератор, если вы передадите ей вызываемый объект и «значение-страж» (пороговое). Получившийся итератор просто снова и снова вызывает предоставленный вызываемый объект, пока он не вернет значение-страж, что приведёт к завершению итерирования.

В вышеприведённом решении *functools.partial* используется для создания вызываемого объекта, который читает фиксированное количествт байтов из файла каждый раз, когда вызывается. Страж *b''* — то, что будет возвращено при попытке чтения файла, когда будет достигнут его конец.

И последнее: в показанном выше решении файл был открыт в бинарном режиме. Для чтений записей фиксированного размера это является наиболее распространенным случаем. В случае же текстовых файлов более распространенным будет построчное чтение (итератор выполняет его по умолчанию). 

## 5.9. Чтение бинарных данных в изменяемый (мутабельный) буфер
### Задача
Вы хотите читать бинарные данные непосредственно в изменяемый буфер без какого-либо промежуточного копирования. Возможно, вы хотите изменить данные на месте и записать их обратно в файл.

### Решение
Чтобы прочесть данные в изменяемый массив, используйте файловый метод *readinto()*. Например:
```python
import os.path

def read_into_buffer(filename):
	buf = bytearray(os.path.getsize(filename))
	with open(filename, 'rb') as f:
		f.readinto(buf)
	return buf
```

Вот пример использования:
```python
>>> # Write a sample file
>>> with open('sample.bin', 'wb') as f:
...		f.write(b'Hello World')
...
>>> buf = read_into_buffer('sample.bin')
>>> buf
bytearray(b'Hello World')
>>> buf[0:5] = b'Hallo'
>>> buf
bytearray(b'Hallo World')
>>> with open('newsample.bin', 'wb') as f:
...		f.write(buf)
...
11
>>>
```

### Обсуждение
Метод *readinto()* может быть использован для заполнения данными любого предварительно выделенного (preallocated) массива. Это даже включает массивы, созданные с помощью модуля *array* или библиотек типа *numpy*. В отличие от обычного метода *read()*, метод *readinto()* заполняет содержание текущего буфера вместо выделения и возвращения новых объектов. Так что вы можете использовать его, чтобы избежать излишних выделений памяти. Например, если вы читаете бинарный файл, состоящий из записей одинакового размера, вы можете написать такую программу:
```python
record_size = 32 	# Size of each record (adjust value)

buf = bytearray(record_size)
with open('somefile', 'rb') as f:
	while True:
		n = f.readinto(buf)
		if n < record_size:
			break
		# Use the contents of buf
		...
``` 

Ещё одна интересная возможность — функция memoryview(), которая позволяет делать срезы [zero-copy](https://ru.wikipedia.org/wiki/Zero-copy) существующего буфера, и даже менять его содержимое. Например:
```python
>>> buf
bytearray(b'Hello World')
>>> m1 = memoryview(buf)
>>> m2 = m1[-5:]
>>> m2
<memory at 0x100681390>
>>> m2[:] = b'WORLD'
>>> buf
bytearray(b'Hello WORLD')
>>>
```

При использовании метода *f.readinto()* нужно соблюдать осторожность: вы должны всегда проверять его код возврата, который является количеством фактически прочтённых байтов.

Если число байтов меньше размера предоставленного буфера, это может указывать на повреждение данных (например, если вы ожидали, что будет прочитано точное количество байтов).

И последнее: посмотрите на другие функции типа “into” в различных библиотечных модулях (например, *recv_into()*, *pack_into()* и т.д.) Многие другие компоненты Python имеют поддержку прямого ввода-вывода и доступа к данным, которая может быть использована для заполнения или изменения содержания массивов и буферов. 

См. **рецепт 6.12.** для значительно более продвинутого примера интерпретации бинарных структур и использования просмотрщиков памяти (memoryviews). 

## 5.10. Отображаемые в память бинарные файлы
### Задача
Вы хотите отобразить в память бинарный файл в форме изменяемого массива байтов — вероятно, для произвольного доступа к его содержимому или изменений прямо на месте.

### Решение
Используйте модуль *mmap* для отображения файлов в память. Вот полезная функция, с помощью которой можно открыть файл и отобразить его в память переносимым способом:
```python
import os
import mmap

def memory_map(filename, access=mmap.ACCESS_WRITE):
	size = os.path.getsize(filename)
	fd = os.open(filename, os.O_RDWR)
	return mmap.mmap(fd, size, access=access)
```

Чтобы использовать эту функцию, вам нужен уже созданный и наполненный данными файл. Вот пример того, как вы можете сначала создать файл и увеличить его до нужного размера:
```python
>>> size = 1000000
>>> with open('data', 'wb') as f:
...		f.seek(size-1)
...		f.write(b'\x00')
...
>>>
```

А вот пример отображения содержимого в память с помощью функции *memory_map()*:
```python
>>> m = memory_map('data')
>>> len(m)
1000000
>>> m[0:10]
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
>>> m[0]
0
>>> # Reassign a slice
>>> m[0:11] = b'Hello World'
>>> m.close()

>>> # Verify that changes were made
>>> with open('data', 'rb') as f:
... 	print(f.read(11))
...
b'Hello World'
>>>
``` 

Объект *mmap*, возвращаемый функцией *mmap()*, может быть также использован в качестве менеджера контекста. В это случае отображенный файл закрывается автоматически. Например:
```python
>>> with memory_map('data') as m:
... 	print(len(m))
...		print(m[0:10])
...
1000000
b'Hello World'
>>> m.closed
True
>>>
```

По умолчанию показанная функция *memory_map()* открывает файл и на чтение, и на запись. Любые изменения данных копируются в исходный файл. Если требуется организовать доступ только для чтения, предоставьте *mmap.ACCESS_READ* в качестве аргумента *access*. Например:
```python
m = memory_map(filename, mmap.ACCESS_READ)
```  

Если вы намерены локально изменять данные, но не хотите, чтобы изменения записывались в исходный файл, используйте *mmap.ACCESS_COPY*:
```python
m = memory_map(filename, mmap.ACCESS_COPY)
```

### Обсуждение
Использование *mmap* для отображения файлов в память может элегантным и эффективным решением для произвольного доступа к содержимому файла. Например, вместо открытия файла и выполнения различных комбинаций вызовов *seek()*, *read()* и *write()*, вы просто отображаете файл и получаете доступ к любым данным через операции извлечения срезов.

Обычно память, выделяемая *mmap()*, выглядить как объект *bytearray*. Однако вы можете интерпретировать данные по-разному, используя функцию *memoryview*. Например:
```python
>>> m = memory_map('data')
>>> # Memoryview of unsigned integers
>>> v = memoryview(m).cast('I')
>>> v[0] = 7
>>> m[0:4]
b'\x07\x00\x00\x00'
>>> m[0:4] = b'\x07\x01\x00\x00'
>>> v[0]
263
>>>
```

Стоит отметить, что отображение файла в память не вызывает чтения файла в память целиком. Он не копируется в некий буфер памяти или массив. Вместо этого операционная система выделяет участок виртуальной памяти под содержимое файла. По мере того, как вы обращаетесь к различным участкам, эти куски файла будут читаться и отображаться в участок памяти по мере необходимости. Однако части файла, к которым никогда не производился доступ, останутся на диске.

Если более чем один интерпретатор Python отображает в память один и тот же файл, получившийся объект *mmap* может быть использован для обмена данными между интерпретаторами. Интерпретаторы могут читать и записывать данные одновременно, и изменения, которые были сделаны в одном интерпретаторе, автоматически будут доступны в других. Очевидно, что синхронизация требует дополнительного внимания, но этот подход иногда используется в качестве альтернативы передаче данных через каналы или сокеты. 

Показанный выше рецепт написан максимально обобщённо, он работает и в Windows, и в Unix. Однако стоит отметить, что есть специфические для каждой платформы отличия в том, как работает *mmap()* «под капотом». Также есть возможности по созданию анонимно отображенных участков памяти. Если вас это интересует, прочтите [соответствующую документацию](http://docs.python.org/3/library/mmap.html) Python.
 

## 5.11. Манипулирование путями к файлам
### Задача
Вам нужно манипулировать путями к файлам, чтобы найти имя файла, название каталога, абсолютный путь и т.д.

### Решение
Для работы с файловыми путями используйте функции из модуля *os.path*. Вот пример, который иллюстрирует несколько ключевых возможностей:
```python
>>> import os
>>> path = '/Users/beazley/Data/data.csv'

>>> # Get the last component of the path
>>> os.path.basename(path)
'data.csv'

>>> # Get the directory name
>>> os.path.dirname(path)
'/Users/beazley/Data'

>>> # Join path components together
>>> os.path.join('tmp', 'data', os.path.basename(path))
'tmp/data/data.csv'

>>> # Expand the user's home directory
>>> path = '~/Data/data.csv'
>>> os.path.expanduser(path)
'/Users/beazley/Data/data.csv'

>>> # Split the file extension
>>> os.path.splitext(path)
('~/Data/data', '.csv')
>>>
```

### Обсуждение
Для любых манипуляций с именами файлов вы должны использовать модуль *os.path*, а не изобретать собственный велосипед из стандартных строковых операций. Во-первых, это важно для переносимости. Модуль *os.path* понимает различия между *Unix* и *Windows* и может надёжно работать с именами Data/data.csv и Data\data.csv. Во-вторых, вы не должны тратить время на велосипедостроение. Обычно лучше использовать готовые решения. 

Стоит отметить, что в модуле *os.path* намного больше возможностей, чем показано в этом рецепте. Обратитесь к документации, чтобы узнать о функциях для тестирования файлов, работы с символическими ссылками и т.д.

## 5.12. Проверка существования файла
### Задача
Вам нужно выяснить, существует ли файл или каталог.

### Решение
Используйте *os.path*, чтобы проверить существование файла или каталога. Например:
```python
>>> import os
>>> os.path.exists('/etc/passwd')
True
>>> os.path.exists('/tmp/spam')
False
>>>
``` 

Вы можете выполнить дополнительные тесты, чтобы проверить тип файла. Эти проверки возвращают *False*, если файл не существует:
```python
>>> # Is a regular file
>>> os.path.isfile('/etc/passwd')
True

>>> # Is a directory
>>> os.path.isdir('/etc/passwd')
False

>>> # Is a symbolic link
>>> os.path.islink('/usr/local/bin/python3')
True

>>> # Get the file linked to
>>> os.path.realpath('/usr/local/bin/python3')
'/usr/local/bin/python3.3'
>>>
```

Если вам нужно получить метаданные (например, размер или дату изменения файла), это тоже можно сделать с помощью модуля *os.path*:
```python
>>> os.path.getsize('/etc/passwd')
3669
>>> os.path.getmtime('/etc/passwd')
1272478234.0
>>> import time
>>> time.ctime(os.path.getmtime('/etc/passwd'))
'Wed Apr 28 13:10:34 2010'
>>>
```

### Обсуждение
Проверка файлов с помощью *os.path* становится очень простой операцией. Единственное, о чем стоит помнить, так это о разрешениях — особенно при операциях получения метаданных. Например:
```python
>>> os.path.getsize('/Users/guido/Desktop/foo.txt')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "/usr/local/lib/python3.3/genericpath.py", line 49, in getsize
		return os.stat(filename).st_size
PermissionError: [Errno 13] Permission denied: '/Users/guido/Desktop/foo.txt'
>>>
``` 

## 5.13. Получение содержимого каталога
### Задача
Вы хотите получить список файлов, содержащихся в каталоге файловой системы. 

### Решение
Используйте функцию *os.listdir()* для получения списка файлов в каталоге:
```python
import os
names = os.listdir('somedir')
```

Вы получите «сырой» список содержимого каталога, включающий все файлы, подкаталоги, символические ссылки и т.п. Если вам нужно как-то отфильровать эти данные, используйте генератор списков вместе с различными функциями библиотеки *os.path()*. Например:
```python
import os.path
# Get all regular files
names = [name for name in os.listdir('somedir')
		 if os.path.isfile(os.path.join('somedir', name))]

# Get all dirs
dirnames = [name for name in os.listdir('somedir')
			if os.path.isdir(os.path.join('somedir', name))]
```

Строковые методы *startswith()* и *endswith()* также могут быть полезны для фильтрации содержимого каталога. Например:
```python
pyfiles = [name for name in os.listdir('somedir')
		   if name.endswith('.py')]
```

Для поиска совпадений по имени файла вы можете использовать модули *glob* или *fnmatch*. Например:
```python
import glob
pyfiles = glob.glob('somedir/*.py')

from fnmatch import fnmatch
pyfiles = [name for name in os.listdir('somedir')
		   if fnmatch(name, '*.py')]
```

### Обсуждение
Получить содержимое каталога просто, но эта операция даёт вам просто имена элементов в каталоге. Если вы хотите получить дополнительные метаданные, такие как размеры файлов, даты изменений и т.д., вам нужны либо дополнительные функции модуля *os.path*, либо функция *os.stat()*. Например:
```python
# Example of getting a directory listing

import os
import os.path
import glob

pyfiles = glob.glob('*.py')

# Get file sizes and modification dates
name_sz_date = [(name, os.path.getsize(name), os.path.getmtime(name))
				for name in pyfiles]

for name, size, mtime in name_sz_date:
	print(name, size, mtime)

# Alternative: Get file metadata
file_metadata = [(name, os.stat(name)) for name in pyfiles]
for name, meta in file_metadata:
	print(name, meta.st_size, meta.st_mtime)
``` 

И последнее: в работе с именами файлов есть тонкие моменты, связанные с кодировками. Обычно записи, возвращаемые функциями типа *os.listdir()*, декодируются согласно установленной по умолчанию в системе кодировки имен файлов. Однако возможно, что при некоторых обстоятельствах вам придётся столкнуться с недекодируемыми именами файлов. Рецепты **5.14.** и **5.15.** содержат дополнительную информацию о работе с такими именами.  

## 5.14. Обход кодировки имен файлов
### Задача
Вы хотите выполнить операции ввода-вывода, используя «сырые» имена файлов, которые не декодируются и не кодируются с помощью системной кодировки имён файлов по умолчанию.

### Решение
По умолчанию все имена файлов кодируются и декодируются согласно кодировке, возвращаемой *sys.getfilesystemencoding()*. Например:
```python
>>> sys.getfilesystemencoding()
'utf-8'
>>>
``` 

Если вы по какой-то причине хотите обойти эту кодировку, определите имя файла, используя «сырую» строку байтов. Например:
```python
>>> # Write a file using a unicode filename
>>> with open('jalape\xf1o.txt', 'w') as f:
...		f.write('Spicy!')
...
6
>>> # Directory listing (decoded)
>>> import os
>>> os.listdir('.')
['jalapeño.txt']

>>> # Directory listing (raw)
>>> os.listdir(b'.') # Note: byte string
[b'jalapen\xcc\x83o.txt']

>>> # Open file with raw filename
>>> with open(b'jalapen\xcc\x83o.txt') as f:
...		print(f.read())
...
Spicy!
>>>
``` 

Как вы можете видеть в двух последних операциях, обращение с именами файлов немного меняется, когда байтовые строки передаются связанными с файлами функциям, таким как *open()* и *os.listdir()*.

### Обсуждение
В обычных обстоятельствах вам не нужно волноваться о кодировании и декодировании имён файлов — обычные операции с именами файлов просто работают. Однако многие операционные системы могут позволить пользователю случайно или по злому умыслу создать файлы, которые не соответствуют ожидаемым правилам кодировки. Такие имена файлов могут загадочным образом сломать программы на Python, которые работают с большим количеством файлов.

Чтение каталогов и работа с именами файлов как сырыми недекодированными байтами может решить эту проблему, хотя и за счёт некоторых неудобств при программировании. 

См. **рецепт 5.15.** о выводе недекодируемых имён файлов. 

## 5.15. Вывод «плохих» имён файлов
### Задача
Ваша программа получила список содержимого каталога, но когда она попыталась вывести эти имена файлов, то упала с исключением *UnicodeEncodeError* и загадочным сообщением “surrogates
not allowed”. 

### Решение
При выводе имен файлов неизвестного происхождения, используйте конвертирование для избежания ошибок:
```python
def bad_filename(filename):
	return repr(filename)[1:-1]

try:
	print(filename)
except UnicodeEncodeError:
	print(bad_filename(filename))
``` 

### Обсуждение
Этот рецепт решает редкую, но очень раздражающую проблему, которая касается программ, работающих с файловой системой. По умолчанию Python предполагает, что все имена файлов закодированы согласно установке, которая возвращается функцией *sys.getfilesystemencoding()*. Однако некоторые файловые системы не заставляют соблюдать это ограничение, позволяя создавать файлы с неправильной кодировкой. Это не частый случай, но все есть опасность, что некий юзер сделает что-то глупое и случайно создаст такой файл (например, передаст неправильное имя файла функции *open()* в какой-то забагованной программе). 

При выполнении команд типа *os.listdir()* неправильные имена файлов загоняют Python в безвыходную ситуацию. С одной стороны, он не может просто отбросить неправильное имя. С другой стороны, он не может превратить имя файла в правильную текстовую строку. Python действует так: берет недекодируемое байтовое значение \\xhh в имени файла и отображает его в так называемую «суррогатную кодировку», представленную символом Unicode \\udchh. Вот пример того, как неправильный список содержимого каталога может выглядеть, если он содержит имя файла bäd.txt, закодированное в Latin-1 вместо UTF-8:
```python
>>> import os
>>> files = os.listdir('.')
>>> files
['spam.py', 'b\udce4d.txt', 'foo.txt']
>>>
```

Если у вас есть код, который манипулирует именами файлов или даже передает их функциям (таким как *open()*), всё работает нормально. Вы попадете в неприятности только в ситуациях, где вы хотите вывести имя файла (вывод, логирование и т.п.) Ваша программа упадет, если вы захотите вывести показанный выше листинг:
```python
>>> for name in files:
...		print(name)
...
spam.py
Traceback (most recent call last):
	File "<stdin>", line 2, in <module>
UnicodeEncodeError: 'utf-8' codec can't encode character '\udce4' in
position 1: surrogates not allowed
>>>
```

Причина падения в том, что символ \\udce4 не является валидным Unicode. Это вторая половина двухсимвольной комбинации, известной как «суррогатная пара». Поскольку первая часть отсутствует, это не валидный Unicode. Поэтому единственный способ успешно произвести вывод — предпринять корректирующее действие, если встретится неправильно имя файла. Например:
```python
>> for name in files:
...		try:
...			print(name)
...		except UnicodeEncodeError:
...			print(bad_filename(name))
...
spam.py
b\udce4d.txt
foo.txt
>>>
```

Выбор того, что будет делать функция *bad_filename()*, во многом зависит от вас. Другая возможность — как-то перекодировать значение:
```python
def bad_filename(filename):
	temp = filename.encode(sys.getfilesystemencoding(), errors='surrogateescape')
	return temp.decode('latin-1')
``` 

При использовани этой версии вы получите следующее:
```python
>>> for name in files:
...		try:
...			print(name)
...		except UnicodeEncodeError:
...			print(bad_filename(name))
...
spam.py
bäd.txt
foo.txt
>>>
```

Этот рецепт наверняка будет проигнорирован большинством читателей. Однако если вы пишете критически важные скрипты, которым нужно надёжно работать с именами файлов и файловой системой, об этом стоит подумать. В противном случае вы можете столкнуться с ситуацией, когда вам придется тащиться в офис на выходных и сражаться с какой-то непонятной ошибкой.

## 5.16. Добавление или изменение кодировки уже открытого файла
### Задача
Вы хотите добавить или изменить кодировку Unicode уже открытого файла, не закрывая его.

### Решение
Если вы хотите добавить кодирование/декодирование в Unicode уже существующему файловому объекту, открытому в бинарном режиме, оберните его объектом *io.TextIOWrapper()*. Например:
```python
import urllib.request
import io

u = urllib.request.urlopen('http://www.python.org')
f = io.TextIOWrapper(u,encoding='utf-8')
text = f.read()
``` 

Если вы хотите изменить кодировку файла, открытого в текстовом режиме, используйте метод *detach()* для удаления существующего слоя текстовой кодировки перед заменой его новым. Вот пример изменения кодировки в *sys.stdout*:
```python
>>> import sys
>>> sys.stdout.encoding
'UTF-8'
>>> sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='latin-1')
>>> sys.stdout.encoding
'latin-1'
>>>
```

Если вы это сделаете, то можете «поломать» вывод вашего терминала. Приведенный выше пример — это просто иллюстрация подхода.

### Обсуждение
Система ввода-вывода построена на последовательности слоёв. Вы можете увидеть эти слои, если попробуете сделать следующее:
```python
>>> f = open('sample.txt','w')
>>> f
<_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'>
>>> f.buffer
<_io.BufferedWriter name='sample.txt'>
>>> f.buffer.raw
<_io.FileIO name='sample.txt' mode='wb'>
>>>
``` 

В этом примере *io.TextIOWrapper* — это слой для обработки текста, который кодирует и декодирует в Unicode, *ioBufferedWriter* — буферизированный слой ввода-вывода, который работает с бинарными данными, а *ioFileIO* — «сырой файл», представляющий низкоуровневый файловый дескриптор в операционной системе. Добавление или изменение текстовой кодировки вовлекает добавление и изменение только верхнего слоя — *io.TextIOWrapper*.

Общее правило: небезопасно напрямую манипулировать слоями, используя показанные выше атрибуты. Например, вот что произойдет, если вы попытаетесь изменить кодировку с помощью этого приёма:
```python
>>> f
<_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'>
>>> f = io.TextIOWrapper(f.buffer, encoding='latin-1')
>>> f
<_io.TextIOWrapper name='sample.txt' encoding='latin-1'>
>>> f.write('Hello')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file.
>>>
```

Это не работает, посколько изначальное значение *f* было уничтожено, а «лежащий под ним» файл закрыт. 

Метод *detach()* отделяет верхний слой файла и возвращает следующий, более низкоуровневый слой. Далее высший слой уже нельзя использовать. Например: 
```python
>>> f = open('sample.txt', 'w')
>>> f
<_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'>
>>> b = f.detach()
>>> b
<_io.BufferedWriter name='sample.txt'>
>>> f.write('hello')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
ValueError: underlying buffer has been detached
>>>
```

После отделения, однако, вы можете добавить новый верхний слой возвращаемому результату. Например:
```python
>>> f = io.TextIOWrapper(b, encoding='latin-1')
>>> f
<_io.TextIOWrapper name='sample.txt' encoding='latin-1'>
>>>
```

Хотя здесь мы показали изменение кодировки, этот приём может быть использован для изменения обработки строк, политики обработки ошибок и других аспектов работы с файлами. Например:
```python
>>> sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='ascii',
...		errors='xmlcharrefreplace')
>>> print('Jalape\u00f1o')
Jalape&#241;o
>>>
```

Отметьте, как не входящий в ASCII символ ñ был заменён на \&#241; в выводе.

## 5.17. Запись байтов в текстовый файл
### Задача
Вы хотите записать сырые байты в файл, открытый в текстовом режиме.

### Решение
Просто запишите байтовые данные в *buffer*. Например:
```python
>>> import sys
>>> sys.stdout.write(b'Hello\n')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: must be str, not bytes
>>> sys.stdout.buffer.write(b'Hello\n')
Hello
5
>>>
```

Похожим образом бинарные данные могут быть прочитаны из текстового файла путём чтения из атрибута *buffer*.

### Обсуждение
Система ввода-вывода построена на слоях. Текстовые файлы конструируются путём добавления слоя кодирования/декодирования в Unicode поверх буферизованного файла, открытого в бинарном режиме. Атрибут *buffer* просто ссылается на этот файл. Если вы обращаетесь к нему, то обходите слой текстового кодирования/декодирования.

Пример с *sys.stdout* может быть рассмотрен как особый случай. По умолчанию *sys.stdout* всегда открывается в текстовом режиме. Однако если вы пишите скрипт, которому на самом деле нужно сбрасывать бинарные данные в стандартный вывод, вы можете использовать показанный приём для обхода текстовой кодировки.

## 5.18. Оборачивание существующего дескриптора файла для использования в качестве объекта файла
### Задача
У вас есть целочисленный файловый дескриптор, соответствующий уже открытому каналу ввода-вывода операционной системы (например, файлу, каналу, сокету и т.п.), и вы хотите обернуть его высокоуровневым объектом файла Python.

### Решение
Файловый дескриптор отличается от обычного открытого файла тем, что это просто целочисленный идентификатор, назначенный операционной системой, чтобы ссылаться на какой-то системный канал ввода-вывода. Если у вас есть дескриптор, вы можете обернуть его файловым объектом Python с помощью функции *open()*. Вы просто предоставляете целочисленный файловый дескриптор в качестве первого аргумента (вместо имени файла). Например:
```python
# Open a low-level file descriptor
import os
fd = os.open('somefile.txt', os.O_WRONLY | os.O_CREAT)

# Turn into a proper file
f = open(fd, 'wt')
f.write('hello world\n')
f.close()
```

Когда высокоуровневый файловый объект закрывается или разрушается, его файловый дескриптор тоже будет закрыт. Если это нежелательное поведение, передайте необязательный аргумент *closefd=False* функции *open()*. Например:
```python
# Create a file object, but don't close underlying fd when done
f = open(fd, 'wt', closefd=False)
...
```

### Обсуждение
В Unix этот приём оборачивания файлового дескриптора может быть удобным способом для подключения файлоподобного интерфейса на существующий канал ввода-вывода, открытый другим способом (например, каналы, сокеты и т.д.) Вот пример с использованием сокетов:
```python
from socket import socket, AF_INET, SOCK_STREAM

def echo_client(client_sock, addr):
	print('Got connection from', addr)

	# Make text-mode file wrappers for socket reading/writing
	client_in = open(client_sock.fileno(), 'rt', encoding='latin-1',
					 closefd=False)
	client_out = open(client_sock.fileno(), 'wt', encoding='latin-1',
					  closefd=False)

	# Echo lines back to the client using file I/O
	for line in client_in:
		client_out.write(line)
		client_out.flush()
	client_sock.close()

def echo_server(address):
	sock = socket(AF_INET, SOCK_STREAM)
	sock.bind(address)
	sock.listen(1)
	while True:
		client, addr = sock.accept()
		echo_client(client, addr)
```

Важно подчеркнуть, что вышеприведённый пример нужен только для иллюстрации возможности встроенной функции *open()*, и он работает только в Unix. Если вы пытаетесь накрутить файлоподобный интерфейс на сокет, и вы хотите, чтобы ваш код был кроссплатформенным, используйте метод сокетов *makefile()*. Однако если переносимость вас не беспокоит, вы можете обнаружить, что представленное выше решение обладает намного большей производительностью, нежели *makefile()*.

Вы таже можете использовать этот приём для создания псевдонима, который позволит уже открытому файлу использоваться немного другим способом, нежели тот, каким он был изначально открыт. Например, вот так вы можете создать файловый объект, который позволит выводить бинарные данные в *stdout* (который по умолчанию открыт в текстовом режиме):
```python
import sys
# Create a binary-mode file for stdout
bstdout = open(sys.stdout.fileno(), 'wb', closefd=False)
bstdout.write(b'Hello World\n')
bstdout.flush()
```

Хотя можно обернуть существующий файловый дескриптор и использовать его в качестве настоящего файла, обратите внимание, что не все файловые режимы могут поддерживаться, и что некоторые типы файловых дескрипторов могут обладать забавными побочными эффектами (особенно по отношению к обработке ошибок, условиям достижения конца файла и т.д.) Это поведение также может изменяться в зависимости от операционной системы. В частности, ни один из приведённых примеров примеров не будет работать за пределами Unix. Суть в том, что вам нужно тщательно тестировать свою реализацию, чтобы убедиться в том, что она работает так, как вы ожидаете. 

## 5.19. Создание временных файлов и каталогов
### Задача
Вам нужно создать временный файл или каталог, которые будут использоваться во время выполнения вашей программы. После, возможно, вы захотите, чтобы они были удалены.

### Решение
В модуле *tempfile* есть различные функции, которые помогут решить эту задачу. Чтобы создать безымянный временный файл, используйте *tempfile.TemporaryFile*:
```python
from tempfile import TemporaryFile

with TemporaryFile('w+t') as f:
	# Read/write to the file
	f.write('Hello World\n')
	f.write('Testing\n')

	# Seek back to beginning and read the data
	f.seek(0)
	data = f.read()

# Temporary file is destroyed
``` 

Также вы можете использовать файл таким образом:
```python
f = TemporaryFile('w+t')
# Use the temporary file
...
f.close()
# File is destroyed
```

Первый аргумент, передаваемый в *TemporaryFile()*, это режим файла: обычно для текстовых файлов это *w+t*, а для бинарных — *w+b*. Этот режим одновременно поддерживает чтение и запись, что в данном случае полезно, поскольку закрытие файла для смены режима его бы разрушило. *TemporaryFile()* дополнительно принимает те же аргументы, что и встроенная функция *open()*. Например:
```python
with TemporaryFile('w+t', encoding='utf-8', errors='ignore') as f:
	...
```

На большинстве Unix-систем файл, созданный функцией *TemporaryFile()*, является безымянным и даже не имеет местоположения в каталоге. Если вы хотите преодолеть это ограничение, используйте *NamedTemporaryFile()*. Например:
```python
from tempfile import NamedTemporaryFile

with NamedTemporaryFile('w+t') as f:
	print('filename is:', f.name)
	...

# File automatically destroyed
```

Здесь атрибут *f.name* открытого файла содержит имя временного файла. Это может быть полезно, если оно передается какой-то другой программе, которой нужно будет открыть этот файл. Как и в случае *TemporaryFile()*, получившийся файл будет автоматически уничтожен после закрытия. Если вы не хотите, чтобы это произошло, передайте в функцию именованный аргумент *delete=False*. Например:
```python
with NamedTemporaryFile('w+t', delete=False) as f:
	print('filename is:', f.name)
	...
```

Чтобы создать временный каталог, используйте *tempfile.TemporaryDirectory()*. Например:
```python
from tempfile import TemporaryDirectory
with TemporaryDirectory() as dirname:
	print('dirname is:', dirname)
	# Use the directory
	...
# Directory and all contents destroyed
```

### Обсуждение
Функции *TemporaryFile()*, *NamedTemporaryFile()* и *TemporaryDirectory()* — вероятно, самый удобный способ работы с временными файлами и каталогами, потому что они автоматически управляются со всеми шагами создания и последующей чистки. На низком уровне вы также можете использовать *mkstemp()* и *mkdtemp()* для создания временных файлов и каталогов:
```python
>>> import tempfile
>>> tempfile.mkstemp()
(3, '/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-/tmp7fefhv')
>>> tempfile.mkdtemp()
'/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-/tmp5wvcv6'
>>>
```

Однако эти функции не заботятся о последующем управлении. Например, функция *mkstemp()* просто возвращает сырой файловый дескриптор операционной системы и оставляет всю работу по превращению его в настоящий файл вам. Похожим образом вам нужно самостоятельно удалять файлы. 

Обычно временные файлы создаются в определенном операционной системой месте сохранения по умолчанию, такому как /var/tmp и т.п. Чтобы определить реальное место, используйте функцию *tempfile.gettempdir()*. Например:
```python
>>> tempfile.gettempdir()
'/var/folders/7W/7WZl5sfZEF0pljrEB1UMWE+++TI/-Tmp-'
>>>
```

Все функции, связанные с временными файлами, позволяют вам менять этот каталог, также как и принципы наименования, с помощью именованных аргументов *prefix*, *suffix* и *dir*. Например:
```python
>>> f = NamedTemporaryFile(prefix='mytemp', suffix='.txt', dir='/tmp')
>>> f.name
'/tmp/mytemp8ee899.txt'
>>>
```  

И последнее: модуль *tempfile()* создает временные файлы наиболее безопасным способом из всех возможных. Это включает предоставление доступа только текущему пользователю и предпринятие шагов, предотвращающих состояние гонки (race condition) при создании сайтов. Однако стоит знать, что на различных платформах этот модуль работает по-разному. Чтобы уточнить своё понимание, обратитесь к официальной [документации](http://docs.python.org/3/library/tempfile.html). 

## 5.20. Работа с последовательными портами
### Задача
Вы хотите читать и записывать данные в последовательный порт. Обычно это нужно для взаимодействия с каким-то устройством (например, роботом или сенсором).

### Решение
Хотя вы могли бы сделать это напрямую, используя примитивы ввода-вывода Python, лучшим выбором для последовательного взаимодействия является пакет [pySerial](http://pyserial.sourceforge.net). Начать работать с пакетом очень легко. Вы просто открываете последовательный порт:
```python
import serial
ser = serial.Serial('/dev/tty.usbmodem641',
					 baudrate=9600,
				     bytesize=8,
					 parity='N',
					 stopbits=1)
```

Имя устройства меняется в зависимости от типа устройства и операционной системы. Например, в Windows вы можете использовать устройство 0, 1 и так далее, чтобы открыть такие порты как COM0 и COM1. Когда они открыты, вы можете читать и записывать данные, используя вызовы *read()*, *readline()* и *write()*. Например:
```python
ser.write(b'G1 X50 Y50\r\n')
resp = ser.readline()
```

По большей части простой последовательный обмен данными весьма незамысловат.

### Обсуждение
Простая на первый взгляд, последовательная коммуникация все же может быть достаточно запутанной. Причина использовать пакеты типа pySerial в том, что они поддерживают продвинутые возможности (например, таймауты, контроль потока, сбрасывание буфера, хендшейкинг и т.п.) Например, если вы хотите включить RTS-CTS-хендшейкинг, просто передайте *Serial()* аргумент *rtscts=True*. У пакета отличная документация, поэтому нет смысла ее здесь пересказывать.

Помните, что весь ввод-вывод с использованием последовательных портов является бинарным. Поэтому убедитесь, что ваша программа использует байты, а не текст (или производит правильное кодирование/декодирование). Модуль *struct* может также оказаться полезным, если вам нужно будет создавать бинарные команды или пакеты.

## 5.21. Сериализация объектов Python
### Задача
Вам нужно сериализировать объект Python в поток байтов, чтобы вы смогли сохранить их в файл или базу данных, или же передать их по сети.

### Решение
Наиболее распространённый подход к сериализации данных — это использование модуля *pickle*. Чтобы сохранить объект в файл, сделайте так:
```python
import pickle

data = ... # Some Python object
f = open('somefile', 'wb')
pickle.dump(data, f)
``` 

Чтобы сохранить объект в строку, используйте *pickle.dumps()*:
```python
s = pickle.dumps(data)
```

Чтобы воссоздать объект из потока байтов (byte stream), используйте либо *pickle.load()*, либо *pickle.loads()*. Например:
```python
# Restore from a file
f = open('somefile', 'rb')
data = pickle.load(f)

# Restore from a string
data = pickle.loads(s)
```

### Обсуждение
Для большинства программ использование функций *dump()* и *load()* — всё, что требуется от модуля *pickle*. Он просто работает — с большинством типов данных Python и экземплярами ваших собственных классов. Если вы работаете с какой-либо библиотекой, которая позволяет вам делать такие вещи как сохранение и восстановление объектов Python в базах данных или передача объектов по сети, то очень велик шанс, что именно *pickle* используется для этого. 

*pickle* — это самоописывающаяся кодировка данных, специфическая для Python. Под самоописыванием мы подразумеваем, что сериализованные данные содержат информацию о начале и конце каждого объекта, а также и информацию об их типе. Поэтому вам не нужно переживать об определении формата записей — всё работает «из коробки». Например, при работе с несколькими объектами вы можете сделать так:
```python
>>> import pickle
>>> f = open('somedata', 'wb')
>>> pickle.dump([1, 2, 3, 4], f)
>>> pickle.dump('hello', f)
>>> pickle.dump({'Apple', 'Pear', 'Banana'}, f)
>>> f.close()
>>> f = open('somedata', 'rb')
>>> pickle.load(f)
[1, 2, 3, 4]
>>> pickle.load(f)
'hello'
>>> pickle.load(f)
{'Apple', 'Pear', 'Banana'}
>>>
```

Вы можете сериализировать функции, классы и экземпляры, однако получающиеся данные кодируют только имена ссылок на связанные объекты кода. Например:
```python
>>> import math
>>> import pickle.
>>> pickle.dumps(math.cos)
b'\x80\x03cmath\ncos\nq\x00.'
>>>
```

Когда данные десериализуются, то предполагается, что требуемый источник доступен. Модули, классы и функции будут автоматически импортированы при необходимости. Для приложений, где данные Python разделяются между интерпретаторами или разными компьютерами, это потенциально может оказаться проблемой, поскольку все машины должны иметь доступ к одному и тому же исходному коду.

```
*pickle.load() никогда нельзя использовать на данных из непроверенных источников. В качестве побочного эффекта загрузки, pickle автоматически загрузить модули и создаст экземпляры. Однако злоумышленник, который знает принцип работы pickle, может создать специальные данные, которые заставят Python выполнить произвольные системные команды. Так что pickle можно использовать только внутренними данными и интерпретаторами, которые могут каким-то образом проводит аутентификацию друг друга.*
```

Некоторые типы объектов не могут быть сериализованы. Это обычно те объекты, которые используют некоторое внешнее системное состояние — такие как открытые файлы, открытые сетевые соединения, треды, процессы, фреймы стека и т.д. Определенные пользователем классы могут иногда обойти эти ограничения, предоставляя методы *__getstate()__* и *__setstate()__*. Если они определены, *ickle.dump()* вызовет *__getstate()__*, чтобы получить объект, пригодный для сериализации. Похожим образом *__setstate()__* будет вызыван при десериализации. Чтобы проиллюстрировать возможности, вот класс, который внутри определяет тред, но при этом может быть сериализован и десериализован:
```python
# countdown.py
import time
import threading

class Countdown:
	def __init__(self, n):
		self.n = n
		self.thr = threading.Thread(target=self.run)
		self.thr.daemon = True
		self.thr.start()
	
	def run(self):	
		while self.n > 0:
			print('T-minus', self.n)
			self.n -= 1
			time.sleep(5)
		
	def __getstate__(self):
		return self.n

	def __setstate__(self, n):
		self.__init__(n)
``` 

Попробуйте применить *pickle*:
```python
>>> import countdown
>>> c = countdown.Countdown(30)
>>> T-minus 30
T-minus 29
T-minus 28
...

>>> # After a few moments
>>> f = open('cstate.p', 'wb')
>>> import pickle
>>> pickle.dump(c, f)
>>> f.close()
```

Теперь выйдите из Python и после перезапуска попробуйте вот это:
```python
>>> f = open('cstate.p', 'rb')
>>> pickle.load(f)
countdown.Countdown object at 0x10069e2d0>
T-minus 19
T-minus 18
...
```

Вы должны увидеть, как тред волшебным образом возрождается к жизни, поднимаясь на том же месте, где он был, когда вы его сериализовали. 

*pickle* не особенно эффективен для сериализации крупных структур данных, таких как бинарные массивы, созданные библиотеками типа *numpy* или модуля *array*. Если вы перемещаете большие объемы данных в массивах туда-сюда, вам лучше просто сохранять массивы в файлы или использовать более стандартизованную кодировку, такую как HDF5 (поддерживается не входящими в поставку Python библиотеками).

*pickle* по своей природе привязан к Python и исходному коду, потоэму вам не стоит использовать его для долговременного хранения данных. Например, если исходный код изменится, все ваши сохранённые данные могут поломаться и стать нечитаемыми. Если честно, для хранения данных в базах данных и архивных хранилищах, вам лучше использовать более стандартные кодировки, такие как XML, CSV или JSON. Они поддерживаются большим количеством языков программирования, и более адаптируемы к изменениям в вашем исходном коде.

И последнее: стоит помнить, что у *pickle* огромное количество различных параметров и хитрых случаев применения. В большинстве обычных ситуаций вам не нужно о них волноваться, но если вы создаете серьёзное приложение, использующее *pickle* для сериализации, не забудьте прочитать [официальную документацию](http://docs.python.org/3/library/pickle.html).

# 6. Кодирование и обработка данных
Основная тема этой главы — использование Python для обработки данных, представленных в различных типах распространенных форматов, таких как файлы CSV, JSON, XML и упакованные бинарные записи. В отличие от главы о структурах данных, здесь мы не будем фокусироваться на конкретных алгоритмах, а рассмотрим задачу получения данных из программы и передачи данных в программу.

## 6.1. Чтение и запись данных в формате CSV
### Задача
Вы хотите прочесть или записать данные в файл CSV. 

###Решение
Для большинства CSV-данных используйте библиотек *csv*. Предположим, например, что у вас есть данные о рынке акций в файле stocks.csv:
```
Symbol,Price,Date,Time,Change,Volume
"AA",39.48,"6/11/2007","9:36am",-0.18,181800
"AIG",71.38,"6/11/2007","9:36am",-0.15,195500
"AXP",62.58,"6/11/2007","9:36am",-0.46,935000
"BA",98.31,"6/11/2007","9:36am",+0.12,104800
"C",53.08,"6/11/2007","9:36am",-0.25,360900
"CAT",78.29,"6/11/2007","9:36am",-0.23,225400
``` 

Вот как вы могли бы прочитать данные в последовательность кортежей:
```python
import csv
with open('stocks.csv') as f:
	f_csv = csv.reader(f)
	headers = next(f_csv)
	for row in f_csv:
		# Process row
		...
```

В приведённым выше коде строке соответствует кортеж. Поэтому для доступа к определенному полю вам нужно использовать индексирование: row[0] — Symbol, row[4] — Change.

Поскольку такое индексирование часто может быть запутанным, вы можете захотеть использовать именованные кортежи. Например:
```python
from collections import namedtuple
with open('stock.csv') as f:
	f_csv = csv.reader(f)
	headings = next(f_csv)
	Row = namedtuple('Row', headings)
	for r in f_csv:
		row = Row(*r)
		# Process row
		...
```

Это позволит использовать заголовки колонок, такие как row.Symbol и row.Change вместо индексов. Стоит отметить, что это сработает только в том случае, если заголовки колонок являются валидными идентификаторами Python. Если это не так, вы должны будете обработать эти заголовки (например, заменить неподходящие символы подчеркиваниями и т.п.)

Еще одна альтернатива — прочесть данные в последовательность словарей. Чтобы это сделать, используйте такой код:
```python
import csv
with open('stocks.csv') as f:
	f_csv = csv.DictReader(f)
	for row in f_csv:
		# process row
		...
```

В этой версии вы можете обращаться к элементом каждой строки, используя заголовки строки. Например, row['Symbol'] или row['Change']. 

Чтобы записать данные в CSV, вы также можете использовать модуль *csv*, но создавая объект *writer*. Например:
```python
headers = ['Symbol','Price','Date','Time','Change','Volume']
rows = [('AA', 39.48, '6/11/2007', '9:36am', -0.18, 181800),
('AIG', 71.38, '6/11/2007', '9:36am', -0.15, 195500),
('AXP', 62.58, '6/11/2007', '9:36am', -0.46, 935000),
]

with open('stocks.csv','w') as f:
	f_csv = csv.writer(f)
	f_csv.writerow(headers)
	f_csv.writerows(rows)
``` 

Если у вас есть данные в форме последовательности словарей, сделайте так:
```python
headers = ['Symbol', 'Price', 'Date', 'Time', 'Change', 'Volume']
rows = [{'Symbol':'AA', 'Price':39.48, 'Date':'6/11/2007',
'Time':'9:36am', 'Change':-0.18, 'Volume':181800},
{'Symbol':'AIG', 'Price': 71.38, 'Date':'6/11/2007',
'Time':'9:36am', 'Change':-0.15, 'Volume': 195500},
{'Symbol':'AXP', 'Price': 62.58, 'Date':'6/11/2007',
'Time':'9:36am', 'Change':-0.46, 'Volume': 935000},
]

with open('stocks.csv','w') as f:
	f_csv = csv.DictWriter(f, headers)
	f_csv.writeheader()
	f_csv.writerows(rows)
```

### Обсуждение
Вы должны практически всегда предпочитать модуль *csv* ручному разрезанию и парсингу CSV-данных. Например, вы можете подумывать, что надо бы написать такой код:
```python
with open('stocks.csv') as f:
	for line in f:
		row = line.split(',')
		# process row
		...
```

Проблема такого подхода в том, что вам нужно разбираться с надоедливыми деталями. Например, если одно из полей окружено кавычками, вы должны будете их срезать. А если это закавыченное поле содержит запятую, код сломается, поскольку выдаст строку неверного размера. 

По умолчанию библиотека csv запрограммирована понимать правила кодирования CSV, которые используются Microsoft Excel. Это, вероятно, наиболее распространенный вариант, и он с высокой вероятностью обеспечит вам наилучшую совместимость. Однако вы можете свериться с документацией модуля *csv*, и там вы найдете настройки, которые помогут работать с кодировками другого формата (например, заменить символ-разделитель и т.п.) Например, если вы хотите прочесть данные, разделенные символами табуляции, используйте вот такой код:
```python
# Example of reading tab-separated values
with open('stock.tsv') as f:
	f_tsv = csv.reader(f, delimiter='\t')
	for row in f_tsv:
	# Process row
	...
``` 

Если вы читаете данные в CSV и конвертируете их в именованные кортежи, вам нужно быть аккуратными с валидацией заголовков колонок. Например, CSV-файл может иметь строку заголовка, содержащую невалидный символ: 
```python
Street Address,Num-Premises,Latitude,Longitude
5412 N CLARK,10,41.980262,-87.668452
```

Это при создании экземпляра *namedtuple* ошибку с исключением *ValueError*. Чтобы обойти проблему, вам может потребоваться почистить заголовки. Например, разобраться с невалидными символами с помощью регулярного выражения:
```python
import re
with open('stock.csv') as f:
	f_csv = csv.reader(f)
	headers = [ re.sub('[^a-zA-Z_]', '_', h) for h in next(f_csv) ]
	Row = namedtuple('Row', headers)
	for r in f_csv:
		row = Row(*r)
		# Process row
		...
```

Важно отметить, что модуль *csv* не пытается интерпретировать данные или конвертировать их в какой-то другой тип, нежели строку. Если такие конвертации нужны, их вам придется выполнить самостоятельно. Вот пример выполнения дополнительных преобразований типов на CSV-данных:
```python
col_types = [str, float, str, str, float, int]
with open('stocks.csv') as f:
	f_csv = csv.reader(f)
	headers = next(f_csv)
	for row in f_csv:
		# Apply conversions to the row items
		row = tuple(convert(value) for convert, value in zip(col_types, row))
		...
```

Альтернативный пример преобразования выбранных полей словарей:
```python
print('Reading as dicts with type conversion')
field_types = [ ('Price', float),
				('Change', float),
				('Volume', int) ]

with open('stocks.csv') as f:
	for row in csv.DictReader(f):
		row.update((key, conversion(row[key]))
			for key, conversion in field_types)
		print(row)
```

В общем, вам стоит быть осторожными с такими преобразованиями. В реальном мире в CSV-файлах часто попадаются отсутствующие поля, повреждённые данные и прочие проблемы, которые могут поломать преобразования типов. Так что если ваши данные не являются гарантированно безошибочными, об этом стоит помнить (например, вы можете добавить подходящую обработку исключений).

Наконец, если ваша цель — чтение CSV-данных для выполнения анализа данных и статистических расчётов, вы можете взглянуть на пакет [Pandas](http://pandas.pydata.org). *Pandas* включает удобную функцию *pandas.read_csv()*, которая загружает CSV-данные в объект *DataFrame*. Далее вы можете провести различные статистические расчёты, отфильровать данные и выполнить другие высокоуровневые операции. Пример вы можете найти в **рецепте 6.13.**

## 6.2. Чтение и запись в формате JSON
### Задача
Вы хотите прочитать или записать данные, закодированные в JSON (JavaScript Object Notation).

### Решение
Модуль *json* предоставляет простой способ кодировать и декодировать данные в JSON. Две главные функции — *json.dumps()* и *json.loads()* — соответствуют интерфейсу других библиотек для сериализации, таких как *pickle*. Вот как вы можете превратить структуру данных Python в JSON:
```python
import json

data = {
	'name' : 'ACME',
	'shares' : 100,
	'price' : 542.23
}

json_str = json.dumps(data)
```

А вот как можно превратить строку в JSON обратно в структуру данных Python:
```python
# Writing JSON data
with open('data.json', 'w') as f:
	json.dump(data, f)

# Reading data back
with open('data.json', 'r') as f:
	data = json.load(f)
``` 

### Обсуждение
Кодирование в JSON поддерживает базовые типы: *None*, *bool*, *int*, *float*, *str*, а также списки, кортежи и словари, содержащие эти типы. В случае словарей ключами должны быть строки (все нестроковые ключи будут преобразованы в строки во время кодирования). Чтобы соответствовать спецификации JSON, вы должны кодировать только списки и словари Python. Более того, для веб-приложений стандартной практикой является использование именно словарей в качестве объектов верхнего уровня. 

Формат JSON практически идентичен синтаксису Python, за исключением нескольких небольших изменений. Например, *True* отображается на *true*, *False* — на *false*, а *None* — на *null*. Вот пример того, как выглядят закодированные данные:
```python
>>> json.dumps(False)
'false'
>>> d = {'a': True,
...		'b': 'Hello',
...		'c': None}
>>> json.dumps(d)
'{"b": "Hello", "c": null, "a": true}'
>>>
```

Если вы хотите изучить данные, которые вы раскодировали из JSON, часто бывает трудно установить их структуру путём простого вывода — особенно если присутствует многоуровневая вложенность или большое количество различных полей. Чтобы справиться с этой задачей, попробуйте функцию *pprint()* из модуля *pprint*. Она расположит ключи в алфавитном порядке и выведет словарь в более понятном виде. Вот пример того, как вы можете симпатично вывести результаты поиска по Twitter:
```python
>>> from urllib.request import urlopen
>>> import json
>>> u = urlopen('http://search.twitter.com/search.json?q=python&rpp=5')
>>> resp = json.loads(u.read().decode('utf-8'))
>>> from pprint import pprint
>>> pprint(resp)
{'completed_in': 0.074,
 'max_id': 264043230692245504,
 'max_id_str': '264043230692245504',
 'next_page': '?page=2&max_id=264043230692245504&q=python&rpp=5',
 'page': 1,
 'query': 'python',
 'refresh_url': '?since_id=264043230692245504&q=python',
 'results': [{'created_at': 'Thu, 01 Nov 2012 16:36:26 +0000',
			  'from_user': ...
},
		  	 {'created_at': 'Thu, 01 Nov 2012 16:36:14 +0000',
			  'from_user': ...
		   	 },
			 {'created_at': 'Thu, 01 Nov 2012 16:36:13 +0000',
			  'from_user': ...
			 },
			 {'created_at': 'Thu, 01 Nov 2012 16:36:07 +0000',
			  'from_user': ...
			 }
			 {'created_at': 'Thu, 01 Nov 2012 16:36:04 +0000',
			  'from_user': ...
			 }],
	'results_per_page': 5,
	'since_id': 0,
	'since_id_str': '0'}
>>>
```

В обычном случае декодирование JSON создаст из предоставленных данных словари или списки. Если вы хотите создать другие объекты, передайте *objects_pair_hook* или *object_hook* функции *json.loads()*. Например, вы можете декодировать JSON-данные, сохраняя их порядок в *OrderedDict*:
```python
>>> s = '{"name": "ACME", "shares": 50, "price": 490.1}'
>>> from collections import OrderedDict
>>> data = json.loads(s, object_pairs_hook=OrderedDict)
>>> data
OrderedDict([('name', 'ACME'), ('shares', 50), ('price', 490.1)])
>>>
```

Вот как вы можете превратить словарь JSON в объект Python:
```python
>>> class JSONObject:
... 	def __init__(self, d):
...			self.__dict__ = d
...
>>>
>>> data = json.loads(s, object_hook=JSONObject)
>>> data.name
'ACME'
>>> data.shares
50
>>> data.price
490.1
>>>
```

В последнем примере созданный при декодировании JSON-данных словарь передается как единственный аргумент в *__init__()*. Далее вы можете использовать его, как хотите, в том числе и напрямую в качестве экземпляра словаря объекта.

Есть несколько параметров, которые могут быть полезны при кодировании в JSON. Если вы хотите, чтобы вывод был симпатично отформатирован, вы можете использовать аргумент *indent* функции *json.dumps()*. В этом случае вывод будет красиво выводиться — в формате, похожем на вывод фунции *pprint()*. Например:
```python
>>> print(json.dumps(data))
{"price": 542.23, "name": "ACME", "shares": 100}
>>> print(json.dumps(data, indent=4))
{
	"price": 542.23,
	"name": "ACME",
	"shares": 100
}
>>>
```

Если вы хотите, чтобы при выводе происходила сортировка ключей, используйте аргумент *sort_keys*:
```python
>>> print(json.dumps(data, sort_keys=True))
{"name": "ACME", "price": 542.23, "shares": 100}
>>>
```

Экземпляры в обычном случае не являются сериализуемыми. Например:
```python
>>> class Point:
... 	def __init__(self, x, y):
...			self.x = x
...			self.y = y
...
>>> p = Point(2, 3)
>>> json.dumps(p)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "/usr/local/lib/python3.3/json/__init__.py", line 226, in dumps
		return _default_encoder.encode(obj)
	File "/usr/local/lib/python3.3/json/encoder.py", line 187, in encode
		chunks = self.iterencode(o, _one_shot=True)
	File "/usr/local/lib/python3.3/json/encoder.py", line 245, in iterencode
		return _iterencode(o, 0)
	File "/usr/local/lib/python3.3/json/encoder.py", line 169, in default
		raise TypeError(repr(o) + " is not JSON serializable")
TypeError: <__main__.Point object at 0x1006f2650> is not JSON serializable
>>>
```

Если вы хотите сериализовать экземпляры, вы можете предоставить функцию, которая принимает экземпляр на вход и возвращает словарь, который может быть сериализован. Например:
```python
def serialize_instance(obj):
	d = { '__classname__' : type(obj).__name__ }
	d.update(vars(obj))
	return d
```

Если вы хотите получить экземпляр обратно, вы можете сделать это так:
```python
# Dictionary mapping names to known classes
classes = {
	'Point' : Point
}

def unserialize_object(d):
	clsname = d.pop('__classname__', None)
	if clsname:
		cls = classes[clsname]
		obj = cls.__new__(cls) # Make instance without calling __init__
			for key, value in d.items():
			setattr(obj, key, value)
			return obj
	else:
		return d
```

Вот пример того, как используются эти функции:
```python
>>> p = Point(2,3)
>>> s = json.dumps(p, default=serialize_instance)
>>> s
'{"__classname__": "Point", "y": 3, "x": 2}'
>>> a = json.loads(s, object_hook=unserialize_object)
>>> a
<__main__.Point object at 0x1017577d0>
>>> a.x
2
>>> a.y
3
>>>
```

В модуле *json* множество других возможностей для контролирования низкоуровневой интерпретации чисел, специальных значений (таких как NaN) и т.п. Обратитесь к [документации](http://docs.python.org/3/library/json.html) за подробностями.

## 6.3. Парсинг простых XML-данных
### Задача
Вы хотите извлечь данные из простого XML-документа.

### Решение
Модуль *xml.etree.ElementTree* может быть использован для извлечения данных из простых XML-документов. Чтобы продемонстрировать это, предположим, что вы хотите распарсить и подготовить выжимку RSS-фида [Planet Python](http://planet.python.org). Вот скрипт, который это сделает:
```python
from urllib.request import urlopen
from xml.etree.ElementTree import parse

# Download the RSS feed and parse it
u = urlopen('http://planet.python.org/rss20.xml')
doc = parse(u)

# Extract and output tags of interest
for item in doc.iterfind('channel/item'):
	title = item.findtext('title')
	date = item.findtext('pubDate')
	link = item.findtext('link')

	print(title)
	print(date)
	print(link)
	print()
```

Если вы запустите вышеприведённый скрипт, вывод будет примерно таким:
```python
Steve Holden: Python for Data Analysis
Mon, 19 Nov 2012 02:13:51 +0000
http://holdenweb.blogspot.com/2012/11/python-for-data-analysis.html

Vasudev Ram: The Python Data model (for v2 and v3)
Sun, 18 Nov 2012 22:06:47 +0000
http://jugad2.blogspot.com/2012/11/the-python-data-model.html

Python Diary: Been playing around with Object Databases
Sun, 18 Nov 2012 20:40:29 +0000
http://www.pythondiary.com/blog/Nov.18,2012/been-...-object-databases.html

Vasudev Ram: Wakari, Scientific Python in the cloud
Sun, 18 Nov 2012 20:19:41 +0000
http://jugad2.blogspot.com/2012/11/wakari-scientific-python-in-cloud.html

Jesse Jiryu Davis: Toro: synchronization primitives for Tornado coroutines
Sun, 18 Nov 2012 20:17:49 +0000
http://feedproxy.google.com/~r/EmptysquarePython/~3/_DOZT2Kd0hQ/
```

Очевидно, что если вы хотите провести дополнительную обработку, вам нужно заменить инструкции *print()* на что-то более интересное.

### Обсуждение
В очень многих приложениях нужно работать с XML-данными. XML не только широко используется в качестве формата для обмена данными через интернет, это также распространенный формат хранения данных приложений (обработка текста, музыкальные библиотеки и т.п.) Нижеследующее обсуждение подразумевает, что читатель уже знаком с основами XML.

Во многих случаях, когда XML просто используется для хранения данных, структура документа проста и прямолинейна. Например, RSS-поток из примера выглядит примерно так:
```xml
<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
	<title>Planet Python</title>
	<link>http://planet.python.org/</link>
	<language>en</language>
	<description>Planet Python - http://planet.python.org/</description>
	<item>
	  <title>Steve Holden: Python for Data Analysis</title>
		<guid>http://holdenweb.blogspot.com/...-data-analysis.html</guid>
		<link>http://holdenweb.blogspot.com/...-data-analysis.html</link>
		<description>...</description>
		<pubDate>Mon, 19 Nov 2012 02:13:51 +0000</pubDate>
 </item>
 <item>
	<title>Vasudev Ram: The Python Data model (for v2 and v3)</title>
	<guid>http://jugad2.blogspot.com/...-data-model.html</guid>
	<link>http://jugad2.blogspot.com/...-data-model.html</link>
	<description>...</description>
	<pubDate>Sun, 18 Nov 2012 22:06:47 +0000</pubDate>
	</item>
 <item>
	<title>Python Diary: Been playing around with Object Databases</title>
	<guid>http://www.pythondiary.com/...-object-databases.html</guid>
	<link>http://www.pythondiary.com/...-object-databases.html</link>
	<description>...</description>
	<pubDate>Sun, 18 Nov 2012 20:40:29 +0000</pubDate>
 </item>
...
</channel>
</rss>
```

Функция *xml.etree.ElementTree.parse()* парсит весь XML-документ в объект *document*. Далее вы можете использовать такие методы как *find()*, *iterfind()* и *findtext()* для поиска определённых XML-элементов. Аргументы этих функций — это имена определенных тегов, такие как *channel/item* или *title*.

Когда вы задаёте теги, вы должны принимать во внимание всю структуру документа. Каждая операция поиска препринимается относительно стартового элемента. Тег, который вы предоставляете каждой операции, также рассматривается относительно старта. В вышеприведённом примере вызов *doc.iterfind('channel/item')* найдёт все элементы “item” под элементом “channel”. *doc* представляет вершину документа (высший уровень — элемент “rss”). Последующие вызовы *item.findtext()* будут делаться относительно найденных элементов “item”.

Каждый элемент, представленный модулем *ElementTree*, имеет несколько основных атрибутов и методов, весьма полезных при парсинге. Атрибут *tag* содержит имя тега, атрибут *text* содержит замкнутый текст, а метод *get()* может быть использован для извлечения атрибутов (если они присутствуют). Например:
```python
>>> doc
<xml.etree.ElementTree.ElementTree object at 0x101339510>
>>> e = doc.find('channel/title')
>>> e
<Element 'title' at 0x10135b310>
>>> e.tag
'title'
>>> e.text
'Planet Python'
>>> e.get('some_attribute')
>>>
```  

Стоит отметить, что *xml.etree.ElementTree* — не единственный способ парсинга XML. Для более продвинутых приложений вы можете попробовать [lxml](http://pypi.python.org/pypi/lxml). Эта библиотека использует тот же интерфейс, что и *ElementTree*, так что вышеприведённые примеры будут работать так же. Вы просто должны изменить первую инструкцию import на *from lxml.etree import parse*. Библиотека *lxml* имеет преимущество в виде полного соответствия стандартам XML. Она также чрезвычайно быстро работает и предоставляет поддержку такиз возможностей как валидация, XSLT и XPath. 

## 6.4. Инкрементальный парсинг очень больших XML-файлов
### Задача
Вам нужно извлечь данные из огромного XML-документа, используя как можно меньше памяти.

### Решение
Каждый раз, когда вы сталкиваетесь с инкрементальной обработкой данных, вы должны вспоминать об итераторах и генераторах. Вот простая функция, которая может быть использована для инкрементальной обработки огромных XML-файлов при очень небольшом потреблении памяти:
```python
from xml.etree.ElementTree import iterparse

def parse_and_remove(filename, path):
	path_parts = path.split('/')
	doc = iterparse(filename, ('start', 'end'))
	# Skip the root element
	next(doc)

tag_stack = []
elem_stack = []
for event, elem in doc:
	if event == 'start':
		tag_stack.append(elem.tag)
		elem_stack.append(elem)
	elif event == 'end':
		if tag_stack == path_parts:
			yield elem
			elem_stack[-2].remove(elem)
		try:
			tag_stack.pop()
			elem_stack.pop()
		except IndexError:
			pass
```

Чтобы протестировать функцию, вам потребуется большой XML-файл. Часто такие файлы можно найти на государственных сайтах и ресурсах с открытой информацией. Например, вы можете скачать [базу данных выбоин на дорогах Чикаго](http://bit.ly/YQh2Oh) в формате XML. Когда писалась эта книга, этот файл состоял из более чем 100 000 строк данных, который были закодированы так:
```xml
<response>
	<row>
		<row ...>
			<creation_date>2012-11-18T00:00:00</creation_date>
			<status>Completed</status>
			<completion_date>2012-11-18T00:00:00</completion_date>
			<service_request_number>12-01906549</service_request_number>
			<type_of_service_request>Pot Hole in Street</type_of_service_request>
			<current_activity>Final Outcome</current_activity>
			<most_recent_action>CDOT Street Cut ... Outcome</most_recent_action>
			<street_address>4714 S TALMAN AVE</street_address>
			<zip>60632</zip>
			<x_coordinate>1159494.68618856</x_coordinate>
			<y_coordinate>1873313.83503384</y_coordinate>
			<ward>14</ward>
			<police_district>9</police_district>
			<community_area>58</community_area>
			<latitude>41.808090232127896</latitude>
			<longitude>-87.69053684711305</longitude>
			<location latitude="41.808090232127896"
					  longitude="-87.69053684711305" />
		/row>
		<row ...>
			<creation_date>2012-11-18T00:00:00</creation_date>
			<status>Completed</status>
			<completion_date>2012-11-18T00:00:00</completion_date>
			<service_request_number>12-01906695</service_request_number>
			<type_of_service_request>Pot Hole in Street</type_of_service_request>
			<current_activity>Final Outcome</current_activity>
			<most_recent_action>CDOT Street Cut ... Outcome</most_recent_action>
			<street_address>3510 W NORTH AVE</street_address>
			<zip>60647</zip>
			<x_coordinate>1152732.14127696</x_coordinate>
			<y_coordinate>1910409.38979075</y_coordinate>
			<ward>26</ward>
			<police_district>14</police_district>
			<community_area>23</community_area>
			<latitude>41.91002084292946</latitude>
			<longitude>-87.71435952353961</longitude>
			<location latitude="41.91002084292946"
					  longitude="-87.71435952353961" />
		</row>
	</row>
</response>
```

Предположим, что вы хотите написать скрипт, который отсортирует ZIP-коды по количеству отчётов о выбоинах. Чтобы сделать это, вы можете написать такой код:
```python
from xml.etree.ElementTree import parse
from collections import Counter

potholes_by_zip = Counter()

doc = parse('potholes.xml')
for pothole in doc.iterfind('row/row'):
	potholes_by_zip[pothole.findtext('zip')] += 1
for zipcode, num in potholes_by_zip.most_common():
	print(zipcode, num)
```

Единственная проблема с этим скриптом заключается в том, что он читает в память XML-файл целиком. На нашем компьютере при запуске он отъел 450 мегабайт оперативной памяти. Если же применить код из этого рецепта, программа изменится совсем чуть-чуть:
```python
rom collections import Counter
potholes_by_zip = Counter()

data = parse_and_remove('potholes.xml', 'row/row')
for pothole in data:
	potholes_by_zip[pothole.findtext('zip')] += 1

for zipcode, num in potholes_by_zip.most_common():
	print(zipcode, num)
```

При этом эта версия занимает при запуске всего 7 мегабайт оперативной памяти — огромная экономия налицо!

### Обсуждение
Этот рецепт основывается на двух базовых возможностях модуля *ElementTree*. Метод *iterparse()* позволяет обрабатывать XML-документы инкрементально. Чтобы использовать его, вы передаете имя файла вместе со списком событий, состоящим из одного или более следующих аргументов: *start*, *end*, *start-ns* и *end-ns*. Итератор, созданный *iterparse()*, производит кортежи формата *(event, elem)*, где *event* — одно из событий списка, а *elem* — полученный XML-элемент. Например:
```python
>>> data = iterparse('potholes.xml',('start','end'))
>>> next(data)
('start', <Element 'response' at 0x100771d60>)
>>> next(data)
('start', <Element 'row' at 0x100771e68>)
>>> next(data)
('start', <Element 'row' at 0x100771fc8>)
>>> next(data)
('start', <Element 'creation_date' at 0x100771f18>)
>>> next(data)
('end', <Element 'creation_date' at 0x100771f18>)
>>> next(data)
('start', <Element 'status' at 0x1006a7f18>)
>>> next(data)
('end', <Element 'status' at 0x1006a7f18>)
>>>
```

События *start* создаются, когда элемент создан, но еще не наполнен любыми другими данными (например, элементами-потомками). События *end* создаются, когда элемент завершен. Хотя в этом рецепте это и не показано, события *start-ns* и *end-ns* используются для работы с объявлениями пространств имён XML.

В этом рецепте события *start* и *end* используются для управления стеками элементов и тегов. Стеки представляют текущую иерархическую структуру документа в процессе его парсинга, а также используются для определения того, совпадает ли элемент с запрашиваемым путём, переданным в функцию *parse_and_remove()*. Если совпадение произошло, *yield* выдаёт его обратно вызывавшему. 

Следующая инструкция после *yield* — базовая возможность *Element.Tree*, которая позволяет этому рецепту экономить память:
```python
elem_stack[-2].remove(elem)
``` 

Эта инструкция удаляет выданный ранее элемент из его родителя. Предполагая, что нигде более на него не осталось ссылок, элемент уничтожается, а память высвобождается.

Конечный эффект итеративного парсинга и удаления узлов — крайне эффективный инкрементальный проход по документу. Ни на одном этапе не создается полное дерево документа. Однако возможно написать код, который обрабатывает XML-данные в прямолинейной манере.

Главный недостаток этого рецепта — производительность. При тестировании версия, которая читает весь документ в память отработала в 2 раза быстрее, чем инкрементальная. Однако она потребовала в 60 раз больше памяти. Так что если память важна, инкрементальный подход дает большой выигрыш. 


## 6.5. Преобразование словарей в XML
### Задача
Вы хотите взять данные из словаря Python и превратить их в XML.

### Решение
Хотя библиотека *xml.etree.ElementTree* обычно используется для парсинга, её также можно применить для создания XML-документов. Например, посмотрите на такую функцию:
```python
from xml.etree.ElementTree import Element

def dict_to_xml(tag, d):
	'''
	Turn a simple dict of key/value pairs into XML
	'''
	elem = Element(tag)
	for key, val in d.items():
		child = Element(key)
		child.text = str(val)
		elem.append(child)
	return elem
```

Вот пример её работы:
```python
>>> s = { 'name': 'GOOG', 'shares': 100, 'price':490.1 }
>>> e = dict_to_xml('stock', s)
>>> e
<Element 'stock' at 0x1004b64c8>
>>>
```

Результатом этого преобразования является экземпляр *Element*. Для ввода-вывода его можно легко конвертировать в байтовую строку — для этого нужно использовать функцию *tostring()* из модуля *xml.etree.ElementTree*. Например:
```python
>>> from xml.etree.ElementTree import tostring
>>> tostring(e)
b'<stock><price>490.1</price><shares>100</shares><name>GOOG</name></stock>'
>>>
```

Если вы хотите прикрепить атрибуты к элементу, используйте метод *set()*:
```python
>>> e.set('_id','1234')
>>> tostring(e)
b'<stock _id="1234"><price>490.1</price><shares>100</shares><name>GOOG</name>
</stock>'
>>>
```

Если порядок элементов имеет значение, подумайте над созданием *OrderedDict* вместо обычного словаря (см. **рецепт 1.7.**)

### Обсуждение
При генерации XML вы можете склоняться к простому созданию строк. Например:
```python
def dict_to_xml_str(tag, d):
	'''
	Turn a simple dict of key/value pairs into XML
	'''
	parts = ['<{}>'.format(tag)]
	for key, val in d.items():
		parts.append('<{0}>{1}</{0}>'.format(key,val))
		parts.append('</{}>'.format(tag))
	return ''.join(parts)
```

Проблема в том, что вы влезете в большие неприятности, если попытаетесь сделать это вручную. Например, что случится, если значение словаря содержат спецсимволы? Например:
```python
>>> d = { 'name' : '<spam>' }

>>> # String creation
>>> dict_to_xml_str('item',d)
'<item><name><spam></name></item>'

>>> # Proper XML creation
>>> e = dict_to_xml('item',d)
>>> tostring(e)
b'<item><name>&lt;spam&gt;</name></item>'
>>>
```

Обратите внимание, как в последнем примере символы < и > заменяются на \&lt; и \&gt;. 

Для справки: если вам когда-либо потребуется вручную экранировать или деэкранировать такие символы, мы можете использовать функции *escape()* и *unescape()* из модуля *xml.sax.saxutils*. Например:
```python
>>> from xml.sax.saxutils import escape, unescape
>>> escape('<spam>')
'&lt;spam&gt;'
>>> unescape(_)
'<spam>'
>>>
```

Если оставить в стороне создание правильного вывода, другая причина создавать экземпляры *Element* вместо строк заключается в том, что они могут быть легче объединены друг с другом создания более крупного документа. Получающиеся экземпляры *Element* также могут быть обработаны различными способами без необходимости парсить XML-текст. Вы можете провести всю обработку данных высокоуровневым способом, а затем в самом конце вывести их в строковой форме.

## 6.6. Парсинг, изменение и перезапись XML
### Задача
Вы хотите прочесть XML-документ, изменить его, а затем записать обратно как XML.

### Решение
Модуль *xml.etree.ElementTree* облегчает выполнение таких задач. Вы можете начать путем парсинга документа обычным способом. Предположим, например, что у вас есть документ под названием pred.xml, который выглядит так:
```xml
<?xml version="1.0"?>
<stop>
	<id>14791</id>
	<nm>Clark &amp; Balmoral</nm>
	<sri>
		<rt>22</rt>
		<d>North Bound</d>
		<dd>North Bound</dd>
	</sri>
	<cr>22</cr>
	<pre>
		<pt>5 MIN</pt>
		<fd>Howard</fd>
		<v>1378</v>
		<rn>22</rn>
	</pre>
	<pre>
		<pt>15 MIN</pt>
		<fd>Howard</fd>
		<v>1867</v>
		<rn>22</rn>
	</pre>
</stop>
```

Вот пример того, как можно использовать *ElementTree* для прочтения и документа и изменения его структуры:
```python
>>> from xml.etree.ElementTree import parse, Element
>>> doc = parse('pred.xml')
>>> root = doc.getroot()
>>> root
<Element 'stop' at 0x100770cb0>

>>> # Remove a few elements
>>> root.remove(root.find('sri'))
>>> root.remove(root.find('cr'))


# Insert a new element after <nm>...</nm>
>>> root.getchildren().index(root.find('nm'))
1
>>> e = Element('spam')
>>> e.text = 'This is a test'
>>> root.insert(2, e)


>>> # Write back to a file
>>> doc.write('newpred.xml', xml_declaration=True)
>>>
```

Результатом этих операций будет новый XML-файл, который выглядит так:
```python
<?xml version='1.0' encoding='us-ascii'?>
<stop>
	<id>14791</id>
	<nm>Clark &amp; Balmoral</nm>
	<spam>This is a test</spam>
	<pre>
		<pt>5 MIN</pt>
		<fd>Howard</fd>
		<v>1378</v>
		<rn>22</rn>
	</pre>
	<pre>
		<pt>15 MIN</pt>
		<fd>Howard</fd>
		<v>1867</v>
		<rn>22</rn>
	</pre>
</stop>
```

### Обсуждение
Изменение структуры XML-документа — незамысловатый процесс, но вы должны помнить, что все изменения в общем применяются к родительскому элементу, обращаясь с ним как со списком. Например, если вы уберете элемент, он будет убран из его непосредственного родителя путём использования метода *remove()* родителя. Если вы вставляете или добавляете новые элементы в конец, вы так же применяете методы *insert()* и *append()* к родителю. Также можно манипулировать элементами с помощью операций индексирования и извлечения среза, таких как *element[i]* или *element[j:j]*.  

Если вы хотите создать новые элементы, используйте класс *Element*, как показано в этом рецепте. Это также описано в **рецепте 6.5.**

## 6.7. Парсинг XML-документов с пространствами имён
### Задача
Вам нужно распарсить XML-документ, но он использует пространства имён XML.

### Решение
Предположим, что у нас есть документ, использующий пространства имён:
```xml
<?xml version="1.0" encoding="utf-8"?>
<top>
	<author>David Beazley</author>
		<content>
			<html xmlns="http://www.w3.org/1999/xhtml">
				<head>
					<title>Hello World</title>
				</head>
				<body>
					<h1>Hello World!</h1>
				</body>
			</html>
		</content>
</top>
```

Если вы парсите этот документ и пытаетесь выполнить обычные запросы, вы обнаружите, что это не работает так просто, поскольку всё становится невероятно многословным:
```python
>>> # Some queries that work
>>> doc.findtext('author')
'David Beazley'
>>> doc.find('content')
<Element 'content' at 0x100776ec0>

>>> # A query involving a namespace (doesn't work)
>>> doc.find('content/html')

>>> # Works if fully qualified
>>> doc.find('content/{http://www.w3.org/1999/xhtml}html')
<Element '{http://www.w3.org/1999/xhtml}html' at 0x1007767e0>

>>> # Doesn't work
>>> doc.findtext('content/{http://www.w3.org/1999/xhtml}html/head/title')

>>> # Fully qualified
>>> doc.findtext('content/{http://www.w3.org/1999/xhtml}html/'
... '{http://www.w3.org/1999/xhtml}head/{http://www.w3.org/1999/xhtml}title')
'Hello World'
>>>
```

Часто вы можете упростить дело путем оборачивания работы с пространством имён во вспомогательный класс:
```python
class XMLNamespaces:
	def __init__(self, **kwargs):
		self.namespaces = {}
		for name, uri in kwargs.items():
			self.register(name, uri)	
	def register(self, name, uri):
		self.namespaces[name] = '{'+uri+'}'
	def __call__(self, path):
		return path.format_map(self.namespaces)
``` 

Чтобы использовать этот класс, вы можете поступить так:
```python
>>> ns = XMLNamespaces(html='http://www.w3.org/1999/xhtml')
>>> doc.find(ns('content/{html}html'))
<Element '{http://www.w3.org/1999/xhtml}html' at 0x1007767e0>
>>> doc.findtext(ns('content/{html}html/{html}head/{html}title'))
'Hello World'
>>>
```

### Обсуждение
Парсинг XML-документов, содержащих пространства имён, может быть запутанным. Класс *XMLNamespaces* на самом деле предназначен для облегчения этого дела: он позволяет использовать сокращённые имена для пространств имён в последующих операциях, а не полные URI.

К несчастью, в базовом парсере *ElementTree* нет механизма для получения дополнительной информации о пространствах имён. Однако вы можете получить немного больше информации об области видимости обработки пространств имён, если будете использовать функцию *iterparse()*. Например:
```python
>>> from xml.etree.ElementTree import iterparse
>>> for evt, elem in iterparse('ns2.xml', ('end', 'start-ns', 'end-ns')):
... print(evt, elem)
...
end <Element 'author' at 0x10110de10>
start-ns ('', 'http://www.w3.org/1999/xhtml')
end <Element '{http://www.w3.org/1999/xhtml}title' at 0x1011131b0>
end <Element '{http://www.w3.org/1999/xhtml}head' at 0x1011130a8>
end <Element '{http://www.w3.org/1999/xhtml}h1' at 0x101113310>
end <Element '{http://www.w3.org/1999/xhtml}body' at 0x101113260>
end <Element '{http://www.w3.org/1999/xhtml}html' at 0x10110df70>
end-ns None
end <Element 'content' at 0x10110de68>
end <Element 'top' at 0x10110dd60>
# This is the topmost element
>>> elem
<Element 'top' at 0x10110dd60>
>>>
```

Последнее замечание: если текст, который вы парсите, использует пространства имён в дополнение к другим продвинутым возможностям XML, вам лучше перейти с *ElementTree* на библиотеку lxml. Например, она предоставляет улучшенную поддержку валидации документов по DTD, более полную поддержку XPath и другие продвинутые возможности. А этот рецепт — просто небольший фикс для облегчения парсинга. 

## 6.8. Взаимодействие с реляционной базой данных
### Задача
Вам нужно выбирать, вставлять или удалять строки в реляционной базе данных.

### Решение
Стандартный способ представления строк данных в Python — это последовательность кортежей. Например:
```python
stocks = [
	('GOOG', 100, 490.1),
	('AAPL', 50, 545.75),
	('FB', 150, 7.45),
	('HPQ', 75, 33.2),
]
```

Если данные представлены в такой форме, они относительно легко взаимодействуют с реляционной базой данных, используя стандартный API баз данных Python, как описано в [PEP 249](http://www.python.org/dev/peps/pep-0249). Суть API в том, что все операции с базой данных выполняются с помощью SQL-запросов. Каждая строка вводимых или выводимых даных представлена в форме кортежа.

Чтобы проиллюстрировать это, вы можете воспользоваться модулем *sqlite3*, который входит в стандартную поставку Python. Если вы используете другую базу данных (например, MySQL, Postgres, ODBC), вы должны будете установить стороннюю библиотеку. Однако программный интерфейс будет практически таким же, если не идентичным. 

Первый шаг — подсоединиться к базе данных. Обычно для этого нужно вызвать функцию *connect()* и передать ей такие параметры как имя базы данных, имя хоста, имя пользователя, пароль и т.п. Например:
```python
>>> import sqlite3
>>> db = sqlite3.connect('database.db')
>>>
```  

Чтобы что-то делать с данными, далее нужно создать курсор. Когда у вас есть курсор, вы можете начать выполнять SQL-запросы. Например:
```python
>>> c = db.cursor()
>>> c.execute('create table portfolio (symbol text, shares integer, price real)')
<sqlite3.Cursor object at 0x10067a730>
>>> db.commit()
>>>
```

Чтобы вставить последовательность строк в данные, используйте такую инструкцию:
```python
>>> c.executemany('insert into portfolio values (?,?,?)', stocks)
<sqlite3.Cursor object at 0x10067a730>
>>> db.commit()
>>>
```

Чтобы сделать запрос, используйте такую инструкцию:
```python
>>> for row in db.execute('select * from portfolio'):
... 	print(row)
...
('GOOG', 100, 490.1)
('AAPL', 50, 545.75)
('FB', 150, 7.45)
('HPQ', 75, 33.2)
>>>
``` 

Если вы хотите сделать запросы, которые принимают поставляемые пользователем входные параметры, убедитесь, что вы экранируете параметры, используя символ ?:
```python
>>> min_price = 100
>>> for row in db.execute('select * from portfolio where price >= ?',
						 (min_price,)):
... 	print(row)
...
('GOOG', 100, 490.1)
('AAPL', 50, 545.75)
>>>
```

### Обсуждение
На низком уровне взаимодействие с базой данных выполняется чрезвычайно прямолинейно. Вы просто формируете SQL-запросы и скармливаете их модулю, чтобы либо обновить информацию в базе, либо извлечь данные. Тем не менее, есть тонкие моменты, с которыми в некоторых случаях придётся разбираться.

Одно из возможных осложнений — отображение данных из базы на типы Python. Для записей типа дат наиболее частым случаем будет использование экземпляров *datetime* из одноимённого модуля, или системных таймстемпов с применением модуля *time*. Для числовых данных, и особенно финансовых данных, в которых применяются десятичные дроби, может применяться представление чисел как экземпляров *Decimal* из модуля *decimal*. К сожалению, конкретные принципы отображения варьируются в зависимости от бэкенда базы данных, так что вам придется почитать документацию.

Ещё одно критически важное осложнение касается формирования строк с инструкциями SQL. Вы никогда не должны использовать операторы форматирования строк Python (например, %) или метод *.format()* для создания таких строк. Если значения, предоставленные таким операторам форматирования, вводятся пользователями, это открывает вашу программу для SQL-инъекций (см. [http://xkcd.com/327](http://xkcd.com/327)). Специальный подменяющий символ ? в запросах требует от бэкенда базы данных использовать его собственный механизм подстановки строк, который (будем надеяться) сделает это безопасно.

К сожалению, существует некоторая разнородность в том, как бэкенды различных баз данных интерпретируют символы подстановки. Многие модули используют ? или %s, тогда как другие могут использовать другой символ, такой как :0 или :1, чтобы ссылаться на параметры. Вам нужно обратиться к документации используемого модуля базы данных. Аттрибут *paramstyle* модуля базы данных также содержит информацию о стиле использования кавычек.

Для простого взаимодействия с данными в таблице базы данных использование API базы данных обычно является несложным. Если вы делаете что-то более нетривиальное, имеет смысл использовать высокоуровневый интерфейс, такой как тот, что представляют объекто-реляционные отображатели (ORM). Библиотеки типа [SQLAlchemy](http://www.sqlalchemy.org) позволяют таблицам базы данных быть описанными как классы Python, и выполнять операции с базами данных, скрывая весь «подкапотный» SQL.

## 6.9. Декодирование и кодирование шестнадцатеричных цифр
### Задача
Вам нужно декодировать строку шестнадцатеричных цифр в байтовую строку или закодировать байтовую строку в шестнадцатеричную форму.

### Решение
Если вам просто нужно декодировать или закодировать сырую строку шестнадцатеричных цифр, используйте модуль *binascii*. Например:
```python
>>> # Initial byte string
>>> s = b'hello'

>>> # Encode as hex
>>> import binascii
>>> h = binascii.b2a_hex(s)
>>> h
b'68656c6c6f'

>>> # Decode back to bytes
>>> binascii.a2b_hex(h)
b'hello'
>>>
```

Похожую функцию можно найти в модуле *base64*. Например:
```python
>>> import base64
>>> h = base64.b16encode(s)
>>> h
b'68656C6C6F'
>>> base64.b16decode(h)
b'hello'
>>>
```

### Обсуждение
По большей части конвертирование в и из шестнадцатеричную форму с помощью показанных приёмов не составляет труда. Главная разница между этими двумя техниками заключается в приведении к регистру. Функции *base64.b16decode()* и *base64.b16encode()* работают только с шестнадцатеричными символами в верхнем регистре, а функции из модуля *binascii* могут работать с обоими регистрами.

Также важно отметить, что вывод, который производят кодирующие функции всегда является байтовой строкой. Чтобы принудительно вывести его в Unicode, вам придется добавить дополнительный шаг. Например:
```python
>>> h = base64.b16encode(s)
>>> print(h)
b'68656C6C6F'
>>> print(h.decode('ascii'))
68656C6C6F
>>>
```   

При декодировании шестнадцатеричных цифр функции *16decode()* и *a2b_hex()* принимают и байтовые, и юникодовые строки. Однако эти строки должны содержать только закодированые в ASCII шестнадцатеричные цифры. 

## 6.10. Кодирование и декодирование в Base64
### Задача
Вам нужно декодировать или закодировать бинарные данные, используя кодировку Base64.

### Решение
В модуле *base64* есть две функции, которые делают именно то, что вам нужно: *b64encode()* и *b64decode()*. Например:
```python
>>> # Some byte data
>>> s = b'hello'
>>> import base64

>>> # Encode as Base64
>>> a = base64.b64encode(s)
>>> a
b'aGVsbG8='

>>> # Decode from Base64
>>> base64.b64decode(a)
b'hello'
>>>
```

### Обсуждение
Кодировка Base64 предназначена только для использования с байт-ориентированными данными, такими как байтовые строки и байтовые массивы. Более того, вывод процесса кодирования всегда будет байтовой строкой. Если вы смешиваете данные в Base64 с текстом в Unicode, вам придется выполнить дополнительный шаг для декодирования. Например:
```python
>>> a = base64.b64encode(s).decode('ascii')
>>> a
'aGVsbG8='
>>>
```

При декодировании Base64 могут быть предоставлены и байтовые строки, и текстовые строки в Unicode. Однако строки Unicode могут содержать только символы ASCII.

## 6.11. Чтение и запись бинарных массивов структур
### Задача
Вы хотите прочесть или записать данные, закодированные как бинарный массив из единообразных структур, в кортежи Python.

### Решение
Чтобы работать с бинарными данными, используйте модуль *struct*. Вот пример кода, который записывает список кортежей Python в бинарный файл, кодируя каждый кортеж в структуру с помощью модуля *struct*:
```python
from struct import Struct

def write_records(records, format, f):
	'''
	Write a sequence of tuples to a binary file of structures.
	'''
	record_struct = Struct(format)
	for r in records:
		f.write(record_struct.pack(*r))

# Example
if __name__ == '__main__':
	records = [ (1, 2.3, 4.5),
				(6, 7.8, 9.0),
				(12, 13.4, 56.7) ]

with open('data.b', 'wb') as f:
	write_records(records, '<idd', f)
```

Есть несколько подходов к обратному превращению этого файла в список кортежей. Во-первых, если вы читаете файл кусочками (чанками) инкрементально, вы можете написать такой код:
```python
from struct import Struct

def read_records(format, f):
	record_struct = Struct(format)
	chunks = iter(lambda: f.read(record_struct.size), b'')
	return (record_struct.unpack(chunk) for chunk in chunks)

# Example
if __name__ == '__main__':
	with open('data.b','rb') as f:
		for rec in read_records('<idd', f):
			# Process rec
			...
```

Если вы хотите прочесть файл целиком в байтовую строку за один проход и конвертировать его кусочек за кусочком, вы можете сделать это так:
```python
from struct import Struct

def unpack_records(format, data):
	record_struct = Struct(format)
	return (record_struct.unpack_from(data, offset)
		for offset in range(0, len(data), record_struct.size))

# Example
if __name__ == '__main__':
	with open('data.b', 'rb') as f:
		data = f.read()
			for rec in unpack_records('<idd', data):
			# Process rec
			...
```

В обоих случаях результатом будет итерируемый объект, который производит кортежи, которые были сохранены в файле при его создании.


### Обсуждение
В программах, которые должны кодировать и декодировать бинарные данные, обычно используют модуль *struct*. Чтобы объявить новую структуру, просто создайте экземпляр *Struct*, как показано ниже:
```python
# Little endian 32-bit integer, two double precision floats
record_struct = Struct('<idd')
```

Структуры всегда определяются путём использования набора кодов структур, таких как *i*, *d*, *f* и так далее (см. документацию [Python](http://docs.python.org/3/library/struct.html)). Эти коды соответствуют определенным бинарным типам данных, таким как 32-битные целые числа, 64-битные числа с плавающей точкой, 32-битные числа с плавающей точкой и т.д. Символ < в качестве первого символа определяет порядок следования байтов. В этом примере он задает порядок little endian. Замените символ на >, чтобы задать big endian, или на ! для сетевого порядка байтов.

Полученный экземпляр Struct имеет различные атрибуты и методы для манипулирования структурами этого типа. Атрибут *size* содержит размер структуры в байтах, что полезно для операций ввода-вывода. Методы *pack()*
и *unpack()* используются для упаковки и распаковки данных. Например:
```python
>>> from struct import Struct
>>> record_struct = Struct('<idd')
>>> record_struct.size
20
>>> record_struct.pack(1, 2.0, 3.0)
b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'
>>> record_struct.unpack(_)
(1, 2.0, 3.0)
>>>
```

Иногда вы можете увидеть, как операции *pack()* и *unpack()* вызываются как функции уровня модуля: 
```python
>>> import struct
>>> struct.pack('<idd', 1, 2.0, 3.0)
b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'
>>> struct.unpack('<idd', _)
(1, 2.0, 3.0)
>>>
```

Это работает, но кажется менее элегантным, нежели создание единственного экземпляра *Struct* — особенно если одна и та же структура появляется во многих местах вашего кода. Путём создания экземпляра *Struct* форматирующий код определяется только раз, и все полезные операции прекрасным образом сгруппированы вместе. Это точно сделает ваш код более легко поддерживаемым, ведь вам придется вносить изменения только в одном месте.

Код для чтения бинарных структур использует несколько интересных и элегантных идиом программирования. В функции *read_records()* функция *iter()* используется для создания итератора, который возвращает кусочки (чанки) фиксированного размера (см. **рецепт 5.8.**) Этот итератор раз за разом вызывает переданный пользователем вызываемый объект (в данном случае, *lambda: f.read(record_struct.size)*), пока он не вернёт определённое значение (в данном случае *b*), на чём итерации останавливаются. Например:
```python
>>> f = open('data.b', 'rb')
>>> chunks = iter(lambda: f.read(20), b'')
>>> chunks
<callable_iterator object at 0x10069e6d0>
>>> for chk in chunks:
... 	print(chk)
...
b'\x01\x00\x00\x00ffffff\x02@\x00\x00\x00\x00\x00\x00\x12@'
b'\x06\x00\x00\x00333333\x1f@\x00\x00\x00\x00\x00\x00"@'
b'\x0c\x00\x00\x00\xcd\xcc\xcc\xcc\xcc\xcc*@\x9a\x99\x99\x99\x99YL@'
>>>
```

Причина создавать итератор в том, что он позволяет записям создаваться с помощью генератора (generator comprehension), как показано в примере. Если бы вы не использовали это решение, ваш код мог бы выглядеть так:
```python
def read_records(format, f):
	record_struct = Struct(format)
	while True:
		chk = f.read(record_struct.size)
		if chk == b'':
			break
	yield record_struct.unpack(chk)
return records
```

В функции *unpack_records()* используется другой подход — метод *unpack_from()*. Это полезный метод для извлечения бинарных данных из более крупного бинарного массива, потому что он делает это без создания временных объектов или копий в памяти. Вы просто передаете ему байтовую строку (или любой массив) вместе с байтовым сдвигом (offset), и он распакует поля прямо из этого места. 

Если вы использовали *unpack()* вместо *unpack_from()*, вы можете захотеть изменить код, чтобы создать большое количество маленьких срезов и вычислений сдвига. Например:
```python
def unpack_records(format, data):
	record_struct = Struct(format)
	return (record_struct.unpack(data[offset:offset + record_struct.size])
		for offset in range(0, len(data), record_struct.size))
```

В дополнение к тому, что эта версия сложнее читается, она также требует намного больше работы, поскольку она выполняет различные вычисления сдвига, копирует данные и создаёт объекты среза. Если вы будете распаковывать много структур из большой байтовой строки, которую уже прочитали, *unpack_from()* будет более элегантным решением.

Распаковка записей — одна из областей, где могут найти применение объекты *namedtuple* из модуля *collections*. Они позволят вам установить имена атрибутов на возвращаемые кортежи. Например:
```python
from collections import namedtuple

Record = namedtuple('Record', ['kind','x','y'])

with open('data.p', 'rb') as f:
	records = (Record(*r) for r in read_records('<idd', f))

for r in records:
	print(r.kind, r.x, r.y)
```

Если вы пишите программу, которой нужно работать с большим количеством бинарных данных, вам стоит использовать библиотеку типа *numpy*. Например, вместо чтения бинарного файла в список кортежей вы можете прочесть его в структурированный массив:
```python
>>> import numpy as np
>>> f = open('data.b', 'rb')
>>> records = np.fromfile(f, dtype='<i,<d,<d')
>>> records
array([(1, 2.3, 4.5), (6, 7.8, 9.0), (12, 13.4, 56.7)],
	  dtype=[('f0', '<i4'), ('f1', '<f8'), ('f2', '<f8')])
>>> records[0]
(1, 2.3, 4.5)
>>> records[1]
(6, 7.8, 9.0)
>>>
```

И последнее: если вы столкнулись с задачей чтения бинарных данных в каком-то известном формате (например, форматах растровых или векторных изображений, HDF5 и т.д.), проверьте, нет ли в Python модуля для работы с ними. Не стоит изобретать велосипед, если это не необходимо.


## 6.12. Чтение вложенных и различных по размеру бинарных структур
ВНИМАНИЕ! В СВЯЗИ С ТЕМ, ЧТО ЭТОТ РЕЦЕПТ ПОКА НАХОДИТСЯ НА ГРАНИ ПОЗНАНИЙ ПЕРЕВОДЧИКА, В ПЕРЕВОДЕ МОГУТ БЫТЬ НЕТОЧНОСТИ. ЕСЛИ ВЫ В СОСТОЯНИИ ПОНЯТЬ, О ЧЕМ ИДЁТ РЕЧЬ В ЭТОМ РЕЦЕПТЕ, ЛУЧШЕ ПРОЧТИТЕ ЕГО НА АНГЛИЙСКОМ. В БУДУЩЕМ ЭТОТ ПЕРЕВОД БУДЕТ ПЕРЕРАБОТАН.
### Задача
Вам нужно прочесть сложные бинарные данные, которые содержат коллекцию вложенных записей и/или записей различного размера. Такие данные могут включать изображения, видео, векторные изображения и т.д.

### Решение
Модуль *struct* может быть использован для декодирования и кодирования бинарных данных практически любой структуры. Чтобы проиллюстрировать работы с задачей этого рецепта, предположим, что у вас есть структура данных Python, представляющая коллекцию точек, составляющих набор многоугольников:
```python
polys = [
		 [ (1.0, 2.5), (3.5, 4.0), (2.5, 1.5) ],
		 [ (7.0, 1.2), (5.1, 3.0), (0.5, 7.5), (0.8, 9.0) ],
		 [ (3.4, 6.3), (1.2, 0.5), (4.6, 9.2) ],
]
```

Теперь предположим, что данные были закодированы в бинарный файл, который начинается следующим заголовком:
```
Byte 	Type 		Description
0		int 		File code (0x1234, little endian)
4 		double 		Minimum x (little endian)
12 		double 		Minimum y (little endian)
20		double		Maximum x (little endian)
28 		double  	Maximum y (little endian)
36 		int 		Number of polygons (little endian)
```

После заголовка идёт набор многоугольников, каждый из которых закодирован так:
```
Byte 	Type 		Description
0 		int 		Record length including length (N bytes)
4-N 	Points 		Pairs of (X,Y) coords as doubles
```

Чтобы записать этот файл, вы можете использовать такой код:
```python
import struct
import itertools

def write_polys(filename, polys):
	# Determine bounding box
	flattened = list(itertools.chain(*polys))
	min_x = min(x for x, y in flattened)
	max_x = max(x for x, y in flattened)
	min_y = min(y for x, y in flattened)
	max_y = max(y for x, y in flattened)
	
	with open(filename, 'wb') as f:
		f.write(struct.pack('<iddddi',
						    0x1234,
							min_x, min_y,
							max_x, max_y,
							len(polys)))
		for poly in polys:
			size = len(poly) * struct.calcsize('<dd')
			f.write(struct.pack('<i', size+4))
			for pt in poly:
				f.write(struct.pack('<dd', *pt))

# Call it with our polygon data
write_polys('polys.bin', polys)
```

Чтобы прочесть получившиеся данные обратно, вы можете написать похожий код с использованием функции *struct.unpack()*, которая обращает операции, проделанные во время записи. Например:
```python
import struct

def read_polys(filename):
	with open(filename, 'rb') as f:
	# Read the header
		header = f.read(40)
		file_code, min_x, min_y, max_x, max_y, num_polys = \
			struct.unpack('<iddddi', header)

	polys = []
	for n in range(num_polys):
		pbytes, = struct.unpack('<i', f.read(4))
		poly = []
		for m in range(pbytes // 16):
			pt = struct.unpack('<dd', f.read(16))
			poly.append(pt)
		polys.append(poly)
	return polys
``` 

Хотя этот код работает, он представляет собой довольно-таки беспорядочный набор небольших операций чтения, распаковки структур и т.п. Если такой код используется для обработки реального файла с данными, он быстро станет еще более запутанным. Это делает очевидным необходимость поиска альтернативного решения, которое могло бы упростить некоторые шаги и позволить программисту сосредоточиться на более важных вещах.

В оставшейся части этого рецепта мы шаг за шагом построим достаточно продвинутое решение для интерпретации бинарных данных. Наша цель — предоставить программисту возможность передать высокоуровневую спецификацию формата файла, а все детали чтения и распаковки данных переместить в «подкапотную» часть. Заранее предупреждаем, что нижеследующий код будет самым продвинутым примером во всей книге. Он использует различные приёмые объектно-ориентированного программирования и метапрограммирования. Рекомендуем вам внимательно прочитать раздел «Обсуждение», обращая внимание на ссылки на другие рецепты. 

Во-первых, при чтении бинарных данных наиболее типичный случай — это присутствие в файле заголовков и других структур данных. Хотя модуль *struct* может распаковать эти данные в кортеж, ещё один способ представить такую информацию — это использование класса. Вот пример кода:
```python
import struct

class StructField:
	'''
	Descriptor representing a simple structure field
	'''
	def __init__(self, format, offset):
		self.format = format
		self.offset = offset
	def __get__(self, instance, cls):
		if instance is None:
			return self
		else:
			r = struct.unpack_from(self.format,
								   instance._buffer, self.offset)
			return r[0] if len(r) == 1 else r

class Structure:
	def __init__(self, bytedata):
		self._buffer = memoryview(bytedata)
```

Этот код использует дескриптор для представления каждого поля структуры. Каждый дескриптор содержит совместимый со *struct* формат кода вместе с байтовым сдвигом используемого буфера памяти. В методе *__get()__* функция *struct.unpack_from()* используется для распаковки значения из буфера без необходимости делать дополнительные срезы или копии.

Класс *Structure* просто служит базовым классом (суперклассом), который принимает некие байтовые данные и сохраняет их в буфере памяти, используемом дескриптором *StructField*. Функция *memoryview()* в этом классе служит целям, которые мы проясним позднее.  

Этот код позволит вам определить структуру как высокоуровневый класс, который отражает информацию, найденную в таблицах, которые описывают ожидаемый формат файла. Например:
```python
class PolyHeader(Structure):
	file_code = StructField('<i', 0)
	min_x = StructField('<d', 4)
	min_y = StructField('<d', 12)
	max_x = StructField('<d', 20)
	max_y = StructField('<d', 28)
	num_polys = StructField('<i', 36)
```

Вот пример использования этого класса для чтения заголовка из данных о многоугольниках, которые мы записали ранее:
```python
>>> f = open('polys.bin', 'rb')
>>> phead = PolyHeader(f.read(40))
>>> phead.file_code == 0x1234
True
>>> phead.min_x
0.5
>>> phead.min_y
0.5
>>> phead.max_x
7.0
>>> phead.max_y
9.2
>>> phead.num_polys
3
>>>
```

Это интересно, но этот подход имеет несколько раздражающих нюансов. Даже если вы получаете удобство классоподобного интерфейса, код все равно многословен и требует от пользователя определять множество низкоуровневых деталей (например, повторяющееся использование *StructField*, определение сдвигов и т.п.) В получившемся класс также отсутствуют привычные удобные моменты, такие как предоставление способа вычислить общий размер структуры.

Каждый раз, когда вы сталкиваетесь с подобным излишне многословным определением класса, вы можете подумать об использовании декоратора класса или метакласса. Одна из возможностей метакласса в том, что он может быть использован для заполнения множества низкоуровневых деталей реализации, снимая это бремя с пользователя. В качестве примере рассмотрите этот метакласс и слегка переработанный класса *Structure*:
```python
class StructureMeta(type):
	'''
	Metaclass that automatically creates StructField descriptors
	'''
	def __init__(self, clsname, bases, clsdict):
		fields = getattr(self, '_fields_', [])
		byte_order = ''
		offset = 0
		for format, fieldname in fields:
			if format.startswith(('<','>','!','@')):
				byte_order = format[0]
				format = format[1:]
			format = byte_order + format
			setattr(self, fieldname, StructField(format, offset))
			offset += struct.calcsize(format)
		setattr(self, 'struct_size', offset)

class Structure(metaclass=StructureMeta):
	def __init__(self, bytedata):
		self._buffer = bytedata

@classmethod
def from_file(cls, f):
	return cls(f.read(cls.struct_size))
``` 

Используя этот новый класс *Structure*, вы можете записывать определение структуры так:
```python
class PolyHeader(Structure):
	_fields_ = [
		('<i', 'file_code'),
		('d', 'min_x'),
		('d', 'min_y'),
		('d', 'max_x'),
		('d', 'max_y'),
		('i', 'num_polys')
	]
```

Как вы можете видеть, эта спецификация намного компактнее. Добавленный метод класса *from_file()* также делает более чтение данных из файла без необходимости знать какие-либо детали о размере или структуре данных. Например:
```python
>>> f = open('polys.bin', 'rb')
>>> phead = PolyHeader.from_file(f)
>>> phead.file_code == 0x1234
True
>>> phead.min_x
0.5
>>> phead.min_y
0.5
>>> phead.max_x
7.0
>>> phead.max_y
9.2
>>> phead.num_polys
3
>>>
```

Когда вы вводите метакласс, вы можете встроить в него больше «ума». Например, предположим, что вы хотите обеспечить поддержку вложенных бинарных структур. Вот переделанный метакласс вместе с новым дескриптором, который это поддерживает:
```python
class NestedStruct:
	'''
	Descriptor representing a nested structure
	'''
	def __init__(self, name, struct_type, offset):
		self.name = name
		self.struct_type = struct_type
		self.offset = offset
		
	def __get__(self, instance, cls):
	if instance is None:
		return self
	else:
		data = instance._buffer[self.offset:
								self.offset+self.struct_type.struct_size]
		result = self.struct_type(data)
		# Save resulting structure back on instance to avoid
		# further recomputation of this step
		setattr(instance, self.name, result)
		return result

class StructureMeta(type):
	'''
	Metaclass that automatically creates StructField descriptors
	'''
	def __init__(self, clsname, bases, clsdict):
		fields = getattr(self, '_fields_', [])
		byte_order = ''
		offset = 0
		for format, fieldname in fields:
			if isinstance(format, StructureMeta):
				setattr(self, fieldname,
						NestedStruct(fieldname, format, offset))
				offset += format.struct_size
			else:
				if format.startswith(('<','>','!','@')):
					byte_order = format[0]
					format = format[1:]
				format = byte_order + format
				setattr(self, fieldname, StructField(format, offset))
				offset += struct.calcsize(format)
		setattr(self, 'struct_size', offset)
```

В этом примере кода дескриптор *NestedStruct* используется для наложения другого определения структуры на область памяти. Он делает это путём извлечения среза изначального буфера памяти и использования его для создания экземпляра данного структурного типа. Поскольку буфер памяти был инициализирован как memoryview, это извлечение среза не приводит к созданию дополнительных копий в памяти. Вместо этого оно накладывается на изначальную память. Более того, чтобы избежать повторения создания экземпляров, дескриптор сохраняет получившуюся внутреннюю структуру объекта в экземпляр, используя тот же приём, что мы описали в **рецепте 8.10.*

Используя эту новую формулировку, вы можете начать писать код так:
```python
class Point(Structure):
	_fields_ = [
			('<d', 'x'),
			('d', 'y')
	]
	
class PolyHeader(Structure):
	_fields_ = [
		('<i', 'file_code'),
		(Point, 'min'),
		(Point, 'max'),
		('i', 'num_polys')
	]
``` 

Удивительно, но код всё еще работает так, как вы ожидаете. Например:
```python
>>> f = open('polys.bin', 'rb')
>>> phead = PolyHeader.from_file(f)
>>> phead.file_code == 0x1234
True
>>> phead.min
# Nested structure
<__main__.Point object at 0x1006a48d0>
>>> phead.min.x
0.5
>>> phead.min.y
0.5
>>> phead.max.x
7.0
>>> phead.max.y
9.2
>>> phead.num_polys
3
```

На этом этапе мы разработали фреймворк для работы с записями фиксированного размера, но что делать с компонентами различных размеров? Например, оставшаяся часть файла с многоугольниками содержит элементы различных размеров. 

Один путь — написать класс, который просто представляет кусок (чанк) бинарных данных вместе с вспомогательной функцией для интерпретирования содержимого различными способами. Это тесно связано с подходом, описанным в **рецепте 6.11.**:
```python
class SizedRecord:
	def __init__(self, bytedata):
		self._buffer = memoryview(bytedata)
		
	@classmethod
	def from_file(cls, f, size_fmt, includes_size=True):
		sz_nbytes = struct.calcsize(size_fmt)
		sz_bytes = f.read(sz_nbytes)
		sz, = struct.unpack(size_fmt, sz_bytes)
		buf = f.read(sz - includes_size * sz_nbytes)
		return cls(buf)

	def iter_as(self, code):
		if isinstance(code, str):
			s = struct.Struct(code)
			for off in range(0, len(self._buffer), s.size):
				yield s.unpack_from(self._buffer, off)
		elif isinstance(code, StructureMeta):
			size = code.struct_size
			for off in range(0, len(self._buffer), size):
				data = self._buffer[off:off+size]
				yield code(data)
```

Метод класса *SizedRecord.from_file()* используется для чтения куска (чанка) данных с префиксом, определяющим размер, из файла, что является обычным для многих форматов файлов. На вход он принимает код форматирования структуры, который содержит кодировку размера, который должен быть представлен в байтах. Необязательный аргумент *includes_size* определяет, включает ли число байтов заголовок размера или нет. Вот пример того, как вы можете использовать этот код для прочтения отдельного многоугольника из файла с многоугольниками:
```python
>>> f = open('polys.bin', 'rb')
>>> phead = PolyHeader.from_file(f)
>>> phead.num_polys
3
>>> polydata = [ SizedRecord.from_file(f, '<i')
...		for n in range(phead.num_polys) ]
>>> polydata
[<__main__.SizedRecord object at 0x1006a4d50>,
 <__main__.SizedRecord object at 0x1006a4f50>,
 <__main__.SizedRecord object at 0x10070da90>]
>>>
```

Как показано выше, содержимое экземпляров *SizeRecord* пока еще не интерпретировано. Чтобы сделать это, используйте метод *iter_as()*, который принимает на вход код структуры формата или класс *Structure*. Это предоставляет вам немалую гибкость в том, как можно интерпретировать данные. Например:
```python
ample:
>>> for n, poly in enumerate(polydata):
...		print('Polygon', n)
...		for p in poly.iter_as('<dd'):
...			print(p)
...
Polygon 0
(1.0, 2.5)
(3.5, 4.0)
(2.5, 1.5)
Polygon 1
(7.0, 1.2)
(5.1, 3.0)
(0.5, 7.5)
(0.8, 9.0)
Polygon 2
(3.4, 6.3)
(1.2, 0.5)
(4.6, 9.2)
>>>

>>> for n, poly in enumerate(polydata):
...		print('Polygon', n)
...		for p in poly.iter_as(Point):
...			print(p.x, p.y)
...
Polygon 0
1.0 2.5
3.5 4.0
2.5 1.5
Polygon 1
7.0 1.2
5.1 3.0
0.5 7.5
0.8 9.0
Polygon 2
3.4 6.3
1.2 0.5
4.6 9.2
>>>
```

Собирая всё в месте, представим альтернативную реализацию функции *read_polys()*:
```python
class Point(Structure):
	_fields_ = [
		('<d', 'x'),
		('d', 'y')
		]

class PolyHeader(Structure):
	_fields_ = [
		('<i', 'file_code'),
		(Point, 'min'),
		(Point, 'max'),
		('i', 'num_polys')
	]

def read_polys(filename):
	polys = []
	with open(filename, 'rb') as f:
		phead = PolyHeader.from_file(f)
		for n in range(phead.num_polys):
			rec = SizedRecord.from_file(f, '<i')
			poly = [ (p.x, p.y)
					  for p in rec.iter_as(Point) ]
			polys.append(poly)
	return polys
```

### Обсуждение
Этот рецепт предоставляет практическое применение различных продвинутых приёмов программирования, в том числе дескрипторов, ленивых вычислений, метаклассов, переменных класса и просмотрщиков памяти (memory-views). И все они служат очень четко определенной цели.

Главная фишка этой реализации в том, что она полностью построена на идее ленивой распаковки. Когда экземпляр *Structure* создан, *__init()__* просто создает memoryview предоставленных байтовых данных и больше ничего не делает. В этот момент не производится распаковка или другие связанные со структурой операции. Причина использовать этот подход в том, что вы можете быть заинтересованы только в получении нескольких конкретных частей бинарной записи. Вместо распаковки файла целиком, будут распакованы только участки, к которым осуществляется доступ.

Чтобы реализовать ленивую распаковку и упаковку значений, используется класс-дескриптор *StructField*. Каждый атрибут, который пользователь запишет в *__fields__*, конвертируется в дескриптор *StructField*, который сохраняет связанный код формата структуры и байтовый сдвиг в хранимый буфер. Метакласс *StructureMeta* — то, что автоматически создаёт эти дескрипторы при определении различных структурных классов. Главная причина использовать метакласс в том, что он очень сильно облегчает пользователю определение формата структуры, давая возможность высокоуровневого описания без необходимости волноваться о низкоуровневых деталях.

Тонкий момент использования метакласса *StructureMeta* в том, что он делает порядок байтов липким. Так что если любой атрибут определил порядок байтов (< для little endian или > для big endian), этот порядок будет применён ко всем последующим полям. Это помогает избежать излишнего ввода с клавиатуры, но также оставляет возможным переключение на другой порядок в середине опеределения. Например, у вас может быть что-то сложное:
```python
class ShapeFile(Structure):
	_fields_ = [ ('>i', 'file_code'),
		 		 ('20s', 'unused'),
				 ('i', 'file_length'),
				 ('<i', 'version'),
				 ('i', 'shape_type'),
				 ('d', 'min_x'),
				 ('d', 'min_y'),
				 ('d', 'max_x'),
				 ('d', 'max_y'),
				 ('d', 'min_z'),
				 ('d', 'max_z'),
				 ('d', 'min_m'),
				 ('d', 'max_m') ]
```

Как было отмечено, использование *memoryview()* в решении позволяет избавиться от копий в памяти. Когда структуры начинают вкладываться одна в другую, просмотрщики памяти (memoryviews) могут быть использованы для наложения разных частей определения структуры на одну и ту же область памяти. Этот аспект решения довольно тонкий, он касается различий работы со срезами при использовании просмотрщиков памяти и при использовании обычных байтовых массивов. Если вы извлекаете срез из байтовой строки или массива, вы обычно получаете копию данных. А с просмотрщиком памяти это не так: срезы просто накладываются на существующую память. Поэтому этот подход эффективнее.

Немалое количество связанных рецептов расширяют освещение тем, поднятых в этом решении. См. **рецепт 8.13.** для детального рассмотрения использования дескрипторов для построения системы типов. **Рецепт 8.10.** содержит информацию о лениво вычисляемых свойствах и связан с реализацией дескриптора *NestedStruct*. **Рецепт 9.19.** рассматривает пример использования метакласса для инициализации атрибутов класса похожим способом, что и класс *StructureMeta*. Исходный код библиотеки Python *ctypes* также может представлять интерес, поскольку реализует похожую поддержку определения структур данных, вложения структур данных и похожую функциональность. 

## 6.13. Суммирование данных и обсчёт статистики
### Задача
Вам нужно обработать большие наборы данных и сгенерировать суммы или другие типы статистики.

### Решение
Для любого анализа данных с использованием статистики, временных рядов и прочих подобных приёмов вам стоит обратиться к библиотеке [Pandas](http://pandas.pydata.org). 

Вот пример использования *Pandas* для анализа [городской базы крыс и грузынов Чикаго](https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Rodent-Baiting/97t6-zrhs). К моменту написания этой книги этот CSV-файл содержал около 74 000 записей:
```python
>>> import pandas

>>> # Read a CSV file, skipping last line
>>> rats = pandas.read_csv('rats.csv', skip_footer=1)
>>> rats
<class 'pandas.core.frame.DataFrame'>
Int64Index: 74055 entries, 0 to 74054
Data columns:
Creation Date 						74055 non-null values
Status 								74055 non-null values
Completion Date 					72154 non-null values
Service Request Number 				74055 non-null values
Type of Service Request 			74055 non-null values
Number of Premises Baited			65804 non-null values
Number of Premises with Garbage 	65600 non-null values
Number of Premises with Rats 		65752 non-null values
Current Activity 					66041 non-null values
Most Recent Action 					66023 non-null values
Street Address 						74055 non-null values
ZIP Code 							73584 non-null values
X Coordinate 						74043 non-null values
Y Coordinate 						74043 non-null values
Ward 								74044 non-null values
Police District 					74044 non-null values
Community Area 						74044 non-null values
Latitude 							74043 non-null values
Longitude 							74043 non-null values
Location 							74043 non-null values
dtypes: float64(11), object(9)

>>> # Investigate range of values for a certain field
>>> rats['Current Activity'].unique()
array([nan, Dispatch Crew, Request Sanitation Inspector], dtype=object)

>>> # Filter the data
>>> crew_dispatched = rats[rats['Current Activity'] == 'Dispatch Crew']
>>> len(crew_dispatched)
65676
>>>

>> # Find 10 most rat-infested ZIP codes in Chicago
>>> crew_dispatched['ZIP Code'].value_counts()[:10]
60647 	3837
60618 	3530
60614 	3284
60629 	3251
60636 	2801
60657 	2465
60641 	2238
60609 	2206
60651 	2152
60632 	2071
>>>

>>> # Group by completion date
>>> dates = crew_dispatched.groupby('Completion Date')
<pandas.core.groupby.DataFrameGroupBy object at 0x10d0a2a10>
>>> len(dates)
472
>>>

>>> # Determine counts on each day
>>> date_counts = dates.size()
>>> date_counts[0:10]
Completion Date
01/03/2011 		4
01/03/2012 		125
01/04/2011 		54
01/04/2012 		38
01/05/2011 		78
01/05/2012 		100
01/06/2011 		100
01/06/2012 		58
01/07/2011 		1
01/09/2012 		12
>>>

>>> # Sort the counts
>>> date_counts.sort()
>>> date_counts[-10:]
Completion Date
10/12/2012 		313
10/21/2011 		314
09/20/2011 		316
10/26/2011 		319
02/22/2011 		325
10/26/2012		333
03/17/2011 		336
10/13/2011 		378
10/14/2011 		391
10/07/2011 		457
>>>
```

Да, 7 октября 2011 года у крыс был трудный денёк.

### Обсуждение
*Pandas* — это большая библиотека, в которой намного больше возможностей, чем мы можем здесь описать. Если вам требуется анализировать большие наборы данных, группировать данные, обсчитывать статистику и т.п., то обязательно присмотритесь к ней. 

В книге [Python for Data Analysis](http://shop.oreilly.com/product/0636920023784.do) также содержится много информации по этой теме.


# 7. Функции
Определение функций с помощью инструкции *def* — краеугольный камень всех программ. Цель этой главы состоит в том, чтобы представить несколько продвинутых и необычных определений функций и паттернов их использования. Темы включают аргументы по умолчанию, функции, способные принимать любое количество аргументов или только именованные аргументы, аннотации и замыкания. Также мы рассмотрим несколько непростых задач контроля потока управления и передачи данных, которые относятся к функциям обратного вызова (коллбэкам).

## 7.1. Определение функций, принимающих любое количество аргументов
### Задача
Вы хотите определить функцию, которая принимает любое количество аргументов.

### Решение
Чтобы определить функцию, которая принимает любое количество позиционных аргументов, используйте аргумент со звездочкой (*argument):
```python
def avg(first, *rest):
	return (first + sum(rest)) / (1 + len(rest))

# Sample use
avg(1, 2) 			# 1.5
avg(1, 2, 3, 4) 	# 2.5
```  

Чтобы принять любое количество именованных аргументов, используйте аргумент, который начинается с **. Например:
```python
import html

def make_element(name, value, **attrs):
	keyvals = [' %s="%s"' % item for item in attrs.items()]
	attr_str = ''.join(keyvals)
	element = '<{name}{attrs}>{value}</{name}>'.format(
				name=name,
				attrs=attr_str,
				value=html.escape(value))
	return element

# Example
# Creates '<item size="large" quantity="6">Albatross</item>'
make_element('item', 'Albatross', size='large', quantity=6)

# Creates '<p>&lt;spam&gt;</p>'
make_element('p', '<spam>')
```

Здесь *attrs* — это словарь, который хранит переданные именованные аргументы (если они были предоставлены).

Если вам нужна функция, которая может принимать и любое количество позиционных, и любое количество именованных аргументов, используйте * и ** вместе. Например:
```python
def anyargs(*args, **kwargs):
print(args) 	# A tuple
print(kwargs)  	# A dict
``` 

В этой функции позиционные аргументы попадают в кортеж *args*, а все именованные аргументы — в словарь *kwargs*.

### Обсуждение
Аргумент * может быть только последним в списке позиционных аргументов в определении функции. Аргумент ** может быть только последним. Тонкость тут в том, что аргумент без звёздочки может идти и после аргумента со звёздочкой:
```python
def a(x, *args, y):
	pass

def b(x, *args, y, **kwargs):
	pass
``` 

Такие аргументы известны как «обязательные именованные аргументы», они обсуждаются далее в *рецепте 7.2.* 

## 7.2. Определение функций, принимающих только именованные аргументы
### Задача
Вам нужна функция, которая принимает только именованные аргументы.

### Решение
Эту возможность легко реализовать, если вы поместите именованные аргументы после аргумента со звёздочкой или единственной звёздочки. Например:
```python
def recv(maxsize, *, block):
	'Receives a message'
	pass

recv(1024, True) 		# TypeError
recv(1024, block=True)  # Ok
```  

Этот приём может быть также использован для определения именованных аргументов для функций, которые принимают различное число позиционных аргументов. Например:
```python
def mininum(*values, clip=None):
	m = min(values)
	if clip is not None:
		m = clip if clip > m else m
	return m

minimum(1, 5, 2, -5, 10) 			# Returns -5
minimum(1, 5, 2, -5, 10, clip=0) 	# Returns 0
```

### Обсуждение
Обязательные именованные аргументы часто являются хорошим способом увеличить понятность кода при определении необязательных аргументов. Например, посмотрите на такой вызов:
```python
msg = recv(1024, False)
```

Пользователь, который не знаком с функцией recv, не имеет представления о том, что означает аргумент False. С другой стороны, намного более ясным будет сделать такой вызов:
```python
msg = recv(1024, block=False)
```

Использование обязательных именованных аргументов часто предпочтительнее трюков с использованием **kwargs, поскольку они правильно показываются, когда пользователь просит помощи:
```python
>>> help(recv)
Help on function recv in module __main__:
recv(maxsize, *, block)
Receives a message
```

Обязательные именованные аргументы также полезны в более продвинутых применениях. Например, они могут быть использованы для внедрения аргументов в функции, которые применяют правила использования \*args и \*\*kwargs для получения всех входных параметров. См. рецепт **рецепт 9.11.**

## 7.3. Прикрепление информационных метаданных к аргументам функций
### Задача
Вы определили функцию, но хотели бы прикрепить дополнительную информацию к аргументам, чтобы другим людям было легче понять, что делает эта функция. 

### Решение
Аннотации аргументов функций могут быть полезны, чтобы помочь программистам разобраться в том, как нужно применять функцию. Например, рассмотрим такую аннотированную функцию:
```python
def add(x:int, y:int) -> int:
	return x + y
```  

Интерпретатор Python не прикрепляет никакого семантического смысла к аннотациям. Это не проверки типов, они вообще никак не влияют на поведение Python. Однако они могут помогать другим людям читать исходный код и понимать, что вы имели в виду. А вот сторонние инструменты и фреймворки могут прикреплять к аннотациям семантический смысл. Также они появляются в документации:
```python
>>> help(add)
Help on function add in module __main__:

add(x: int, y: int) -> int
>>>
``` 

Хотя вы можете прикрепить любой объект к функции в качестве аннотации (например, числа, строки, экземпляры и т.д.), использование классов или строк имеет наибольший смысл.


### Обсуждение
Аннотации функции хранятся в атрибуте функции *__annotations__*. Например:
```python
>>> add.__annotations__
{'y': <class 'int'>, 'return': <class 'int'>, 'x': <class 'int'>}
```

Хотя можно придумать немало потенциальных применений аннотаций, обычно их используют для документации. Поскольку в Python нет объявлений типов, часто сложно понять, что нужно передавать в функцию, если вы просто читаете исходный код. Аннотации дают дополнительную информацию.

См. продвинутый пример в **рецепте 9.20.**, который показывает, как использовать аннотации для реализации множественной диспетчеризации (т.е., перегруженных функций).

## 7.4. Возвращение функцией нескольких значений
### Задача
Вы хотите, чтобы функция возвращала несколько значений.

### Решение
Чтобы вернуть несколько значений из функции, просто сделайте возвращаемым значением кортеж. Например:
```python
>>> def myfun()
... 	return 1, 2, 3
...
>>> a, b, c = myfun()
>>> a
1
>>> b
2
>>> c
3
```

### Обсуждение
Хотя это выглядит так, будто *myfun()* возвращает несколько значений, на самом деле создается кортеж. Это кажется немного замысловатым, но кортеж задается не скобками, а запятыми. Например:
```python
>>> a = (1, 2)	 # With parentheses
>>> a
(1, 2)
>>> b = 1, 2 	 # Without parentheses
>>> b
(1, 2)
>>>
```

При вызове функций, которые возвращают кортеж, часто результат присваивают нескольким переменным. Это просто распаковка кортежа, описанная в **рецепте 1.1.** Возвращаемое значение также может быть присвоено одной переменной:
```python
>>> x = myfun()
>>> x
(1, 2, 3)
>>>
```

## 7.5. Определение функций с аргументами по умолчанию
### Задача
Вы хотите определить функцию или метод, где один или более аргументов являются необязательными и имеют значение по умолчанию.

### Решение
Определить функцию с необязательными аргументами несложно: просто пропишите значения в определении и убедитесь, что аргументы по умолчанию идут последними. Например:
```python
def spam(a, b=42):
print(a, b)
spam(1)			 # Ok. a=1, b=42
spam(1, 2)		 # Ok. a=1, b=2
``` 

Если значение по умолчанию — это изменяемый (мутабельный) контейнер, такой как список, множество или словарь, используйте None в качестве значения по умолчанию:
```python
# Using a list as a default value
def spam(a, b=None):
	if b is None:
		b = []
		...
```

Если вместо предоставления значения по умолчанию вы хотите написать код, который просто проверяет, передано ли в необязательном аргументе целевое значение, используйте такую идиому:
```python
_no_value = object()

def spam(a, b=_no_value):
	if b is _no_value:
		print('No b value supplied')
	...
```

Вот как эта функция себя ведёт:
```python
>>> spam(1)
No b value supplied
>>> spam(1, 2) 		# b = 2
>>> spam(1, None) 	# b = None
>>>
``` 

Понаблюдайте за разницой между отсутствием переданного значения и передачей значения None.

### Обсуждение
Определение функций с аргументами по умолчанию — несложное дело, но не без тонкостей. 

Во-первых, значения, назначенные значениями по умолчанию, связываются только один раз, во время определения функции. Попробуйте поэкспериментировать:
```python
>>> x = 42
>>> def spam(a, b=x):
...		print(a, b)
...
>>> spam(1)
1 42			# Has no effect
>>> x = 23
>>> spam(1)
1 42
>>>
```

Заметьте, как изменение переменной *x* (которая была использована в качестве значения по умолчанию) не оказывает влияния на последующие события. 

Во-вторых, значения, назначенные значениями по умолчанию, всегда должны быть неизменяемыми объектами, такими как None, True, False, числа или строки. Никогда не пишите такой код:
```python
def spam(a, b=[]): 		# NO!
...
```

Если вы это сделаете, вы столкнетесь со всеми возможными неприятностями, если значение по умолчанию когда-либо покинет пределы функции будет изменено. Такие изменения навсегда поменяют значение по умолчанию и воздействуют на все будущие вызовы функции. Например:
```python
>>> def spam(a, b=[]):
...		print(b)
...		return b
...
>>> x = spam(1)
>>> x
[]
>>> x.append(99)
>>> x.append('Yow!')
>>> x
[99, 'Yow!']
>>> spam(1) 	# Modified list gets returned!
[99, 'Yow!']
>>>
```

Вероятно, вы хотели не этого. Чтобы избежать таких проблем, лучше назначить в качестве значения по умолчанию None и проверить его затем в функции, как показано в решении.

Использование оператора *is* при проверке None — важнейшая часть этого рецепта. Некоторые делают такую ошибку:
```python
def spam(a, b=None):
	if not b: 			# NO! Use 'b is None' instead
		b = []
	...
```

Проблема в том, что хотя None выдает значение False, многие другие объекты (например, строки нулевой длины, пустые списки, кортежи и словари) ведут себя так же. Так что показанная выше проверка будет ошибочно считать некоторые входные значения отсутствующими. Например:
```python
>>> spam(1)			# ОК
>>> x = []
>>> spam(1, x) 		# Silent error. x value overwritten by default
>>> spam(1, 0)		# Silent error. 0 ignored
>>> spam(1, '')		# Silent error. '' ignored
>>> 
```

Последняя часть этого рецепта — это особенно тонкий момент: функция, которая выполняет проверку, передано ли значение (любое) в необязательном аргументе. Хитрость в том, вы не можете использовать None, 0 или False в качестве значения по умолчанию при проверке присутствия предоставленного пользователем аргумента (поскольку все они являются вполне допустимыми аргументами, и пользователь может их передать в функцию). Так что вам нужно делать проверку как-то по-другому.

Чтобы решить эту проблему, вы можете создать уникальный частный экземпляр *object*, как показано в решении (переменная *_no_value*). Затем вы проверяете предоставленный аргумент в функции, сравнивая его с этим специальным значением, чтобы узнать, передан ли аргумент или нет. Идея в том, что крайне маловероятно, что пользователь передаст в качестве входного значения экземпляр *_no_value*. Поэтому это безопасное значение для проверки того, предоставлен ли экземпляр.

Использование *object()* может показаться необычным. *object* — это класс, который является обычным базовым классом (суперклассом) практически всех объектов Python. Вы можете создавать экземпляры *object*, но они не особенно интересны, поскольку не имеют каких-то полезных методов или каких-то атрибутов (в них нет словаря экземпляра, так что вы не можете присвоить им атрибуты). Практически единственная вещь, для которой они полезны, это проверка идентичности. Их можно использовать в качестве специальных значений, как и показано в вышеописанном решении.

## 7.6. Определение анонимных функций или функций в строке (инлайновых)
### Задача
Вам нужно предоставить короткую функцию обратного вызова для использования в операции типа *sort()*, но вы не хотите определять отдельную однострочную функцию с помощью инструкции *def*. Вместо этого вам бы пригодился способ определить функцию «инлайново» (в строке).

### Решение
Простые функции, которые просто вычисляют результат выражения, могут быть заменены инструкцией *lambda*. Например:
```python
>>> add = lambda x, y: x + y
>>> add(2,3)
5
>>> add('hello', 'world')
'helloworld'
>>>
```

Использование *lambda* абсолютно равноценно такому примеру:
```python
>>> def add(x, y):
...		return x + y
...
>>> add(2,3)
5
>>>
```

Обычно *lambda* используется в контексте какой-то другой операции, такой как сортировка или сокращение данных:
```python
>>> names = ['David Beazley', 'Brian Jones',
...			 'Raymond Hettinger', 'Ned Batchelder']
>>> sorted(names, key=lambda name: name.split()[-1].lower())
['Ned Batchelder', 'David Beazley', 'Raymond Hettinger', 'Brian Jones']
>>>
```

### Обсуждение
Хотя *lambda* позволяет определить простую функцию, ее использование строго ограничено. В частности, может быть определено только одно выражение, результат которого станет возвращаемым значением. Это значит, что никакие другие возможности языка, в т.ч. множественные инструкции, условия, итерации и обработка исключений, использоваться не могут. 

Вы можете замечательно писать код на Python без использования *lambda*. Однако вы скорее всего натолкнётесь на них в написанной кем-то программе, в которой используется множество маленьких функций для вычисления результатов выражений, или же в программе, которая требует от пользователей предоставлять функции обратного вызова (коллбэки).


## 7.7. Захват переменных в анонимных функциях
### Задача
Вы определили анонимную функцию, используя *lambda*, но вы также хотите захватить (запомнить) значения некоторых переменных во время определения.

### Решение
Рассмотрим поведение следующей программы:
```python
>>> x = 10
>>> a = lambda y: x + y
>>> x = 20
>>> b = lambda y: x + y
>>>  
```

А теперь задайте себе вопрос: какими будут значения *a(10)* и *b(10)*? Если вы думаете, что 20 и 30, то ошибаетесь:
```python
>>> a(10)
30
>>> b(10)
30
>>>
```  

Проблема в том, что значение *x*, используемое в lambda-выражении, является свободной переменной, которая связывается во время выполнения (в рантайме), а не во время определения. Так что значение *x* в lambda-выражениях будет таким, каким ему случится быть во время выполнения. Например:
```python
>>> x = 15
>>> a(10)
25
>>> x = 3
>>> a(10)
13
>>>
```  

Если же вы хотите, чтобы анонимная функция захватывала значение во время определения и сохраняло его, используйте значение по умолчанию:
```python
>>> x = 10
>>> a = lambda y, x=x: x + y
>>> x = 20
>>> b = lambda y, x=x: x + y
>>> a(10)
20
>>> b(10)
30
>>>
```

### Обсуждение
Проблема, которую мы рассматриваем в этом рецепте, возникает, когда случается перемудрить с lambda-функциями. Например, вы можете ожидать, что при создании списка lambda-выражений с использованием генератора списка или цикла, lambda-функции запомнят итерационные переменные во время определения. Например:
```python
>>> funcs = [lambda x: x+n for n in range(5)]
>>> for f in funcs:
...		print(f(0))
...
4
4
4
4
4
>>>
```

Обратите внимание, что все функции считают, что *n* имеет последнее значение, полученное в ходе итераций. Теперь сравните со следующим:
```python
>>> funcs = [lambda x, n=n: x+n for n in range(5)]
>>> for f in funcs:
...		print(f(0))
...
0
1
2
3
4
>>>
```

Как вы видите, теперь функции захватывают значения *n* во время определения. 
 

## 7.8. Заставляем вызывамый объект с N аргументами работать так же, как вызываемый объект с меньшим количеством аргументов
### Задача
У вас есть вызываемый объект, который вы хотели бы использовать в какой-то программе Python — возможно, в качестве функции обратного вызова (коллбэка) или обработчика (хэндлера), но он принимает слишком много аргументов и при вызове возбуждает исключение.

### Решение
Если вам нужно уменьшить количество аргументов функции, используйте *functools.partial()*. Функция *partial()* позволяет присваивать фиксированные значения одному или более аргументам, что уменьшает количество аргументов, которые должны быть переданы в последующих вызовах. Например, у вас есть вот такая функция:
```python
def spam(a, b, c, d):
	print(a, b, c, d)
```

А теперь попробуем *partial()*, чтобы зафиксировать значения некоторых аргументов:
```python
>>> from functools import partial
>>> s1 = partial(spam, 1)			# a = 1
>>>  s1(2, 3, 4)
1 2 3 4
>>> s1(4, 5, 6)
1 2 5 6
>>> s2 = partial(spam, d=42) 		# d = 42
>>> s2(1, 2, 3)
1 2 3 42
>>> s2(4, 5, 5)
4 5 5 42
>>> s3 = partial(spam, 1, 2, d=42)  # a = 1, b = 2, d = 42
>>> s3(3)
1 2 3 42
>>> s3(4)
1 2 4 42
>>> s3(5)
1 2 5 42
```

Понаблюдайте, как *partial()* фиксирует значения некоторых аргументов и возвращает новый вызываемый объект. Этот новый вызываемый объект принимает пока ещё не получившие значения аргументы, объединяя их с аргументами, переданными в *partial()*, и передает всё в изначальную функцию.

### Обсуждение
Этот рецепт на самом деле связан с решением такой задачи, как обеспечение совместной работы, казалось бы, несовместимого кода. Проиллюстрируем это серией примеров.

Первый пример. Предположим, что у вас есть список точек, представленных как кортежи координат (x, y). Вы можете использовать такую функцию для вычисления расстояния между двумя точками:
```python
points = [ (1, 2), (3, 4), (5, 6), (7, 8) ]

import math
def distance(p1, p2):
	x1, y1 = p1
	x2, y2 = p2
	return math.hypot(x2 - x1, y2 - y1)
```   

А теперь предположим, что вы хотите отсортировать все точки по их расстоянию до какой-то другой точки. Метод списков *sort()* принимает аргумент *key*, который может быть использован для настройки поиска, он работает только с функциями, которые принимают один аргумент (то есть *distance()* не подходит). Вот как вы можете использовать *partial()*, чтобы решить эту проблему:
```python
>>> pt = (4, 3)
>>> points.sort(key=partial(distance,pt))
>>> points
[(3, 4), (1, 2), (5, 6), (7, 8)]
>>>
```

Развивая эту идею, заметим, что *partial()* часто может использоваться для настройки сигнатур аргументов функций обратного вызова, используемых в других библиотеках. Например, вот пример кода, который использует *multiprocessing* для асинхронного вычисления результата, который передается функции обратного вызова, которая принимает результат и необязательный аргумент настройки логирования:
```python
def output_result(result, log=None):
	if log is not None:
		log.debug('Got: %r', result)

# A sample function
def add(x, y):
	return x + y

if __name__ == '__main__':
	import logging
	from multiprocessing import Pool
	from functools import partial

	logging.basicConfig(level=logging.DEBUG)
	log = logging.getLogger('test')
	p = Pool()
	p.apply_async(add, (3, 4), callback=partial(output_result, log=log))
	p.close()
	p.join()
```

При передаче функции обратного вызова с использованием *apply_async()*, дополнительный аргумент настройки логирования передается с использованием *partial()*. *multiprocessing* просто вызывает функцию обратного вызова (коллбэк) с единственным значением.

В качестве похожего примера рассмотрим задачу написания сетевых серверов. Модуль *socketserver* позволяет сделать это относительно легко. Например, вот простой эхо-сервер:
```python
from socketserver import StreamRequestHandler, TCPServer

class EchoHandler(StreamRequestHandler):
	def handle(self):
	for line in self.rfile:
		self.wfile.write(b'GOT:' + line)

serv = TCPServer(('', 15000), EchoHandler)
serv.serve_forever(
```

Предположим, однако, что вы хотите наделить класс *EchoHandler* методом *__init__()*, который принимает дополнительный конфигурирующий аргумент. Например:
```python
class EchoHandler(StreamRequestHandler):
	# ack is added keyword-only argument. *args, **kwargs are
	# any normal parameters supplied (which are passed on)
	def __init__(self, *args, ack, **kwargs):
		self.ack = ack
		super().__init__(*args, **kwargs)
	def handle(self):
		for line in self.rfile:
			self.wfile.write(self.ack + line)
```

Если вы внесёте это изменение, вы обнаружите, что больше нет очевидного пути вставить его в класс *TCPServer*. На самом деле вы обнаружите, что код начал возбуждать такие исключения:
```python
Exception happened during processing of request from ('127.0.0.1', 59834)
Traceback (most recent call last):
   ...
TypeError: __init__() missing 1 required keyword-only argument: 'ack'
``` 

На первый взгляд каждется невозможным исправить этот код без попыток поправить исходник *socketserver* или ещё какого-то странного обходного решения. Однако задача легко решается с помощью *partial()* — используйте её, чтобы предоставить значение аргумента *ack*:
```
from functools import partial
serv = TCPServer(('', 15000), partial(EchoHandler, ack=b'RECEIVED:'))
serv.serve_forever()
```

В этом примере определение аргумента *ack* в методе *__init__()* может показаться немного странным, но он определяется как обязательный именованный аргумент. Это подробно рассматривается в рецепте *7.2.* 

Иногда функциональность *partial()* заменяется lambda-выражением. Например, в предыдущем примере можно применить такие инструкции:
```python
points.sort(key=lambda p: distance(pt, p))

p.apply_async(add, (3, 4), callback=lambda result: output_result(result,log))

serv = TCPServer(('', 15000),
	lambda *args, **kwargs: EchoHandler(*args,
										ack=b'RECEIVED:',
										**kwargs))
``` 

Этот код работает, но он более многословен и может запутать того, кто его читает. Использование *partial()* более явно сообщает о ваших намерениях (передать значения некоторым аргументам).


## 7.9. Замена классов с одним методом функциями
### Задача
У вас есть класс, который определяет только один метод, исключая *__init__()*. Однако для упрощения вашего кода вы бы хотели заменить его на простую функцию.

### Решение
Во многих случаях классы с одним методом могут быть превращены в функции с помощью замыканий. Рассмотрите, например, следующий класс, который позволяет пользователю загружать страницы по URL с использованием некой шаблонной схемы:
```python
from urllib.request import urlopen

class UrlTemplate:
	def __init__(self, template):
		self.template = template
	def open(self, **kwargs):
		return urlopen(self.template.format_map(kwargs))

# Example use. Download stock data from yahoo
yahoo = UrlTemplate('http://finance.yahoo.com/d/quotes.csv?s={names}&f={fields}')
for line in yahoo.open(names='IBM,AAPL,FB', fields='sl1c1v'):
	print(line.decode('utf-8'))
```

Этот класс может быть заменен намного более простой функцией:
```python
def urltemplate(template):
	def opener(**kwargs):
		return urlopen(template.format_map(kwargs))
	return opener

# Example use
yahoo = urltemplate('http://finance.yahoo.com/d/quotes.csv?s={names}&f={fields}')
for line in yahoo(names='IBM,AAPL,FB', fields='sl1c1v'):
	print(line.decode('utf-8'))
```

### Обсуждение
Во многих случаях единственной причиной использовать класс с одним методом является необходимость сохранять дополнительное состояние для использования в методе. Например, единственное назначение класса *UrlTemplate* заключается в сохранении значения *template*, чтобы оно могло быть использовано в методе *open()*.

Использование вложенной функции (замыкания), как показано выше, часто будет намного более элегантным решением. Замыкание — это просто функция, но с дополнительным окружением переменных, которые используются внутри функции. Ключевое преимущество замыкания в том, что оно запоминает окружение, в котором было определено. Поэтому в примере функция *opener()* запоминает значение аргумента *template()*, и использует его в последующих вызовах.

Всякий раз, когда вы пишите код и встречаетесь с задачей прикрепления дополнительного состояния к функции, вспоминайте о замыканиях. Они часто являются более минималистичным и элегантным решением, нежели альтернатива (превращение функции в полноценный класс).  

## 7.10. Передача дополнительного состояния в функциях обратного вызова
### Задача
Вы пишете код, который опирается на использование функций обратного вызова (например, обработчики событий, коллбэки на завершения и т.п.), но вы хотите получить функцию обратного вызова, несущую дополнительное состояние для использования в функции обратного вызова.

### Решение
Этот рецепт относится к способу использования функций обратного вызова, который можно обнаружить во многих библиотеках и фреймворках — особенно тех, которые связаны с асинхронной обработкой. Рассмотрим следующую функцию, которая вызывает коллбэк:
```python
def apply_async(func, args, *, callback):
	# Compute the result
	result = func(*args)

# Invoke the callback with the result
callback(result)
```

В реальной жизни такой код может выполнять различные типы продвинутой обработки, включая треды, процессы и таймеры, но в данном случае это не главное. Мы просто сосредоточимся на вызове коллбэка. Вот пример использования приведённого выше кода:
```python
>>> def print_result(result):
...		print('Got:', result)
...
>>> def add(x, y):
...		return x + y
...
>>> apply_async(add, (2, 3), callback=print_result)
Got: 5
>>> apply_async(add, ('hello', 'world'), callback=print_result)
Got: helloworld
>>>
```   

Как вы можете видеть, функция *print_result()* принимает только один аргумент, который представляет собой результат. Никакая другая информация не передаётся. Это отсутствие информации иногда может представлять собой проблему, когда вы хотите, чтобы коллбэк взаимодействовал с другими переменными или частями окружения.

Один способ передать дополнительную информацию в функцию обратного вызова — это использовать связанный метод вместо простой функции. Например, этот класс хранит внутренний последовательный номер, который инкрементально увеличивается каждый раз, когда получен результат:
```python
class ResultHandler:
	def __init__(self):
		self.sequence = 0
	def handler(self, result):
		self.sequence += 1
		print('[{}] Got: {}'.format(self.sequence, result))
```

Чтобы использовать этот класс, вы могли бы создать экземпляр и использовать связанный метод *handler* в качестве функции обратного вызова (коллбэка):
```python
>>> r = ResultHandler()
>>> apply_async(add, (2, 3), callback=r.handler)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=r.handler)
[2] Got: helloworld
>>> 
```

В качестве альтернативы классу вы также можете использовать для хранения состояния замыкание:
```python
def make_handler():
	sequence = 0
	def handler(result):
		nonlocal sequence
		sequence += 1
		print('[{}] Got: {}'.format(sequence, result))
	return handle
``` 

Вот пример использования такого варианта:
```python
>>> handler = make_handler()
>>> apply_async(add, (2, 3), callback=handler)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=handler)
[2] Got: helloworld
>>> 
```

В качестве ещё одной вариации на эту тему вы также иногда можете использовать корутину для выполнения той же задачи:
```python
def make_handler():
	sequence = 0
	while True:
		result = yield
		sequence += 1
		print('[{}] Got: {}'.format(sequence, result))
```

Для корутины вы можете использовать метод *send()* в качестве коллбэка:
```python
>> handler = make_handler()
>>> next(handler) 			# Advance to the yield
>>> apply_async(add, (2, 3), callback=handler.send)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=handler.send)
[2] Got: helloworld
>>> 
```

И последнее: вы также можете передать состояние в коллбэк, используя дополнительный аргумент и применяя функцию *partial()*. Например:
```python
>>> class SequenceNo:
...		def __init__(self):
...			self.sequence = 0
...	
>>> def handler(result, seq):
...		seq.sequence += 1
...		print('[{}] Got: {}'.format(seq.sequence, result))

>>> seq = SequenceNo()
>>> from functools import partial
>>> apply_async(add, (2, 3), callback=partial(handler, seq=seq))
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=partial(handler, seq=seq))
[2] Got: helloworld
>>> 
```

### Обсуждение
Программы, основанные на функциях обратного вызова (коллбэках), часто подвержены риску превратиться в огромную беспорядочную кучу. Частично эта проблема возникает, потому что функция обратного вызова часто отсоединена от кода, который делает первоначальный запрос, который приводит к выполнению коллбэка. Поэтому окружение выполнения между созданием запроса и обработкой результата теряется. Если вы хотите, чтобы функция обратного вызова продолжалась с процедурой из нескольких шагов, вам нужно понять, как сохранить и восстановить ассоциированное состояние.

Существует два основных подхода, которые полезны для захвата и переноса состояния. Вы можете переносить его в экземпляре (например, прикрепленном к связанному методу), или же вы можете переносить его в замыкании (вложенной функции). Из этих двух приёмов замыкания, вероятно, немного более легковесны и естественны, поскольку просто создаются из функций. Они также автоматически захватывают все использованные переменные. Это освобождает вас от необходимости беспокоиться по поводу того, какое именно состояние нужно сохранить (это автоматически определяется вашим кодом).

При использовании замыканий вам нужно осторожно обращаться с изменяемыми (мутабельными) переменными. В вышеприведённом решении объявление *nonlocal* используется для обозначения того, что переменная *sequence* изменяется изнутри коллбэка. Без этого объявления вы бы получили ошибку.


Использование корутины в качестве обработчика коллбэка интересно тем, что это тесно связано с походом с использованием замыканий. В некотором смысле он даже чище, поскольку представляет собой одну функцию. БОлее того, переменные могут свободно изменяться без беспокойства об объявлениях *nonlocal*. Потенциальный недостаток в том, что корутины не так легки в понимании, как другие компоненты Python. Есть также несколько тонких моментов, таких как необходимость вызывать *next()* на корутине перед тем как её использовать. Тем не менее, потенциально корутины можно использовать и по-другому — например, для определения внутристрочного коллбэка (см. следующий рецепт).

Последний приём с использованием *partial()* полезен, если всё, что вам нужно, это передать дополнительные значения в коллбэк. Иногда вместо *partial()* мы можете достичь того же с помощью *lambda*:
```python
>>> apply_async(add, (2, 3), callback=lambda r: handler(r, seq))
[1] Got: 5
>>>
```  

Дополнительные примеры мы можете найти в **рецепте 7.8.**, где показывается использование *partial()* для смены аргументных сигнатур.

## 7.11. Внутристрочные функции обратного вызова
### Задача
Вы пишите код, в котором используются коллбэки, но вас беспокоит быстрое размножение маленьких функций и головоломность потока управления. Вы бы хотели как-то заставить код выглядеть более похожим на нормальную последовательность процедурных шагов.

### Решение
Коллбэки могут быть встроены в функцию путём использования генераторов и корутин. Предположим, у вас есть функция, которая выполняет какую-то работу и вызывает коллбэк (см. **рецепт 7.10.**):
```python
def apply_async(func, args, *, callback):
	# Compute the result
	result = func(*args)

	# Invoke the callback with the result
	callback(result)
```  

Теперь взгляните на поддерживающий код, который использует класс *Async* и декоратор *inlined_async*:
```python
from queue import Queue
from functools import wraps

class Async:
	def __init__(self, func, args):
		self.func = func
		self.args = args

	def inlined_async(func):
		@wraps(func)
		def wrapper(*args):
			f = func(*args)
			result_queue = Queue()
			result_queue.put(None)
			while True:
				result = result_queue.get()
				try:
					a = f.send(result)
					apply_async(a.func, a.args, callback=result_queue.put)
				except StopIteration:
					break
		return wrapper
``` 

Эти два фрагмента кода позволят вам встроить в строку шаги функции обраного вызова, используя инструкции *yield*. Например:
```python
def add(x, y):
	return x + y

@inlined_async
def test():
	r = yield Async(add, (2, 3))
	print(r)
	r = yield Async(add, ('hello', 'world'))
	print(r)
	for n in range(10):
		r = yield Async(add, (n, n))
		print(r)
	print('Goodbye')
```

Если вы вызовете *test()*, то получите такой вывод:
```python
5
helloworld
0
2
4
6
8
10
12
14
16
18
Goodbye
```

Если исключить специальный декоратор и использование *yield*, то вы заметите, что функции обратного вызова нигде не появляются (только «под капотом»).

### Обсуждение
Этот рецепт действительно проверяет ваши знания функций обратного вызова, генераторов и потока управления.

Во-первых, основной момент кода с коллбэками в том, что текущее вычисление приостанавливается и возобновляется в какой-то момент времени позже (асинхронно). Когда вычисление возобновляется, для продолжения обработки выполняется коллбэк. Функция *apply_sync()* иллюстрирует важнейшие составляющие выполнения коллбэка, хотя в реальном мире процесс может быть намного сложнее (в нем могут использоваться треды, процессы, обработчики событий и т.п.)

Идея того, что вычисление приостановится и возобновится естественным образом отображается на модель выполнения генератора. Если точнее, то операция *yield* заставляет генератор выдавать значение и приостанавливаться. Последующие вызовы методов генератора *__next()__* или *send()* заставят его снова запуститься.

Имея это в виду, мы можем понять, что суть этого рецепта находится в декораторе *inline_async()*. Ключевая идея в том, что декоратор пошагово проводит генератор через все его инструкции *yield*. Чтобы это сделать, создается и изначально наполняется значениями *None* очередь результатов. Затем инициируется цикл, в котором результат вынимается из очереди и посылается в генератор. Это вызывает следующий *yield*, где принимается экземпляр *Async*. Затем цикл смотрит на функцию и аргументы и вызывает асинхронное вычисление *apply_sync()*. Однако наиболее хитрая часть этого вычисления в том, что вместо использования обычного коллбэка, функция обратного вызова установлена на метод очереди *put()*.	

В этот момент он остается открытым вопрос о том, что произойдет. Главный цикл немедленно возвращается наверх и просто выполняет операцию *get()* на очереди. Если данные присутствуют, это должен быть результат, помещенный туда коллбэком *put()*. Если же ничего нет, операция блокируется и ждёт, когда придёт результат. Как это может произойти — зависит от конкретной реализации функции *apply_async()*.

Если вы сомневаетесь, что такая безумная штука может работать, вы можете попробовать ее с библиотекой *multiprocessing* и заставить асинхронные операции выполняться в отдельных процессах:
```python
if __name__ == '__main__':
	import multiprocessing
	pool = multiprocessing.Pool()
	apply_async = pool.apply_async
	
	# Run the test function
	test()
```

Вы обнаружите, что это работает, но чтобы разобраться в потоке управления, вам может потребоваться немало кофе.

Приём скрытия нетривиального потока управления за генераторами можно найти повсеместно в стандартной библиотеке и сторонних пакетах. Например, декоратор *@contextmanager* из библиотеки *contextlib* выполняет похожий безумный фокус, который склеивает вход в менеджер контекста и выход из него через инструкцию *yield*. Популярный пакет *Twisted* тоже использует похожие внутристрочные коллбэки. 

## 7.12. Доступ к переменным, определенным внутри замыкания
### Задача
Вы хотите расширить добавить в замыкание функции, которые позволят получать доступ к внутренним переменным (в том числе и доступ на изменение).

### Решение
В обычном случае внутренние переменные замыкания полностью скрыты от внешнего мира. Однако вы можете предоставить доступ путём написания функций для доступа и прикрепления их к замыканию как атрибутов функции. Например:
```python
def sample():
	n = 0
	# Closure function
	def func():
		print('n=', n)
	
	# Accessor methods for n
	def get_n():
		return n
	
	def set_n(value):
		nonlocal n
		n = value
	
	# Attach as function attributes
	func.get_n = get_n
	func.set_n = set_n
	return func
``` 

Вот пример использования этого кода:
```python
>>> f = sample()
>>> f()
n = 0
>>> f.set_n(10)
>>> f()
n = 10
>>> f.get_n()
10
>>>
```

### Обсуждение
Две главные возможности языка позволяют этому рецепту работать. Во-первых, инструкции nonlocal делают возможным написание функций, которые изменяют внутренние переменные. Во-вторых, атрибуты функции позволяют напрямую прикреплять методы для доступа к замыканию, и они работают практически так же, как методы экземпляра (хотя классы тут не используются).

Небольшое дополнение к этому рецепту позволит замыканиям эмулировать экземпляры класса. Всё, что вам нужно, это скопировать внутренние функции в словарь экземпляра и возвратить его. Например:
```python
import sys
class ClosureInstance:
	def __init__(self, locals=None):
		if locals is None:
			locals = sys._getframe(1).f_locals

	# Update instance dictionary with callables
		self.__dict__.update((key,value) for key, value in locals.items()
							  if callable(value) )
	# Redirect special methods
	def __len__(self):
		return self.__dict__['__len__']()

# Example use
def Stack():
	items = []

	def push(item):
		items.append(item)
	def pop():
		return items.pop()
	def __len__():
		return len(items)

	return ClosureInstance()
``` 

Вот интерактивный сеанс, который показывает, как всё это работает:
```python
>>> s = Stack()
>>> s
<__main__.ClosureInstance object at 0x10069ed10>
>>> s.push(10)
>>> s.push(20)
>>> s.push('Hello')
>>> len(s)
3
>>> s.pop()
'Hello'
>>> s.pop()
20
>>> s.pop()
10
>>>
```

Интересно, что этот код работает немного быстрее аналога, использующего  обычное определение класса. Например, вы можете проверить производительность по сравнению с таким классом:
```python
class Stack2:
	def __init__(self):
		self.items = []

	def push(self, item):
		self.items.append(item)

	def pop(self):
		return self.items.pop()

	def __len__(self):
		return len(self.items)
```

Если вы это сделаете, то получите похожие результаты:
```python
>>> from timeit import timeit
>>> # Test involving closures
>>> s = Stack()
>>> timeit('s.push(1);s.pop()', 'from __main__ import s')
0.9874754269840196
>>> # Test involving a class
>>> s = Stack2()
>>> timeit('s.push(1);s.pop()', 'from __main__ import s')
1.0707052160287276
>>>
```

Как показано выше, версия на замыкании работает на 8% быстрее. По большей части выигрыш возникает за счёт прямого доступа к переменным экземпляра. Замыкания быстрее, потому что не используют дополнительную переменную *self*. 

Рэймонд Хеттингер предложил еще более [дьявольский вариант этой идеи](http://bit.ly/11DSni2). Однако если вы склоняетесь использовать что-то такое в своей программе, помните, что это просто странная замена настоящему классу. Например, ключевые возможности типа наследования, свойств, дескрипторов или методов класса работать не будут. Вам также придётся поплясать с бубном, чтобы заставить специальные методы работать (например, обратите внимание на реализацию метода *__len__()* в *ClosureInstance*).

И последнее: вы рискуете затруднить жизнь людям, которые будут читать ваш код и размышлять о том, почему в нем нет нормального определения класса (конечно, они также задумаются, почему ваша версия работает быстрее). Но в любом случае это интересный пример того, чего можно достичь, предоставляя доступ к «внутренностям» замыкания.

Добавление методов в замыкания может иметь больше смысла в условиях, когда вам нужно делать вещи типа сброса внутреннего состояния, сброса буферов, очистки кэша или реализации какого-то механизма обратной связи.

# 8. Классы и объекты
Основная задача этой главы — представить рецепты обычных шаблонов программирования, относящихся к определениям классов. Рассматриваемые темы включают создание объектов, поддерживающих обычные возможности Python, использование специальных методов, приёмы инкапсуляции, наследование, управление памятью, а также полезные шаблоны проектирования.

## 8.1. Изменение строкового представления экземпляров
### Задача
Вы хотите изменить строки, которые выдаются при выводе или просмотре экземпляров, на что-то более понятное.

### Решение
Чтобы изменить строковое представление экземпляра, определите методы *__str__()* и *__repr__()*. Например:
```python
class Pair:
	def __init__(self, x, y):
		self.x = x
		self.y = y
	def __repr__(self):
		return 'Pair({0.x!r}, {0.y!r})'.format(self)
	def __str__(self):
		return '({0.x!s}, {0.y!s})'.format(self)
```

Метод *__repr__()* возвращает кодовое представление экземпляра, и обычно это текст, который нужно ввести, чтобы воссоздать объект. Встроенная функция *repr()* возвращает этот текст, как и интерактивный сеанс интерпретатора при проверке значений. Метод *__str__()* преобразует экземпляр в строку, что и будет выводом функций *str()* и *print()*. Например:
```python
>>> p = Pair(3, 4)
>>> p
Pair(3, 4) 			# __repr__() output
>>> print(p)
(3, 4)				# __str__() output
>>>
```

Реализация этого рецепта также показывает, как различные строковые представления могут быть использованы при форматировании. Конкретнее, специальный код форматирования *!r* показывает, что вывод *__repr__()* должен быть использован вместо вызываемого по умолчанию *__str__()*. Вы можете попробовать это показанным выше классом:
```python
>>> p = Pair(3, 4)
>>> print('p is {0!r}'.format(p))
p is Pair(3, 4)
>>> print('p is {0}'.format(p))
p is (3, 4)
>>>
``` 

### Обсуждение
Определение *__repr__()* и *__str__()* часто является хорошей практикой, поскольку может облегчить дебаггинг и вывод экземпляра. Например, просто печатая или логируя экземпляр, программист получит более полезную информацию о содержимом экземпляра. 

Стандартная практика для вывода *__repr__()* — выдавать такой текст, чтобы *eval(repr(x)) == x*. Если это невозможно или нежелательно, то обычной практикой будет создание полезного текстового представления, заключенного между < и >. Например:
```python
>>> f = open('file.dat')
>>> f
<_io.TextIOWrapper name='file.dat' mode='r' encoding='UTF-8'>
>>>
```

Если *__str__()* не определён, используется вывод *__repr__()*.

Использование в решении *format()* может показаться немного странным, но код форматирования {0.x} определяет атрибут *x* аргумента *0*. Так, в следующей функции 0 — это аргумент *self* экземпляра:
```python
def __repr__(self):
	return 'Pair({0.x!r}, {0.y!r})'.format(self)
```

В качестве альтернативы этой реализации вы можете также использовать оператор *%* и такой код:
```python
def __repr__(self):
	return 'Pair(%r, %r)' % (self.x, self.y)
```

## 8.2. Настройка строкового форматирования
### Задача
Вы хотите, чтобы объект поддерживал кастомизированное форматирование через функцию *format()* и строковый метод.

### Решение
Чтобы кастомизировать строковое форматирование, определите в классе метод *__format__()*. Например:
```python
_formats = {
	'ymd' : '{d.year}-{d.month}-{d.day}',
	'mdy' : '{d.month}/{d.day}/{d.year}',
	'dmy' : '{d.day}/{d.month}/{d.year}'
	}

class Date:
	def __init__(self, year, month, day):
		self.year = year
		self.month = month
		self.day = day
	
	def __format__(self, code):
		if code == '':
			code = 'ymd'
		fmt = _formats[code]
		return fmt.format(d=self)
```

Экземпляры класса *Date* теперь поддерживают операции форматирования:
```python
>>> d = Date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d, 'mdy')
'12/21/2012'
>>> 'The date is {:ymd}'.format(d)
'The date is 2012-12-21'
>>> 'The date is {:mdy}'.format(d)
'The date is 12/21/2012'
>>>
```

### Обсуждение
Метод *__format__()* предоставляет доступ к функциональности Python в области форматирования строк. Важно отметить, что интерпретация кодов форматирования полностью зависит от самого класса. Поэтому коды могут быть практически любыми. Например, посмотрим на следующий пример из модуля *datetime*:
```python
>>> from datetime import date
>>> d = date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d,'%A, %B %d, %Y')
'Friday, December 21, 2012'
>>> 'The end is {:%d %b %Y}. Goodbye'.format(d)
'The end is 21 Dec 2012. Goodbye'
>>>
```

Есть определённые стандартные соглашения для форматирования встроенных типов. См. [документацию модуля string](http://docs.python.org/3/library/string.html), в которой приведена формальная спецификация.


## 8.3. Создание объектов, поддерживающих протокол менеджера контекста
### Задача
Вы хотите заставить ваши объекты поддерживать протокол менеджера контекста (инструкцию *with*).

### Решение
Чтобы сделать объекты совместимыми с инструкцией *with*, вам нужно реализовать методы *__enter__()* и *__exit__()*. Например, рассмотрим следующий класс, который предоставляет сетевое соединение:
```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
	def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
		self.address = address
		self.family = AF_INET
		self.type = SOCK_STREAM
		self.sock = None
	
	def __enter__(self):
		if self.sock is not None:
			raise RuntimeError('Already connected')
		self.sock = socket(self.family, self.type)
		self.sock.connect(self.address)
		return self.sock
	def __exit__(self, exc_ty, exc_val, tb):
		self.sock.close()
		self.sock = None
```

Ключевая возможность этого класса в том, что он представляет сетевое соединение, но изначально ничего не делает (т.е., не устанавливает соединение). Вместо этого соединение устаналивается и закрывается по запросу, с использованием инструкции *with*. Например:
```python
from functools import partial

conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
	# conn.__enter__() executes: connection open
	s.send(b'GET /index.html HTTP/1.0\r\n')
	s.send(b'Host: www.python.org\r\n')
	s.send(b'\r\n')
	resp = b''.join(iter(partial(s.recv, 8192), b''))
	# conn.__exit__() executes: connection closed
```


### Обсуждение
Главный принцип написания менеджера контекста в том, что вы пишете код, который будет окружён блоком инструкций согласно правилам использования инструкции *with*. Когда инструкция *with* впервые встречается интерпретатору, вызывается метод *__enter__()*. Возвращённое методом *__enter__()* значение (если оно есть) помещается в переменную, указанную с помощью квалификатора *as*. Затем выполняются инструкции в теле инструкции *with*. В конце вызывается метод *__exit__()*, чтобы всё подчистить.

Этот поток управления будет выполнен несмотря на любые события в теле инструкции *with*, даже если будут возбуждены исключения. На самом деле три аргумента метода *__exit__()* содержат тип исключения, значение и трассировку для возбужденных исключений (если они имели место). Метод *__exit__()* может как-то использовать информацию об исключении, либо проигнорировать её, ничего не делая и возвращая *None* в качестве результата. Если *__exit__()* возвращает *True*, исключение исчезнет, как будто бы ничего и не произошло, и программа продолжит выполнение инструкций, следующих сразу за блоком *with*.

Тонкий аспект этого рецепта в том, позволяет ли класс *LazyConnection* вложенное использование соединения с несколькими инструкциями *with*. Как было показано, только одновременно разрешено только одно соединение через сокет, и будет возбуждено исключение, если повторить инструкцию *with*, когда сокет уже используется. Вы можете обойти это ограничение с помощью немного отличающейся реализации:
```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
	def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
		self.address = address
		self.family = AF_INET
		self.type = SOCK_STREAM
		self.connections = []
	
	def __enter__(self):
		sock = socket(self.family, self.type)
		sock.connect(self.address)
		self.connections.append(sock)
		return sock
	
	def __exit__(self, exc_ty, exc_val, tb):
		self.connections.pop().close()

# Example use
from functools import partial

conn = LazyConnection(('www.python.org', 80))
with conn as s1:
	...
	with conn as s2:
		...
		# s1 and s2 are independent sockets
``` 

В этой второй версии класс *LazyConnection* служит своего рода фабрикой соединений. Внутри для хранения стека используется список. Когда бы ни был вызван метод *__enter__()*, он создает новое соединение и добавляет его в стек. Метод *__exit__()* просто выталкивает последнее соединение со стека и закрывает его. Это тонкий момент, но это позволяет создавать множество соединений за раз с помощью вложенных инструкций *with*, как и показано выше.

Менеджеры контекста наиболее часто используются в программах, которым нужно управлять такими ресурсами как файлы, сетевые соединения и блокировки. Ключевая особенность этих ресурсов в том, что должны быть явно закрыты или освобождены, чтобы корректно работать. Например, если вы получаете блокировку, то должны убедиться, что освобождаете её, иначе вы рискуете получить дедлок. Путём реализации *__enter__()*, *__exit__()* и с помощью инструкции *with* намного проще избежать таких проблем, поскольку «подчищающий» код в методе *__exit__()* будет гарантированно выполнен в любом случае. 

Альтернативную реализацию менеджеров контекста вы сможете найти в модуле *contextmanager*. Потокобезопасная версия этого рецепта ждёт вас в **рецепте 12.6.**  

## 8.4. Экономия памяти при создании большого количества экземпляров
### Задача
Ваша программа создает большое количество (миллионы) экземпляров и использует много памяти.

### Решение
Для классов, которые в основном служат простыми структурами данных, вы часто можете значительно уменьшить потребление памяти экземплярами путем добавления атрибута *__slots__* в определение класса. Например:
```python
class Date:
	__slots__ = ['year', 'month', 'day']
	def __init__(self, year, month, day):
		self.year = year
		self.month = month
		self.day = day
```

Когда вы определяете *__slots__*, Python использует намного более компактное внутреннее представление экземпляров. Вместо снабжения каждого экземпляра словарём, они создаются на базе небольшого массива фиксированного размера, похожего на кортеж или список. Атрибуты, перечисленные в спецификаторе *__slots__*, отображаются внутри на конкретные индексы внутри массива. Побочный эффект использования слотов в том, что теряется возможность добавления новых атрибутов к экземплярам — у вас будет возможность использовать только атрибуты, перечисленные в спецификаторе *__slots__*.

### Обсуждение
Объем сэкономленной с помощью слотов памяти варьируется в зависимости от количества и типа хранимых атрибутов. Однако в общем случае общий объем использования памяти сравним с тем, который бы потребовался для сохранения этих данных в кортеже. Чтобы дать вам пищу для размышлений, упомянем, что сохранение одного экземпляра *Date* без использования слотов потребует 428 байтов на 64-битной версии Python. Если опеределены слоты, объем падает до 156 байтов. В программах, работающих с большим количеством дат одновременно, это может привести к значительному снижению использования памяти.

Хотя слоты могут показаться возможностей, которая будет полезна всегда, вы должны сопротивляться желанию использовать их повсюду. Очень многие компоненты Python основаны на стандартной реализации на базе словарей. Также нужно отметить, что классы, которые определяют слоты, не поддерживают некоторые возможности — такие как, например, множественное наследование. По большей части вы должны использовать слоты только в классах, которые служат структурами данных в вашей программе (то есть ваша программа создает миллионы экземпляров какого-то класса).

Часто слоты неправильно понимают как инструмент для инкапсуляции, который запрещает пользователям добавлять новые атрибуты к экземплярам. Хотя это действительно является побочным эффектом использования слотов, это не было целью их появления в языке. __slots__ изначально задумывались именно как инструмент для оптимизации.   

## 8.5. Инкапсуляция имён в классе
### Задача
Вам нужно инкапсулировать «приватные» (частные) данные в экземпляре класса, но вас беспокоит, что в Python нет контроля доступа.

### Решение
Вместо того, чтобы полагаться на возможности языка по инкапсулированию данных, от программистов на Python ожидается соблюдение определённых соглашений о наименовании, касающихся намеренного использования данных и методов. Первое соглашение состоит в том, что любое имя, которое начинается с одного нижнего подчеркивания (_) должно рассматриваться как внутренняя реализация. Например:
```python
class A:
	def __init__(self):
		self._internal = 0	 # An internal attribute
		self.public = 1		 # A public attribute
	
	def public_method(self):
		'''
		A public method
		'''
		...
		
	def _internal_method(self):
		...
``` 

Python не запрещает доступ к внутренним именам. Однако это считается неправильным, и в результате может получиться хрупкий код. Также стоит отметить, что начало имен с нижнего подчеркивания также используется для имён модулей и функций уровня модуля. Например, если вы видите имя модуля, которое начинается с нижнего подчёркивания, (например, *_socket*), то это внутренняя реализация. Похожим образом функции уровня модуля, такие как *sys._getframe()*, должны применяться очень осторожно. 

Вы можете натолкнуться на имена внутри классов, которые начинаются с двух нижних подчёркиваний (__). Например:
```python
class B:
	def __init__(self):
		self.__private = 0
	def __private_method(self):
		...
	def public_method(self):
		...
	self.__private_method()
		...
``` 

Использование двойного нижнего подчёркивания вызывает искажение имени в другое. Если говорить конкретно, то частные атрибуты в представленном выше классе переименуются в *_B__private* и *_B__private_method* соответственно. Здесь вы можете спросить, зачем нужны такие искажения? Причина — наследование: такие атрибуты не могут быть переопределены через наследование. Например:
```python
class C(B):
	def __init__(self):
		super().__init__()
		self.__private = 1 	# Does not override B.__private
	# Does not override B.__private_method()
	def __private_method(self):
		...
```

Здесь частные имена *__private* и *__private_method* переименуются в *_C__private* и *_C__private_method*, которые отличаются от искаженных имён в базовом классе B.

### Обсуждение
Факт того, что существует два разных соглашения (одиночное нижнее подчеркивание против двойного) для определения «частных» атрибутов, приводит к логичному вопросу того, какой стиль вам стоит использовать. Для большей части вашего кода вы, вероятно, должны делать ваши имена непубличными с помощью одного нижнего подчеркивания. Если же, однако, вы знаете, что ваш код будет использовать подклассы, и есть внутренние атрибуты, которые должны быть скрыты от подклассов, используйте двойные подчеркивания. 

Также стоит отметить, что иногда вы можете определить переменную, которая вступает в конфликт с зарезервированным именем. Для таких случаев нужно использовать нижнее подчёркивание в конце:
```python
lambda_ = 2.0	# Trailing _ to avoid clash with lambda keyword
```

Причина не использовать нижнее подчеркивание в начале имени в этом случае заключается в том, что это позволяет избежать сомнений по поводу причины его использования (то есть использование подчёркивания в начале может быть истолковано как указание на приватность значения). Использование одного подчёркивания в конце решает эту проблему.

## 8.6. Создание управляемых атрибутов
### Задача
Вы хотите добавить дополнительную обработку (например, проверку типов или валидацию) в получение или установку атрибута экземпляра.

### Решение
Простой способ кастомизировать доступ к атрибуту заключается в определении свойства (property). Например, этот код определяет свойство, которое добавляет простую проверку типов к атрибуту:
```python
class Person:
	def __init__(self, first_name):
		self.first_name = first_name
	
	# Getter function
	@property
	def first_name(self):
		return self._first_name
	
	# Setter function
	@first_name.setter
	def first_name(self, value):
		if not isinstance(value, str):
			raise TypeError('Expected a string')
		self._first_name = value
	
	# Deleter function (optional)
	@first_name.deleter
	def first_name(self):
		raise AttributeError("Can't delete attribute")
```

В представленном коде есть три относящихся друг к другу метода, которые должны иметь одинаковое имя. Первый метод — это функция-геттер (getter), она устанавливает *first_name* как свойство. Два других метода прикрепляют необязательные функции сеттер (setter) и делитер (deleter) к свойству (property) *first_name*. Важно подчеркнуть, что декораторы *@first_name.setter* и *@first_name.deleter* не будут определены, если *first_name* не было установлено как свойство с помощью *@property*.

Важнейшая возможность свойства в том, что оно выглядит так же, как обычный атрибут, но при доступе автоматически активируются методы геттер, сеттер и делитер. Например:
```python
>>> a = Person('Guido')
>>> a.first_name 		# Calls the getter
'Guido'
>>> a.first_name = 42 	# Calls the setter
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "prop.py", line 14, in first_name
		raise TypeError('Expected a string')
TypeError: Expected a string
>>> del a.first_name
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: can't delete attribute
>>>
```

Когда вы имплементируете свойство, данные (если они имеются) нужно где-то сохранять. Поэтому в методах получения и установки вы видите прямую манипуляцию атрибутом *_first_name*, в котором и находятся данные. Вы также можете спросить, почему метод *__init__()* устанавливает *self.first_name*, а не *self._first_name*. В этом примере весь смысл свойства в применении проверки типа при установке значения атрибута. ПОэтому есть вероятность, что вы также захотите провести такую проверку при инициализации. Устанавливая *self.first_name*, операция установки использует метод-сеттер (в противоположность обходному пути прямого доступа к self._first_name).

Свойства также могут быть определены для существующих методов получения и установки. Например:
```python 
class Person:
	def __init__(self, first_name):
		self.set_first_name(first_name)
	
	# Getter function
	def get_first_name(self):
		return self._first_name
	
	# Setter function
	def set_first_name(self, value):
		if not isinstance(value, str):
			raise TypeError('Expected a string')
		self._first_name = value
	
	# Deleter function (optional)
	def del_first_name(self):
		raise AttributeError("Can't delete attribute")
	
	# Make a property from existing get/set methods
	name = property(get_first_name, set_first_name, del_first_name)
```

### Обсуждение
Свойство — это на самом деле коллекция связанных вместе методов. Если вы изучите класс со свойством, то обнаружите сырые методы *fget*, *fset* и *fdel* в атрибутах самого свойства. 
```python
>>> Person.first_name.fget
<function Person.first_name at 0x1006a60e0>
>>> Person.first_name.fset
<function Person.first_name at 0x1006a6170>
>>> Person.first_name.fdel
<function Person.first_name at 0x1006a62e0>
>>>
```
Обычно вы не будете вызывать *fget* и *fset* напрямую, но они автоматически вызываются, когда происходит доступ к свойству.

Свойства должны быть использованы только в случаях, когда вы на самом деле нуждаетесь в выполнении дополнительных операций при доступе к атрибутам. Иногда программисты, пришедшие из языков типа Java, считают, что любой доступ нужно осуществлять с помощью геттеров и сеттеров, и пишут такой код:
```python
class Person:
	def __init__(self, first_name):
		self.first_name = name
	@property
	def first_name(self):
		return self._first_name
	@first_name.setter
	def first_name(self, value):
		self._first_name = value
```

Не пишите свойства, которые не ничего не добавляют (как в примере выше). Во-первых, они делают ваш код многословным и непонятным другим. Во-вторых, они сделают вашу программу намного медленнее. И последнее: с точки зрения проектирования в этом нет никакого преимущества. Если вы в будущем решите, что нужно добавить дополнительную обработку к доступу к обычному атрибуту, то просто превратите его в свойство, что не приведет к необходимости менять существующий код. Это возможно, потому что синтаксис кода, который осуществляет доступ к атрибуту, останется неизменным. 

Свойства также могут быть способом определить вычисляемые атрибуты. Это атрибуты, которые не хранятся, а вычисляются по запросу. Например:
```python
import math
class Circle:
	def __init__(self, radius):
		self.radius = radius
	@property
	def area(self):
		return math.pi * self.radius ** 2
	@property
	def perimeter(self):
		return 2 * math.pi * self.radius
```  

Здесь использование свойств позволяет создать единообразный интерфейс экземпляра, в котором к *radius*, *area* и *perimeter* доступ осуществляется как к простым атрибутам, в противоположность смеси простых атрибутов и вызовов методов. Например:
```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area 			# Notice lack of ()
50.26548245743669
>>> c.perimeter   	# Notice lack of ()
25.132741228718345
>>>
```

Хотя свойства дают вам элегантный интерфейс программирования, иногда вы иногда можете захотеть использовать геттеры и сеттеры напрямую. Например:
```python
>>> p = Person('Guido')
>>> p.get_first_name()
'Guido'
>>> p.set_first_name('Larry')
>>>
```

Такое использование часто возникает, когда код на Python интегрируется в более крупную инфраструктуру систем или программ. Например, предположим, что класс Python будет вставлен в большую распределённую систему, основанную на удалённых вызовах процедур или распределённых объектов. В таких условиях может оказаться намного легче работать с явными методами установки и получения (вызывая их как обычные методы), вместо использования свойств для скрытого совершения таких вызовов.

И последнее: не пишите код на Python, в котором много повторяющихся определений свойств. Например:
```python
class Person:
	def __init__(self, first_name, last_name):
		self.first_name = first_name
		self.last_name = last_name
		
	@property
	def first_name(self):
		return self._first_name

	@first_name.setter
	def first_name(self, value):
		if not isinstance(value, str):
			raise TypeError('Expected a string')
		self._first_name = value
	
	# Repeated property code, but for a different name (bad!)
	@property
	def last_name(self):
		return self._last_name

	@last_name.setter
	def last_name(self, value):
		if not isinstance(value, str):	
			raise TypeError('Expected a string')
		self._last_name = value
```

Повторение кода ведёт к раздутому, подверженному ошибкам и уродливому коду. Есть намного лучшие пути добиться того же, используя дескрипторы или замыкания. См. **рецепт 8.9.** и рецепт **9.21.**.

## 8.7. Вызов метода родительского класса
### Задача
Вы хотите вызвать метод родительского класса вместо метода, который был переопеределён в подклассе.

### Решение
Чтобы вызвать метод из родительского класса (суперкласса), используйте функцию *super()*. Например:
```python
class A:
	def spam(self):
		print('A.spam')

class B(A):
	def spam(self):
		print('B.spam')
		super().spam()		# Call parent spam()
```

Очень распространённый случай использования *super()* — это применение её к методу __init__(), чтобы убедиться в правильной инициализации родителей:
```python
class A:
	def __init__(self):
		self.x = 0

class B(A):
	def __init__(self):
		super().__init__()
		self.y = 1
```  

Также *super()* часто используется в коде, который переопределяет один из специальных методов Python. Например:
```python
class Proxy:
	def __init__(self, obj):
		self._obj = obj

	# Delegate attribute lookup to internal obj
	def __getattr__(self, name):
		return getattr(self._obj, name)
	
	# Delegate attribute assignment
	def __setattr__(self, name, value):
		if name.startswith('_'):
			super().__setattr__(name, value) 	# Call original __setattr__
	else:
		setattr(self._obj, name, value)
```

В этом коде реализация *__setaddr__()* включает проверку имени. Если имя начинается с нижнего подчёркивания (_), он вызывает изначальную реализацию *__setaddr__()* через использование *super()*. В противном случае оно делегируется внутреннему объекту *self._obj*. Это выглядит немного странно, но *super()* работает, даже если явно не указан базовый класс. 

### Обсуждение
Правильное использование функции *super()* — это один из самых плохо понимаемых аспектов Python. Вы наверняка встретите код, который напрямую вызывает метод родительского класса:
```python
class Base:
	def __init__(self):
		print('Base.__init__')

class A(Base):
	def __init__(self):
		Base.__init__(self)	
		print('A.__init__')
```

Хотя это обычно «работает», это может привести к странным проблемам в продвинутых программах, использующих множественное наследование. Например:
```python
class Base:
	def __init__(self):
		print('Base.__init__')

class A(Base):
	def __init__(self):
		Base.__init__(self)
		print('A.__init__')

class B(Base):
	def __init__(self):
		Base.__init__(self)
		print('B.__init__')

class C(A,B):
	def __init__(self):
		A.__init__(self)
		B.__init__(self)
		print('C.__init__')
``` 

Если вы запустите эту программу, то увидите, что метод *Base.__init__()* вызывается дважды:
```python
>>> c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
>>>
```

Дублирование вызова *Base.__init__()* может не нанести вреда, но может и всё поломать. Если же вы измените код так, чтобы он использовал *super()* всё будет работать:
```python
class Base:
	def __init__(self):
		print('Base.__init__')

class A(Base):
	def __init__(self):
		super().__init__()
		print('A.__init__')

class B(Base):
	def __init__(self):
		super().__init__()
		print('B.__init__')

class C(A,B):
	def __init__(self):
		super().__init__()	 # Only one call to super() here
		print('C.__init__')
```

При использовании этой новой версии вы обнаружите, что каждый метод *__init__()* вызывается только один раз:
```python
>>> c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
>>>
```

Чтобы понять, почему это работает, мы должны сделать шаг назад и обсудить, как в Python реализовано наследование. Для каждого класса, который вы определите, Python вычисляет так называемый список порядка разрешения методов (ПРМ, MRO). Список ПРМ — это просто линейно упорядоченные базовые классы. Например:
```python
>>> C.__mro__
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>,
<class '__main__.Base'>, <class 'object'>)
>>>
```

Чтобы реализовать наследование, Python начинает с самого левого класса и проходит по классам в списке ПРМ слева направо, пока не найдёт нужный атрибут.

Определение самого списка ПРМ происходит путём использования [C3-линеаризации](https://ru.wikipedia.org/wiki/C3-%D0%BB%D0%B8%D0%BD%D0%B5%D0%B0%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F). Не будем погружаться в математические тонкости, но по сути это сортировка слиянием ПРМ родительских классов с тремя условиями:
— классы-потомки проверяются перед родительскими;
— множественные родительские классы проверяются по порядку;
— если для следующего класса есть два валидных выбора, выбирается класс от первого родителя.

Если честно, вам нужно знать только то, что порядок классов в списке ПРМ «имеет смысл» для практически любой классовой иерархии, которую вы реализуете.

Когда вы используете функцию *super()*, Python продолжает свой поиск, начиная со следующего класса в ПРМ. Пока каждый переопределённый метод использует *super()* и вызывает её один раз, поток управления найдет свой путь через весь список ПРМ, и каждый метод будет вызван единожды. Вот почему вы не должны делать двойные вызовы *Base.__init__()* во втором примере.  

Аспект *super()*, который может удивить, это то, что она не обязательно идёт в прямого родителя следующего в ПРМ класса, а также то, что вы можете использовать её даже с классом, не имеющим прямого родителя. Рассмотрим, например, такой класс:
```python
class A:
	def spam(self):
		print('A.spam')
		super().spam()
``` 

Если вы попробуете его использовать, вы обнаружите, что он не работает:
```python
>>> a = A()
>>> a.spam()
A.spam
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "<stdin>", line 4, in spam
AttributeError: 'super' object has no attribute 'spam'
>>>
```

Но посмотрите, что случится, если вы будете использовать этот класс с множественным наследованием:
```python
>>> class B:
...		def spam(self):
...			print('B.spam')
...
>>> class C(A,B):
...		pass
...
>>> c = C()
>>> c.spam()
A.spam
B.spam
>>>
```

Здесь вы видите, что использование *super().spam()* в классе *A* на самом деле вызвало метод *spam()* в классе *B* — классе, абсолютно никак не связанном с A! Это объясняется ПРМ класса *C*:
```python
>>> C.__mro__
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>,
<class 'object'>)
>>>
```

Использование *super()* таким способом наиболее часто можно встретить в классах-миксинах (примесях). См. рецепт *8.13.* и рецепт *8.18.*  

Но поскольку *super()* может вызывать метод, который вы не ожидаете, есть несколько общих правил, которым вам нужно попытаться следовать. Во-первых, убедитесь, что все методы с одинаковыми именами в иерархии наследования имеют совместимые сигнатуры вызова (то есть одинаковое количество аргументов, имена аргументов). Это позволяет удостовериться, что *super()* не сломается, если попытается вызвать метод класса, который не является прямым родителем. Во-вторых, обычно является хорошей идеей убедиться, что класс верхнего уровня предоставляет реализацию метода, так что поиск, который идёт по цепи ПРМ, завершится каким-то конкретным методом. 

Использование *super()* иногда становится источником дебатов в сообществе Python. Однако при всех прочих равных вам стоит использовать её в современном коде. Рэймонд Хеттингер написал отличный пост [“Python’s super() Considered Super!”](http://rhettinger.wordpress.com/2011/05/26/super-considered-super), в котором вы найдёте ещё больше примеров того, почему *super()* может быть суперкрутой штукой.


## 8.8. Расширение свойства в подклассе
### Задача
Внутри подкласса вы хотите расширить функциональность свойства, определённого в родительском классе.

### Решение
Рассмотрите следующий код, в котором определяется свойство:
```python
class Person:
	def __init__(self, name):
		self.name = name
	
	# Getter function
	@property
	def name(self):
		return self._name
	
	# Setter function
	@name.setter
	def name(self, value):
		if not isinstance(value, str):
			raise TypeError('Expected a string')
		self._name = value
	
	# Deleter function
	@name.deleter
	def name(self):
		raise AttributeError("Can't delete attribute")
```

Вот пример класса, который наследует от *Person* и расширяет свойство *name* новой функциональностью:
```python
class SubPerson(Person):
	@property
	def name(self):
		print('Getting name')
		return super().name
	
	@name.setter
	def name(self, value):
		print('Setting name to', value)
		super(SubPerson, SubPerson).name.__set__(self, value)
	
	@name.deleter
	def name(self):
		print('Deleting name')
		super(SubPerson, SubPerson).name.__delete__(self)
```

Вот пример использования нового класса:
```python
>>> s = SubPerson('Guido')
Setting name to Guido
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
Setting name to Larry
>>> s.name = 42
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 16, in name
		raise TypeError('Expected a string')
TypeError: Expected a string
>>>
```

Если вы хотите расширить только один из методов свойства, используйте такой код:
```python
class SubPerson(Person):
	@Person.name.getter
	def name(self):
		print('Getting name')
		return super().name
```

Или, альтернативно, только для сеттера, используйте такой код:
```python
class SubPerson(Person):
	@Person.name.setter
	def name(self, value):
		print('Setting name to', value)
		super(SubPerson, SubPerson).name.__set__(self, value)
```

### Обсуждение
Расширение свойства в подклассе заставляет столнуться с достаточно большим количеством тонких проблем, связанных с тем фактом, что свойство определяется как коллекция из геттера, сеттера и делитера, а не как один метод. Поэтому при расширении свойства вам нужно понять, будете ли вы переопределять все методы или только один.

В первом примере все методы свойства переопределяются вместе. В каждом методе используется *super()* для вызова предыдущей реализации. Использование *super(SubPerson, SubPerson).name.__set__(self, value)* в функции-сеттере — это не ошибка. Чтобы делегировать предыдущую реализацию сеттера, поток управления должен пройти через метод *__set__()* ранее определённого свойства *name*. Однако единственный способ получить этот метод — это доступ к нему как к переменной класса, а не как к переменной экземпляра. Это происходит в операции *super(SubPerson, SubPerson)*.

Если хотите переопределить только один из методов, недостаточно использовать само *@property*. Например, вот такой код не работает:
```python
class SubPerson(Person):
	@property					# Doesn't work
	def name(self):
		print('Getting name')
		return super().name
``` 

Если вы попробуете использовать получившийся код, вы обнаружите, что функция-сеттер полностью исчезла:
```python
>>> s = SubPerson('Guido')
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 5, in __init__
		self.name = name
AttributeError: can't set attribute
>>>
```

Вместо этого вы должны были изменить код так, как показано в решении:
```python
class SubPerson(Person):
	@Person.getter
	def name(self):
		print('Getting name')
		return super().name
```

Когда вы это сделаете, все ранее определённые методы свойства будут скопированы, а функция-геттер заменена. Теперь оно работает так, как ожидается:
```python
>>> s = SubPerson('Guido')
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
>>> s.name
Getting name
'Larry'
>>> s.name = 42
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 16, in name
		raise TypeError('Expected a string')
TypeError: Expected a string
>>>
```

В этом конкретном решении нет способа заменить жестко прописанное имя класса *Person* чем-то более общим. Если вы не знаете, в каком базовом классе определено свойство, вы должны использовать решение, в котором все методы свойства переопределяются, а *super()* используется для передачи управления предыдущей реализации.

Стоит отметить, что первый приём, показанный в этом рецепте, также может быть использован для расширения дескриптора, как описано в **рецепте 8.9.** Например:
```python
# A descriptor
class String:
	def __init__(self, name):
		self.name = name

	def __get__(self, instance, cls):
		if instance is None:
			return self
		return instance.__dict__[self.name]

	def __set__(self, instance, value):
		if not isinstance(value, str):
			raise TypeError('Expected a string')
		instance.__dict__[self.name] = value

# A class with a descriptor
class Person:
	name = String('name')
	def __init__(self, name):
		self.name = name

# Extending a descriptor with a property
class SubPerson(Person):
	@property
	def name(self):
		print('Getting name')
		return super().name
	
	@name.setter
	def name(self, value):
		print('Setting name to', value)
		super(SubPerson, SubPerson).name.__set__(self, value)
	
	@name.deleter
	def name(self):
		print('Deleting name')
		super(SubPerson, SubPerson).name.__delete__(self)
``` 

Наконец, стоит отметить, что к тому моменту, когда вы это прочитаете, расширение сеттеров и делитеров в подклассах может быть уже как-то упрощено. Показанное решение работает, но баг, описанный на [странице проблем Python](http://bugs.python.org/issue14965), может быть исправлен путём реализации более ясного подхода в будущих версиях Python.

## 8.9. Создание нового типа атрибута класса или экземпляра
### Задача
Вы хотите создать новый тип атрибута экземпляра с некой дополнительной функциональностью — например, с проверкой типа.

### Решение
Если вы хотите создать полностью новый тип атрибута экземпляра, определите его функциональность в форме класса-дескриптора. Вот пример:
```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
	def __init__(self, name):
		self.name = name
	
	def __get__(self, instance, cls):
		if instance is None:
			return self
		else:
			return instance.__dict__[self.name]
	
	def __set__(self, instance, value):
		if not isinstance(value, int):
			raise TypeError('Expected an int')
		instance.__dict__[self.name] = value
	
	def __delete__(self, instance):
		del instance.__dict__[self.name]
```

Дескриптор — это класс, который реализует три ключевых операции доступа к атрибутам (получение, установки и удаления) в форме специальных методов *__get__()*, *__set__()* и *__delete__()*. Эти методы работают путем получения экземпляра на вход. Затем происходит манипуляции над словарём экземпляра. 

Чтобы использовать дескриптор, экземпляры дескриптора размещаются в определении класса как переменные класса. Например:
```python
class Point:
	x = Integer('x')
	y = Integer('y')
	def __init__(self, x, y):
		self.x = x
		self.y = y
```

Когда вы это делаете, все попытки доступа к атрибуту дескриптора (то есть *x* или *y*) перехватываются методами *__get__()*, *__set__()* и *__delete__()*. Например:
```python
>>> p = Point(2, 3)
>>> p.x 			# Calls Point.x.__get__(p,Point)
2
>>> p.y = 5 		# Calls Point.y.__set__(p, 5)
>>> p.x = 2.3		# Calls Point.x.__set__(p, 2.3)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "descrip.py", line 12, in __set__
		raise TypeError('Expected an int')
TypeError: Expected an int
>>>
```

На вход каждый метод дескриптора получает экземпляр, над которым нужно провести какие-то манипуляции. Чтобы провести запрошенную операцию, соответствующим образом меняется словарь экземпляра (атрибут *__dict__*). Атрибут дескриптора *self.name* содержит ключ словаря, который используется для хранения реальных данных в словаре экземпляра.

### Обсуждение
Дескрипторы предоставляют «подкапотную» магию для большинства возможностей классов *Python*, включая *@classmethod*, *@staticmethod*, *@property* и даже *__slots__*.

Путём определения дескриптора вы можете перехватить базовые операции экземпляров (получение, установку, удаление) на очень низком уровне и полностью кастомизировать то, как они работают. Это дает вам огромные возможности, и это один из самых важных инструментов, используемых создателями продвинутых библиотек и фреймворков.

Путаница с дескрипторами иногда возникает по причине того, что они могут быть определены только на уровне класса, но не на уровне экземпляра. Поэтому вот такой код работать не будет:
```python
# Does NOT work
class Point:
	def __init__(self, x, y):	
		self.x = Integer('x') 	# No! Must be a class variable
		self.y = Integer('y')
		self.x = x
		self.y = y
``` 

А реализация метода *__get__()* сложнее, чем может показаться:
```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
	...
	def __get__(self, instance, cls):
		if instance is None:
			return self
		else:
		return instance.__dict__[self.name]
	...
```

Причина того, что *__get__()* выглядит довольно сложным, заключается в различии между переменными экземпляра и переменными класса. Если доступ к дескриптору осуществляется как к переменной класса, аргумент *instance* имеет значение *None*. В этом случае стандартным подходом будет просто вернуть сам экземпляр дескриптора (хотя разрешается также любой тип нестандартной обработки). Например:
```python
>>> p = Point(2,3)
>>> p.x 			# Calls Point.x.__get__(p, Point)
2
>>> Point.x 		# Calls Point.x.__get__(None, Point)
<__main__.Integer object at 0x100671890>
>>>
```  

Дескрипторы часто являются одним из компонентов крупного фреймворка, использующего декораторы или метаклассы. В этом случае их использование может быть практически незаметно. В качестве примера приведём более продвинутый код, основанный на дескрипторах, использующий декоратор класса:
```python
# Descriptor for a type-checked attribute
class Typed:
	def __init__(self, name, expected_type):
		self.name = name
		self.expected_type = expected_type

	def __get__(self, instance, cls):
		if instance is None:
			return self
		else:
			return instance.__dict__[self.name]

	def __set__(self, instance, value):
		if not isinstance(value, self.expected_type):
			raise TypeError('Expected ' + str(self.expected_type))
		instance.__dict__[self.name] = value

	def __delete__(self, instance):
		del instance.__dict__[self.name]

# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
	def decorate(cls):
		for name, expected_type in kwargs.items():
			# Attach a Typed descriptor to the class
			setattr(cls, name, Typed(name, expected_type))
		return cls
	return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
	def __init__(self, name, shares, price):
		self.name = name
		self.shares = shares
		self.price = price
```

Стоит подчеркнуть, что вам, вероятно, не стоит писать дескриптор, если вы хотите просто кастомизировать доступ к одному атрибуту конкретного класса. Для этого проще использовать свойство, как описано в **рецепте 8.6.** Дескрипторы более полезны в ситуациях, где предполагается много переиспользовать код (то есть если вы хотите использовать функциональность, предоставленную дескриптором, в сотнях мест в вашем коде или предоставить ее как возможность библиотеки).

## 8.10. Использование лениво вычисляемых свойств
### Задача
Вы хотите определить доступный только для чтения атрибут как свойство, которое вычисляется при доступе к нему. Однако после произошедшего доступа значение должно кэшироваться и не пересчитываться при следующих запросах.

### Решение
Эффективный путь определения ленивых атрибутов — это использование класса-дескриптора:
```python
class lazyproperty:
	def __init__(self, func):
		self.func = func
	
	def __get__(self, instance, cls):
		if instance is None:
			return self
		else:
			value = self.func(instance)
			setattr(instance, self.func.__name__, value)
			return value
```

Чтобы использовать этот код, вы можете применить его в классе:
```python
import math

class Circle:
	def __init__(self, radius):
		self.radius = radius

	@lazyproperty
	def area(self):
		print('Computing area')
		return math.pi * self.radius ** 2

	@lazyproperty
	def perimeter(self):
		print('Computing perimeter')
		return 2 * math.pi * self.radius
```

Вот пример использования в интерактивном сеансе:
```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.perimeter
Computing perimeter
25.132741228718345
>>> c.perimeter
25.132741228718345
>>>
```

Обратите внимание, что сообщения “Computing area” и “Computing perimeter” появляются только один раз.

### Обсуждение
Во многих случаях цель применения лениво вычисляемых атрибутов заключается в увеличении производительности. Например, вы можете избежать вычисления значений, если только они действительно где-то не нужны. Показанное решение делает именно это, используя тонкую особенность дескриптора, чтобы реализовать функциональность самым эффективным способом. 

Как показано в других рецептах (например, в **рецепте 8.9.**), когда дескриптор помещается в определение класса, его методы *__get__()*, *__set__()* и *__delete__() задействуются при доступе к атрибуту. Но если дескриптор определяет только метод *__get__()*, то у него намного более слабое связывание, нежели обычно. В частности, метод *__get__()* срабатывает только если атрибут, к которому осуществляется доступ, отсутствует в словаре экземпляра.

Класс *lazyproperty* использует это путём того, что заставляет метод *__get__()* сохранять вычисленное значение в экземпляре, используя то же имя, что и само свойство. С помощью этого значение сохраняется в словаре экземпляра и отключает будущие вычисления свойства. Вы можете понаблюдать за этим в таком примере:
```python
>>> c = Circle(4.0)
>>> # Get instance variables
>>> vars(c)
{'radius': 4.0}

>>> # Compute area and observe variables afterward
>>> c.area
Computing area
50.26548245743669
>>> vars(c)
{'area': 50.26548245743669, 'radius': 4.0}

>>> # Notice access doesn't invoke property anymore
>>> c.area
50.26548245743669

>>> # Delete the variable and see property trigger again
>>> del c.area
>>> vars(c)
{'radius': 4.0}
>>> c.area
Computing area
50.26548245743669
>>>
```

Возможный недостаток этого рецепта в том, что вычисленное значение становится изменяемым после создания. Например:
```python
>>> c.area
Computing area
50.26548245743669
>>> c.area = 25
>>> c.area
25
>>>
```

Если это проблема, вы можете использовать немного менее эффективную реализацию:
```python
def lazyproperty(func):
	name = '_lazy_' + func.__name__
	@property
	def lazy(self):
		if hasattr(self, name):
			return getattr(self, name)
		else:
			value = func(self)
			setattr(self, name, value)
			return value
	return lazy
```

Если вы используете эту версию, вы обнаружите, что операции установки недоступны. Например:
```python
>>> c = Circle(4.0)
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.area = 25
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
>>>
```

Недостаток такого подхода в том, что все операции получения значения проводятся функцию-геттер свойства. Это менее эффективно, чем простой поиск значения в словаре экземпляра, как сделано в первом решении.

За сведениями о свойствах и управлении атрибутами обратесь к **рецепту 8.6.** Дескрипторы описаны в **рецепте 8.9.**

## 8.11. Упрощение инициализации структур данных
### Задача
Вы создаете много классов, которые служат структурами данных, но уже устали от написания повторяющихся и шаблонных функций *__init__()*.

### Решение
Часто вы можете обобщить инициализацию структур данных в единственной функции *__init__()*, определённой в общем базовом классе. Например:
```python
class Structure:
	# Class variable that specifies expected fields
	_fields= []
	def __init__(self, *args):
		if len(args) != len(self._fields):
			raise TypeError('Expected {} arguments'.format(len(self._fields)))
	
		# Set the arguments
		for name, value in zip(self._fields, args):
			setattr(self, name, value)

# Example class definitions
if __name__ == '__main__':
	class Stock(Structure):
		_fields = ['name', 'shares', 'price']

	class Point(Structure):
	_fields = ['x','y']

	class Circle(Structure):
		_fields = ['radius']
		def area(self):
			return math.pi * self.radius ** 2
```

Если вы будете использовать эти классы, то обнаружите, что они легко конструируются. Например:
```python
>>> s = Stock('ACME', 50, 91.1)
>>> p = Point(2, 3)
>>> c = Circle(4.5)
>>> s2 = Stock('ACME', 50)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "structure.py", line 6, in __init__
		raise TypeError('Expected {} arguments'.format(len(self._fields)))
TypeError: Expected 3 arguments
```

Если вы решите реализовать поддержку именованных аргументов, то для этого есть несколько способов проектирования. Один из них — такое отображение именованных аргументов, чтобы они соответстовали только именам атрибутов, определённым в *_fields*. Например:
```python
class Structure:
	_fields= []
	def __init__(self, *args, **kwargs):
		if len(args) > len(self._fields):
			raise TypeError('Expected {} arguments'.format(len(self._fields)))
	
		# Set all of the positional arguments
		for name, value in zip(self._fields, args):
			setattr(self, name, value)
		
		# Set the remaining keyword arguments
		for name in self._fields[len(args):]:
			setattr(self, name, kwargs.pop(name))
		
		# Check for any remaining unknown arguments
		if kwargs:
			raise TypeError('Invalid argument(s): {}'.format(','.join(kwargs)))

# Example use
if __name__ == '__main__':
	class Stock(Structure):
		_fields = ['name', 'shares', 'price']

	s1 = Stock('ACME', 50, 91.1)
	s2 = Stock('ACME', 50, price=91.1)
	s3 = Stock('ACME', shares=50, price=91.1)
``` 

Другой возможный выбор — использование именованных аргументов как средства добавления дополнительных атрибутов, не определённых в *_fields*, к структуре. Например:
```python
class Structure:
	# Class variable that specifies expected fields
	_fields= []
	def __init__(self, *args, **kwargs):
		if len(args) != len(self._fields):
			raise TypeError('Expected {} arguments'.format(len(self._fields)))

		# Set the arguments
		for name, value in zip(self._fields, args):
			setattr(self, name, value)

		# Set the additional arguments (if any)
		extra_args = kwargs.keys() - self._fields
		for name in extra_args:
			setattr(self, name, kwargs.pop(name))
		if kwargs:
			raise TypeError('Duplicate values for {}'.format(','.join(kwargs)))

# Example use
if __name__ == '__main__':
	class Stock(Structure):
		_fields = ['name', 'shares', 'price']

	s1 = Stock('ACME', 50, 91.1)
	s2 = Stock('ACME', 50, 91.1, date='8/2/2012')
```

### Обсуждение
Приём определения метода *__init__()* общего назначения может оказаться чрезвычайно полезным, если вы когда-либо будете писать программу, построенную на основе большого количества маленьких структур данных. Так вы напишете намного меньше кода, чем при ручном создании таких методов *__init__()*:
```python
class Stock:
	def __init__(self, name, shares, price):
		self.name = name
		self.shares = shares
		self.price = price

class Point:
	def __init__(self, x, y):
		self.x = x
		self.y = y

class Circle:
	def __init__(self, radius):
		self.radius = radius
		def area(self):
		return math.pi * self.radius ** 2
```

Тонкий аспект реализации касается механизма, который используется для установки значений с помощью функции *setattr()*. Вместо этого вы можете склоняться к прямому доступу к словарю экземпляра. Например:
```python
class Structure:
# Class variable that specifies expected fields
	_fields= []
	def __init__(self, *args):
		if len(args) != len(self._fields):
			raise TypeError('Expected {} arguments'.format(len(self._fields)))
		
		# Set the arguments (alternate)
		self.__dict__.update(zip(self._fields,args))
```

Хотя это работает, часто небезопасно делать предположения о реализации подкласса. Если подкласс решит использовать *__slots__* или обернёт конкретный атрибут в свойство (или дескриптор), прямой доступ к словарю экземпляра поломается. Приведённое в рецепте решение обладает максимально общей областью применения и не делает предположений по поводу подклассов. 

Потенциальный недостаток этого приёма заключается в воздействии на документацию и справочные возможности IDE. Если пользователей вызывает справку по конкретному классу, требуемые аргументы не будут описаны обычным способом. Например:
```python
>>> help(Stock)
Help on class Stock in module __main__:

class Stock(Structure)
...
| Methods inherited from Structure:
|
| __init__(self, *args, **kwargs)
|
...
>>>
```

Многие из этих проблем могут быть исправлены путём прикрепления или принудительного использования сигнатуры типов в функции *__init__()*. **См. рецепт 9.16.**

Также нужно отметить, что можно автоматически инициализировать переменные экземпляра, используя вспомогательную функцию и так называемый «фреймхак». Например:
```python
def init_fromlocals(self):
	import sys
	locs = sys._getframe(1).f_locals
	for k, v in locs.items():
		if k != 'self':
			setattr(self, k, v)

class Stock:
	def __init__(self, name, shares, price):
		init_fromlocals(self)
```

В этом варианте функция *init_fromlocals()* использует *sys._getframe()*, чтобы подсмотреть локальные переменные вызывающего метода. Если использовать её как первый шаг в методе *__init__()*, локальные переменные будут такими же, как и переданные аргументы, и смогут быть легко использованы для установки атрибутов с такими же именами. Хотя этот подход обходит проблему получения правильной сигнатуры вызова в IDE, он работает на 50% медленнее, чем представленное в рецепте решение, и использует больше сложной «подкапотной» магии. Если вашему коду не нужна эта дополнительная способность, в большинстве случаев более простое решение работает просто отлично.

## 8.12. Определение интерфейса или абстрактного базового класса
### Задача
Вы хотите определить класс, который будет служить интерфейсом, или абстрактный базовый класс, из которого вы сможете производить проверку типов и убеждаться, что некоторые методы реализованы в подклассах.

### Решение
Чтобы определить абстрактный базовый класс, воспользуйтесь модулем *abc*. Например:
```python
from abc import ABCMeta, abstractmethod

class IStream(metaclass=ABCMeta):
	@abstractmethod
	def read(self, maxbytes=-1):
		pass
	@abstractmethod
	def write(self, data):
		pass
```

Главная возможность абстрактного базового класса в том, что он не может напрямую порождать экземпляры. Если вы попробуете это сделать, то получите ошибку:
```python
a = IStream() 	# TypeError: Can't instantiate abstract class
				# IStream with abstract methods read, write
```

Вместо этого абстрактный базовый класс предназначен для использования в качестве базового класса для других классов, от которых ожидается реализация требуемых методов. Например:
```python
class SocketStream(IStream):
	def read(self, maxbytes=-1):
		...
	def write(self, data):
		...
```

В основном абстрактные базовые классы используются в коде, где нужно принудительно реализовать ожидаемый программный интерфейс. Например, можно посмотреть на базовый класс *IStream* как на высокоуровневую спецификацию для интерфейса, который позволяет читать и записывать данные. Код, который явно проверяет наличие этого интерфейса, может быть написан так:
```python
def serialize(obj, stream):
	if not isinstance(stream, IStream):
		raise TypeError('Expected an IStream')
...
``` 

Вы можете подумать, что такого рода проверка типов работает только путем создания подкласса абстрактного базового класса, но абстрактный базовый класс позволяет другим классам регистрироваться как реализовывающим требуемый интерфейс. Например, вы можете сделать так:
```python
import io

# Register the built-in I/O classes as supporting our interface
IStream.register(io.IOBase)

# Open a normal file and type check
f = open('foo.txt')
isinstance(f, IStream)		# Returns True
``` 

Нужно отметить, что *@abstractmethod* может быть также применён к статическим методам, методам класса и свойствам. Вам нужно просто убедиться, что вы применяете его в правильной последовательности, где *@abstractmethod* появляется сразу перед определением функции, как показано тут:
```python
from abc import ABCMeta, abstractmethod

class A(metaclass=ABCMeta):
	@property
	@abstractmethod
	def name(self):
		pass

	@name.setter
	@abstractmethod
	def name(self, value):
		pass

	@classmethod
	@abstractmethod
	def method1(cls):
		pass

	@staticmethod
	@abstractmethod
	def method2():
		pass
```

### Обсуждение
Предопределенные абстрактные базовые классы можно найти во многих местах стандартной библиотеки. Модуль *collections* определяет разнообразные абстрактные базовые классы, относящиеся к контейнерам и итераторам (последовательности, отображения, множества и т.п.), библиотека *numbers* определяет абстрактные базовые классы, связанные с числовыми объектами (целые числа, числа с плавающей точкой, дроби и т.п.), библиотека *io* — связанные с управлением вводом-выводом.

Вы можете использовать предопределённые абстрактные базовые классы для выполнения более обобщённой проверки типов. Вот несколько примеров:
```python
import collections

# Check if x is a sequence
if isinstance(x, collections.Sequence):
	...

# Check if x is iterable
if isinstance(x, collections.Iterable):
	...

# Check if x has a size
if isinstance(x, collections.Sized):
...

# Check if x is a mapping
if isinstance(x, collections.Mapping):
	...
```

Стоит отметить, что на момент написания этой книги некоторые библиотечные модули не используют эти предопределённые классы так, как вы могли бы предположить. Например:
```python
from decimal import Decimal
import numbers

x = Decimal('3.4')
isinstance(x, numbers.Real)		# Returns False
```

Хотя значение 3.4 технически является реальным числом, результат проверки типов не подтверждает этого, чтобы помочь избежать случайного смешивания чисел с плавающих точкой и десятичных дробей. Поэтому если вы используете функциональность абстрактных базовых классов, стоит аккуратно писать тесты, которые проверяют, что поведение именно таково, какое вам требуется.

Хотя абстрактные базовые классы облегчают проверку типов, это не стоит слишком часто использовать в программах. В своей основе Python является гибким динамическим языком. Попытки устроить повсюду принудительные ограничения типов ведут к более сложному коду, нежели необходимо. Вы должны принять гибкость Python.


## 8.13. Реализации модели данных или системы типов
### Решение
Вы хотите определить различные структуры данных, но вы хотите установить принудительные ограничения на значения, которые можно назначить определенным атрибутам.

### Решение
В этой задаче вы сталкиваетесь с необходимостью разместить проверки или ассерты (assertions), которые вызываются при установке (присваивании значения) определенным атрибутам экземпляра. Чтобы сделать это, вам нужно кастомизировать установку атрибутов отдельно для каждого атрибута. Для этого нужно использовать дескрипторы.

Следующий пример иллюстрирует использование дескрипторов для реализации системы типов и фреймворка проверки значений:
```python
# Base class. Uses a descriptor to set a value
class Descriptor:
	def __init__(self, name=None, **opts):
		self.name = name
		for key, value in opts.items():
			setattr(self, key, value)
	def __set__(self, instance, value):
		instance.__dict__[self.name] = value

# Descriptor for enforcing types
class Typed(Descriptor):
	expected_type = type(None)

	def __set__(self, instance, value):
		if not isinstance(value, self.expected_type):
			raise TypeError('expected ' + str(self.expected_type))
		super().__set__(instance, value)

# Descriptor for enforcing values
class Unsigned(Descriptor):
	def __set__(self, instance, value):
		if value < 0:
			raise ValueError('Expected >= 0')
		super().__set__(instance, value)

class MaxSized(Descriptor):
	def __init__(self, name=None, **opts):
		if 'size' not in opts:
			raise TypeError('missing size option')
		super().__init__(name, **opts)

	def __set__(self, instance, value):
		if len(value) >= self.size:
			raise ValueError('size must be < ' + str(self.size))
		super().__set__(instance, value)
``` 

Эти классы нужно рассматривать как базовые строительные блоки, из которых вы создаете модель данных или систему типов. Продолжая пример, приведём код, который реализует некоторые другие типы данных:
```python
class Integer(Typed):
	expected_type = int

class UnsignedInteger(Integer, Unsigned):
	pass

class Float(Typed):
	expected_type = float

class UnsignedFloat(Float, Unsigned):
	pass

class String(Typed):
	expected_type = str

class SizedString(String, MaxSized):
	pass
```

Используя эти объекты типов, можно определить такой класс:
```python
class Stock:
	# Specify constraints
	name = SizedString('name',size=8)
	shares = UnsignedInteger('shares')
	price = UnsignedFloat('price')
	def __init__(self, name, shares, price):
		self.name = name
		self.shares = shares
		self.price = price
```

Применив ограничения, вы обнаружите, что присвоение атрибутов теперь валидируется. Например:
```python
>>> s = Stock('ACME', 50, 91.1)
>>> s.name
'ACME'
>>> s.shares = 75
>>> s.shares = -10
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 17, in __set__
		super().__set__(instance, value)
	File "example.py", line 23, in __set__
		raise ValueError('Expected >= 0')
ValueError: Expected >= 0
>>> s.price = 'a lot'
raceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 16, in __set__
		raise TypeError('expected ' + str(self.expected_type))
TypeError: expected <class 'float'>
>>> s.name = 'ABRACADABRA'
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "example.py", line 17, in __set__
		super().__set__(instance, value)
	File "example.py", line 35, in __set__
		raise ValueError('size must be < ' + str(self.size))
ValueError: size must be < 8
>>>
```

Есть несколько приёмов для упрощения спецификации ограничений в классах. Один из них — это использование декоратора класса:
```python
# Class decorator to apply constraints
def check_attributes(**kwargs):
	def decorate(cls):
		for key, value in kwargs.items():
			if isinstance(value, Descriptor):
				value.name = key
				setattr(cls, key, value)
			else:
				setattr(cls, key, value(key))
		return cls
	return decorate

# Example
@check_attributes(name=SizedString(size=8),
				  shares=UnsignedInteger,
				  price=UnsignedFloat)
class Stock:
	def __init__(self, name, shares, price):
		self.name = name
		self.shares = shares
		self.price = price
```

Ещё один подход к упрощению спецификации ограничений — использование метакласса:
```python
# A metaclass that applies checking
class checkedmeta(type):
	def __new__(cls, clsname, bases, methods):
		# Attach attribute names to the descriptors
		for key, value in methods.items():
			if isinstance(value, Descriptor):
				value.name = key
		return type.__new__(cls, clsname, bases, methods)

# Example
class Stock(metaclass=checkedmeta):
	name = SizedString(size=8)
	shares = UnsignedInteger()
	price = UnsignedFloat()
	def __init__(self, name, shares, price):
		self.name = name
		self.shares = shares
		self.price = price
```

### Обсуждение
Этот рецепт использует несколько продвинутых приёмов, включая дескрипторы, классы-миксины (примеси), функцию *super()*, декораторы классов и метаклассы. Здесь мы не можем раскрыть эти темы, но примеры вы можете найти в других рецептах (см. **рецепты 8.9., 8.18., 9.12. и 9.19.**). Однако несколько тонких моментов всё же стоит осветить.

Во-первых, в базовом классе *Descriptor* есть метод *__set__()*, но нет соответствующего *__get__()*. Если дескриптор не делает ничего, кроме как извлекает значение с таким же именем из словаря экземпляра, определять *__get__()* не нужно — на самом деле это сделает программу медленнее. Поэтому этот рецепт сосредоточен только на реализации *__set__()*.

Различные классы-дескрипторы в общем проектируются на базе классов-миксин (примесей). Например, классы *Unsigned* и *MaxSized* предназначены для смешивания с другими классами-дескрипторами, полученными от *Typed*. Чтобы обрабатывать конкретные типы данных, для получения нужной функциональности используется множественное наследование. 

Вы также заметите, что все методы *__init__()* различных дескрипторов запрограммированы так, чтобы иметь одинаковую сигнатуру вызовов, использующую именованные аргументы \*\*opts. Класс *MaxSized* ищет требуемые атрибуты в *opts*, но просто передает их базовому классу *Descriptor*, который их устанавливает. Сложность в композиции таких классов (и миксин в особенности) состоит в том, что вы не всегда знаете, как классы будут связаны друг с другом, или что будет вызывать функция *super()*. Поэтому вам нужно заставить всё это работать для любой возможной комбинации классов.

Определения различных типов классов, таких как *Integer*, *Float* и *String*, иллюстрируют полезный приём использования переменных класса для кастомизации реализации. Дескриптор *Typed* просто ищет атрибут *expected_type*, который предоставляется каждым из этих подклассов.

Использование декоратора класса или метакласса часто является полезным для упрощения спецификации пользователем. Вы заметите, что в этих примерах пользователь больше не должен прописывать имя атрибута больше, нежели один раз:
```python
# Normal
class Point:
	x = Integer('x')
	y = Integer('y')

# Metaclass
class Point(metaclass=checkedmeta):
	x = Integer()
	y = Integer()
```

Код декоратора класса и метакласса просто сканирует словарь класса в поиске дескрипторов. Когда дескриптор найден, они просто заполняют имя дескриптора, основываясь на значении ключа.

Из всех этих подходов решение с декоратором класса может предоставить наилучшую гибкость и ясность. Во-первых оно не рассчитывает ни на какую продвинутую магию типа метаклассов. Во-вторых, декоратор может быть легко добавлен или удалён из определения класса. Например, внутри декоратора может быть возможность просто пропустить все добавленные проверки. Это может позволить проверкам стать чем-то, что можно выключить или выключить в зависимости от текущих потребностей (например, во время дебаггинга выключить, а в продакшне включить).

И последнее: подход с использованием декоратора класса может быть также применён в качестве замены классам-миксинам (примесям), множественному наследованию и сложному использованию функции *super()*. Вот альтернативная реализация этого рецепта, использующая декораторы классов:
```python
# Base class. Uses a descriptor to set a value
class Descriptor:
	def __init__(self, name=None, **opts):
		self.name = name
		for key, value in opts.items():
			setattr(self, key, value)

	def __set__(self, instance, value):
		instance.__dict__[self.name] = value

# Decorator for applying type checking
def Typed(expected_type, cls=None):
	if cls is None:
		return lambda cls: Typed(expected_type, cls)
	
	super_set = cls.__set__
	def __set__(self, instance, value):
		if not isinstance(value, expected_type):
			raise TypeError('expected ' + str(expected_type))
		super_set(self, instance, value)
	cls.__set__ = __set__
	return cls

# Decorator for unsigned values
def Unsigned(cls):
	super_set = cls.__set__

	def __set__(self, instance, value):
		if value < 0:
			raise ValueError('Expected >= 0')
		super_set(self, instance, value)
	cls.__set__ = __set__
	return cls

# Decorator for allowing sized values
def MaxSized(cls):
	super_init = cls.__init__
	def __init__(self, name=None, **opts):
		if 'size' not in opts:
			raise TypeError('missing size option')
		super_init(self, name, **opts)
	cls.__init__ = __init__

	super_set = cls.__set__
	def __set__(self, instance, value):
		if len(value) >= self.size:
			raise ValueError('size must be < ' + str(self.size))
		super_set(self, instance, value)
	cls.__set__ = __set__
	return cls

# Specialized descriptors
@Typed(int)
class Integer(Descriptor):
	pass

@Unsigned
class UnsignedInteger(Integer):
	pass

@Typed(float)
class Float(Descriptor):
	pass

@Unsigned
class UnsignedFloat(Float):
	pass

@Typed(str)
class String(Descriptor):
	pass

@MaxSized
class SizedString(String):
	pass
```

Классы, определённые в этом альтернативном решении, работают так же, как и раньше (ранее показанный в примерах код не изменился), за исключением того, что всё работает намного быстрее. Например, простая проверка времени исполнения установки типизированного атрибута обнаруживает, что подход с использованием декораторов классов работает почти на 100% быстрее, чем использование миксин (примесей). Теперь-то вы рады, что дочитали весь этот рецепт до конца?

## 8.14. Реализация собственных контейнеров
### Задача
Вы хотите реализовать собственный кастомный класс, который копирует поведение обычного встроенного типа контейнера, такого как список или словарь. Однако вы не полностью уверены, что знаете, какие методы нужно реализовать.

### Решение
Библиотека *collections* определяет разнообразные абстрактные базовые классы, которые чрезвычайно полезны при реализации собственных классов контейнеров. Для примера предположим, что вы хотите создать класс с поддержкой итераций. Чтобы сделать это, унаследуйте его от *collections.Iterable*, как показано тут:
```python
import collections

class A(collections.Iterable):
	pass
```

Наследование от *collections.Iterable* проверяет, что вы реализовали все требуемые специальные методы. Если вы не сделаете этого, то получите ошибку при создании экземпляра:
```python
>>> a = A()
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class A with abstract methods __iter__
>>>
```

Чтобы исправить эту ошибку, просто дайте классу требуемый метод *__iter__()* и реализуйте его так, как хотите (см. **рецепты 4.2. и 4.7.**)

Другие важные классы, определённые в *collections*, это *Sequence*, *MutableSequence*, *Mapping*, *MutableMapping*, *Set* и *MutableSet*. Многие из этих классов формируют иерархии с увеличивающими уровнями функциональности (одна из таких иерархий — *Container*, *Iterable*, *Sized*, *Sequence* и *MutableSequence*). Ещё раз: просто создайте экземпляр любого из этих классов, чтобы увидеть, какие методы нужны, чтобы реализовать собственный контейнер с требуемым поведением:
```python
>>> import collections
>>> collections.Sequence()
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class Sequence with abstract methods \
__getitem__, __len__
>>>
```

Вот простой пример класса, который реализует предшествующие методы, чтобы создать последовательность, в которой элементы хранятся в отсортированном порядке (это не самая эффективная реализация, но она иллюстрирует общую идею):
```python
import collections
import bisect

class SortedItems(collections.Sequence):
	def __init__(self, initial=None):
		self._items = sorted(initial) if initial is None else []
	
	# Required sequence methods
	def __getitem__(self, index):
		return self._items[index]
	
	def __len__(self):
		return len(self._items)
	
	# Method for adding an item in the right location
	def add(self, item):
		bisect.insort(self._items, item)
```

Вот пример использования этого класса:
```python
>>> items = SortedItems([5, 1, 3])
>>> list(items)
[1, 3, 5]
>>> items[0]
1
>>> items[-1]
5
>>> items.add(2)
>>> list(items)
[1, 2, 3, 5]
>>> items.add(-10)
>>> list(items)
[-10, 1, 2, 3, 5]
>>> items[1:4]
[1, 2, 3]
>>> 3 in items
True
>>> len(items)
5
>>> for n in items:
...
print(n)
...
-10
1
2
3
5
>>>
```

Как вы можете видеть, экземпляры *SortedItems* ведут себя в точности как обычная последовательность и поддерживают все обычные операции, включая индексирование, итерирование, *len()*, проверку на содержание (оператор *in*) и даже извлечение срезов.

А вот модуль *bisect*, использованный в этом рецепте, даёт удобный способ поддерживать отсортированность элементов в списке. Поскольку *bisect.insort()* вставляет элемент в список, последовательность остается отсортированной.

### Обсуждение
Наследование от одного из абстрактных базовых классов из *collections* позволяет удостовериться, что ваш собственный контейнер реализует все требуемые методы, которые нужны контейнеру. Также наследование упрощает проверку типов.

Например, ваш собственный контейнер будет удовлетворять различным проверкам типов:
```python
>>> items = SortedItems()
>>> import collections
>>> isinstance(items, collections.Iterable)
True
>>> isinstance(items, collections.Sequence)
True
>>> isinstance(items, collections.Container)
True
>>> isinstance(items, collections.Sized)
True
>>> isinstance(items, collections.Mapping)
False
>>>
```

Многие абстрактные базовые классы из *collections* также предоставляют дефолтные реализации обычных методов контейнеров. Предположим, например, что у вас есть класс, который наследует от *collections.MutableSequence*:
```python
class Items(collections.MutableSequence):
	def __init__(self, initial=None):
		self._items = list(initial) if initial is None else []
	
	# Required sequence methods
	def __getitem__(self, index):
		print('Getting:', index)
		return self._items[index]

	def __setitem__(self, index, value):
		print('Setting:', index, value)
		self._items[index] = value

	def __delitem__(self, index):
		print('Deleting:', index)
		del self._items[index]

	def insert(self, index, value):
		print('Inserting:', index, value)
		self._items.insert(index, value)

	def __len__(self):
		print('Len')
		return len(self._items)
``` 

Если вы создадите экземпляр *Items*, то вы обнаружите, что он поддерживает практически все основные методы (например, *append()*, *remove()*, *count()* и т.д.) Эти методы реализованы таким образом, что они используют только требуемые. Вот интерактивный сеанс, которая демонстрирует это:
```python
>>> a = Items([1, 2, 3])
>>> len(a)
Len
3
>>> a.append(4)
Len
Inserting: 3 4
>>> a.append(2)
Len
Inserting: 4 2
>>> a.count(2)
Getting: 0
Getting: 1
Getting: 2
Getting: 3
Getting: 4
Getting: 5
2
>>> a.remove(3)
Getting: 0
Getting: 1
Getting: 2
Deleting: 2
>>>
```

Этот рецепт — лишь небольшой экскурс в функциональность абстрактных базовых классов Python. Модуль *numbers* предоставляет похожую коллекцию абстрактных классов, связанных с числовыми типами данных. См. **рецепт 8.12.**, чтобы получить больше сведений о создании собственных абстрактных базовых классов. 


## 8.15. Делегирование доступа к атрибуту
### Задача
Вы хотите, чтобы экземпляр делегировал доступ к атрибуту содержащемуся внутри экземпляру — возможно, в качестве альтернативы наследованию или чтобы реализовать прокси.

### Решение
Если не усложнять, делегирование — это паттерн программирования, который подразумевает передачу ответственности за реализацию конкретной операции другому объекту. В простейшей форме это часто выглядит как-то так:
```python
class A:
	def spam(self, x):
		pass

	def foo(self):
		pass

class B:
	def __init__(self):
		self._a = A()
	
	def spam(self, x):
		# Delegate to the internal self._a instance
		return self._a.spam(x)
	
	def foo(self):
		# Delegate to the internal self._a instance
		return self._a.foo()
	
	def bar(self):
		pass
```

Если нужно делегировать только пару методов, написать код типа вышеприведённого будет несложно. Однако если нужно делегировать много методов, существует альтернативный подход с определением метода *__getattr__()*:
```python
class A:
	def spam(self, x):
		pass
	
	def foo(self):
		pass

class B:
	def __init__(self):
		self._a = A()

	def bar(self):
		pass

# Expose all of the methods defined on class A
def __getattr__(self, name):
	return getattr(self._a, name)
```

Метод *__getattr__()* — это «общая ловушка» для обращений к атрибутам. Это метод, который вызывается, когда программа пытается обратиться к несуществующему атрибуту. В приведённом выше коде она перехватит операции доступа к неопределённым методам в классе *B* и просто делегирует их *A*. Например:
```python
b = B()
b.bar() 	# Calls B.bar() (exists on B)
b.spam(42)  # Calls B.__getattr__('spam') and delegates to A.spam
```

Еще один пример делегирования — это реализация прокси. Например:
```python
# A proxy class that wraps around another object, but
# exposes its public attributes

class Proxy:
	def __init__(self, obj):
	self._obj = obj

	# Delegate attribute lookup to internal obj
	def __getattr__(self, name):
		print('getattr:', name)
		return getattr(self._obj, name)

	# Delegate attribute assignment
	def __setattr__(self, name, value):
		if name.startswith('_'):
			super().__setattr__(name, value)
		else:
			print('setattr:', name, value)
			setattr(self._obj, name, value)

	# Delegate attribute deletion
	def __delattr__(self, name):
		if name.startswith('_'):
			super().__delattr__(name)
		else:
			print('delattr:', name)
			delattr(self._obj, name)
```

Чтобы использовать этот прокси-класс, просто оберните им другой экземпляр. Например:
```python
class Spam:
	def __init__(self, x):
		self.x = x
	def bar(self, y):
		print('Spam.bar:', self.x, y)

# Create an instance
s = Spam(2)

# Create a proxy around it
p = Proxy(s)

# Access the proxy
print(p.x)			# Outputs 2
p.bar(3)			# Outputs "Spam.bar: 2 3"
p.x = 37			# Changes s.x to 37
```

Путём кастомизации реализации методов доступа к атрибутам вы можете настроить поведение прокси (заставить его логировать доступ, разрешить доступ только на чтение и т.д.)

### Обсуждение
Делегирование иногда используется в качестве альтернативы наследованию. Например, вместо написания такого кода:
```python
class A:
	def spam(self, x):
		print('A.spam', x)
	
	def foo(self):
		print('A.foo')

class B(A):
	def spam(self, x):
		print('B.spam')
		super().spam(x)
	
	def bar(self):
		print('B.bar')
``` 

Вы можете написать решение с использованием делегирования:
```python
class A:
	def spam(self, x):
		print('A.spam', x)
	
	def foo(self):
		print('A.foo')

class B:
	def __init__(self):
		self._a = A()

	def spam(self, x):
		print('B.spam', x)
		self._a.spam(x)

	def bar(self):
		print('B.bar')
	
	def __getattr__(self, name):
		return getattr(self._a, name)
```

Такое использование делегирования часто полезно в ситуациях, когда прямое наследование может не иметь смысла, или когда вы хотите лучше контролировать отношения между объектами (например, показывать наружу некоторые методы, реализовывать интерфейсы и т.п.)

При использовании делегирования для реализации прокси, нужно держать в голове несколько важных деталей. Во-первых, метод *__getattr__()* это на самом деле «запасной» метод, который вызывается только если атрибут не найден. Поэтому когда запрашивается доступ к атрибутам самого экземпляра прокси (например, атрибут *_obj*), этот метод вызываться не будет. Во-вторых, методы *__setattr__()* и *__getattr__()* требуют добавления дополнительной логики, чтобы отделить атрибуты самого экземпляра прокси от атрибутов внутреннего объекта *_obj*. Общепринятое условие состоит в том, что прокси делегируются только атрибутам, которые не начинаются нижнего подчеркивания (то есть прокси показывают только «публичные» атрибуты содержащегося внутри объекта).

Важно подчеркнуть, что метод *__getattr__()* обычно не применяется к специальным методам, которые начинаются и заканчиваются двойным нижним подчеркиванием. Например, рассмотрите такой класс:
```python
class ListLike:
	def __init__(self):
		self._items = []
	def __getattr__(self, name):
		return getattr(self._items, name)
```     

Если вы попытаетесь создать объект *ListLike*, то обнаружите, что он поддерживает обычные методы списков, такие как *append()* и *insert()*. Однако он не поддерживает операторы типа *len()*, поиска элемента и т.д. Например:
```python
>>> a = ListLike()
>>> a.append(2)
>>> a.insert(0, 1)
>>> a.sort()
>>> len(a)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: object of type 'ListLike' has no len()
>>> a[0]
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: 'ListLike' object does not support indexing
>>>
```

Чтобы реализовать поддержку различных операторов, вы должны вручную делегировать специальные ассоциированные методы. Например:
```python
class ListLike:
	def __init__(self):
		self._items = []
	def __getattr__(self, name):
		return getattr(self._items, name)
	
	# Added special methods to support certain list operations
	def __len__(self):
		return len(self._items)
	def __getitem__(self, index):
		return self._items[index]
	def __setitem__(self, index, value):
		self._items[index] = value
	def __delitem__(self, index):
		del self._items[index]
```

См. **рецепт 11.8.**, в котором приведён другой пример использования делегирования в контексте создания прокси-классов для удалённого вызова процедуры.

## 8.16. Определение более одного конструктора в классе
### Задача
Вы пишите класс и хотите, чтобы пользователи могли создавать экземпляры не только лишь единственным способом, предоставленным *__init__()*.

### Решение
Чтобы определить класс с более чем одним конструктором, вы должны использовать метод класса. Вот простой пример:
```python
import time

class Date:
	# Primary constructor
	def __init__(self, year, month, day):
		self.year = year
		self.month = month
		self.day = day

	# Alternate constructor
	@classmethod
	def today(cls):
		t = time.localtime()
		return cls(t.tm_year, t.tm_mon, t.tm_mday)
``` 

Чтобы использовать альтернативный конструктор, просто вызовите его как функцию, такую как *Date.today()*. Вот пример:
```python
a = Date(2012, 12, 21) 	# Primary
b = Date.today()		# Alternate
```

### Обсуждение
Одно из главных применений методов класса — это определение альтернативных конструкторов, как было показано в этом рецепте. Важнейшая возможность метода класса в том, что он получает класс в первом аргументе (*cls*). Вы заметите, что этот класс используется в методе для создания и возвращения конечного экземпляра. Это тонкий момент, но этот аспект методов класса позволяет им корректно работать с такими возможностями как наследование. Например:
```python
class NewDate(Date):
	pass

c = Date.today() 		# Creates an instance of Date (cls=Date)
d = NewDate.today() 	# Creates an instance of NewDate (cls=NewDate)
```

При определении класса с множественными конструкторами, вы должны делать функцию *__init__()* максимально простой — она должна просто присваивать атрибутам значения. А вот уже альтернативные конструкторы будут вызываться при необходимости выполнения продвинутых операций.

Вместо определения отдельного метода класса, вы можете склоняться к реализации метода *__init__()* таким образом, который позволяет обрабатывать различные условия вызова. Например:
```python
class Date:
	def __init__(self, *args):
		if len(args) == 0:
			t = time.localtime()
			args = (t.tm_year, t.tm_mon, t.tm_mday)
		self.year, self.month, self.day = args
```

Хотя этот приём в некоторых случаях работает, он часто ведёт к сложному коду, который сложно понять и поддерживать. Например, эта реализация не показывает полезные строки помощи (с именами аргументов). Также код, который создает экземпляры *Date* будет менее ясным. Сравните:
```python
a = Date(2012, 12, 21) 	# Clear. A specific date.
b = Date() 				# ??? What does this do?

# Class method version
c = Date.today() 		# Clear. Today's date.
```

Как показано, *Date.today()* вызывает обычный метод *Date.__init__()* и создаёт экземляр класса *Date()* с подходящими аргументами года, месяца и дня. При необходимости экземпляр может быть создан без вызова метода *__init__()*. Это описывается в следующем рецепте.

## 8.17. Создание экземпляра без вызова *init*
### Задача
Вам нужно создать экземпляр, но вы по какой-то причине хотите обойти выполнение метода *__init__()*.

### Решение
«Голый» экземпляр может быть создан с помощью прямого вызова метода класса *__new__()*. Например, рассмотрите такой класс:
```python
class Date:
	def __init__(self, year, month, day):
		self.year = year
		self.month = month
		self.day = day
``` 

Вот как вы можете создать экземпляр *Date* без вызова *__init__()*:
```python
>>> d = Date.__new__(Date)
>>> d
<__main__.Date object at 0x1006716d0>
>>> d.year
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: 'Date' object has no attribute 'year'
>>>
```

Как вы можете видеть, получившийся экземпляр неинициализирован. Поэтому теперь установка нужных переменных экземпляра лежит на вашей ответственности. Например:
```python
>>> data = {'year':2012, 'month':8, 'day':29}
>>> for key, value in data.items():
...		setattr(d, key, value)
...
>>> d.year
2012
>>> d.month
8
>>>
```

### Обсуждение
Задача обхода метода *__init__()* иногда возникает, когда экземпляры создаются нестандартным путём, таким как десериализация данных или реализация метода класса, определённого в качестве альтернативного конструктора. Например, в показанном классе *Date* некто может определить альтернативный конструктор *today()* как показано тут: 
```python
from time import localtime

class Date:
	def __init__(self, year, month, day):
		self.year = year
		self.month = month
		self.day = day

	@classmethod
	def today(cls):
		d = cls.__new__(cls)
		t = localtime()
		d.year = t.tm_year
		d.month = t.tm_mon
		d.day = t.tm_mday
		return d
```

При десериализации данных из JSON вы можете получить похожий словарь:
```python
data = { 'year': 2012, 'month': 8, 'day': 29 }
``` 

Если вы хотите превратить его в экземпляр *Date*, просто используйте показанный в решении приём. 

При создании экземпляров нестандартным путём, обычно лучше не делать слишком много предположений по поводу их реализации. В общем случае лучше не писать код, который напрямую манипулирует внутренний словарь *__dict__*, если вы не знаете точно, что он гарантировано будет определён. В противном случае код поломается, если класс использует *__slots__*, свойства, дескрипторы или другие продвинутые приёмы. Если же вы будете использовать для установки значений *setattr()*, то ваш код будет настолько универсальным, насколько это возможно.

## 8.18. Расширение классов с помощью миксин (примесей)
### Задача
У вас есть набор полезных методов, которые вы хотели бы сделать доступными в других класса, чтобы расширить их функциональность. Однако классы, в которые добавляются методы, не всегда связаны друг с другом через наследование. Поэтому вы не можете просто прикрепить методы к общему базовому классу (суперклассу).

### Решение
Проблема, решаемая в этом рецепте, часто возникает в программах, где необходима кастомизация классов. Например, библиотека может предоставлять базовый набор классов вместе с набором необязательных кастомизаций, которые могут быть применены пользователями при желании.

Чтобы проиллюстрировать это, предположим, что вы заинтересованы в добавлении различных кастомизаций к объектам (например, логирования, запрета повторного присваивания, проверки типов и т.п.). Вот набор классов-миксин (примесей), которые это делают:
```python
class LoggedMappingMixin:
	'''
	Add logging to get/set/delete operations for debugging.
	'''
	__slots__ = ()

	def __getitem__(self, key):
		print('Getting ' + str(key))
		return super().__getitem__(key)
	
	def __setitem__(self, key, value):
		print('Setting {} = {!r}'.format(key, value))
		return super().__setitem__(key, value)
		
	def __delitem__(self, key):
		print('Deleting ' + str(key))
		return super().__delitem__(key)

class SetOnceMappingMixin:
	'''
	Only allow a key to be set once.
	'''
	__slots__ = ()
	def __setitem__(self, key, value):
		if key in self:
			raise KeyError(str(key) + ' already set')
		return super().__setitem__(key, value)

class StringKeysMappingMixin:
	'''
	Restrict keys to strings only
	'''
	__slots__ = ()
	def __setitem__(self, key, value):
		if not isinstance(key, str):
			raise TypeError('keys must be strings')
		return super().__setitem__(key, value)
```   

Сами по себе эти классы бесполезны. Если вы попытаетесь создать их экземпляры, ничего полезного не получится, разве что вы полюбуетесь на исключения. На самом деле они должны быть смешаны с другими классами через множественное наследование. Например:
```python
>>> class LoggedDict(LoggedMappingMixin, dict):
...		pass
...
>>> d = LoggedDict()
>>> d['x'] = 23
Setting x = 23
>>> d['x']
Getting x
23
>>> del d['x']
Deleting x

>>> from collections import defaultdict
>>> class SetOnceDefaultDict(SetOnceMappingMixin, defaultdict):
...		pass
...
>>> d = SetOnceDefaultDict(list)
>>> d['x'].append(2)
>>> d['y'].append(3)
>>> d['x'].append(10)
>>> d['x'] = 23
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "mixin.py", line 24, in __setitem__
		raise KeyError(str(key) + ' already set')
KeyError: 'x already set'

>>> from collections import OrderedDict
>>> class StringOrderedDict(StringKeysMappingMixin,
...							SetOnceMappingMixin,
...							OrderedDict):
...		pass
...
>>> d = StringOrderedDict()
>>> d['x'] = 23
>>> d[42] = 10
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "mixin.py", line 45, in __setitem__
		'''
TypeError: keys must be strings
>>> d['x'] = 42
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "mixin.py", line 46, in __setitem__
		__slots__ = ()
File "mixin.py", line 24, in __setitem__
	if key in self:
KeyError: 'x already set'
>>>
```

В этом примере вы заметите, что миксины объединены с другими существующими классами (*dict*, *defaultdict*, *OrderedDict*) и даже друг с другом. При объединении классы работают вместе, предоставляя желаемую функциональность.

### Обсуждение
Классы-миксины (примеси) испольуются в различных местах стандартной библиотеки, в основном для расширения функциональности других классов. Также они являются одной из основных причин использования множественного наследования. Например, если вы пишете сетевой код, вы часто можете использовать *ThreadingMixIn* из модуля *socketserver*, чтобы добавить поддержку потоков в другие связанные с сетью классы. Например, вот многопоточный XML-RPC-сервер:
```python
from xmlrpc.server import SimpleXMLRPCServer
from socketserver import ThreadingMixIn
class ThreadedXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer):
	pass
```  

Также часто можно встретить миксины в крупных библиотеках и фреймворках — опять же, в основном для расширения функциональности существующих классов дополнительными возможностями.

У теории классов-миксин богатая история. Однако вместо погружения во все детали стоит держать в голове несколько важных моментов реализации.

Во-первых, классы-миксины (примеси) никогда не предназначались для прямого создания экземпляров. Например, ни один из приведённых в этом рецепте классов сам по себе не работает. Они должны быть подмешаны к другому классу, который реализует требуемую функциональность. Похожим образом *ThreadingMixIn* из модуля *socketserver* должен быть подмешан к подходящему классу-серверу — он не может быть использован само по себе.

Во-вторых, классы-миксины обычно не имеют собственного состояния. Это значит, что у них нет метода *__init__()* и переменных экземпляра. В этом рецепте определение *__slots__ = ()* предназначено для строгого указания на тот факт, что классы-миксины не имеют собственных данных экземпляра. 

Если вы подумываете определить класс-миксин, у которого будет метод *__init__()* и переменные экземпляра, то обратите внимание, что существует серьезная опасность, связанная с тем фактом, что класс ничего не знает о других классах, с которыми он будет смешиваться. Поэтому все переменные экземпляра должны иметь такие имена, которые позволят избежать конфликтов имён. Также метод *__init__()* должен быть запрограммирован правильно вызывать метод *__init__()* других классов, к которым подмешивается миксин. В общем случае это трудно реализовать, поскольку вы ничего не знаете о сигнатурах аргументов других классов. По крайней мере, вы должны реализовать нечто очень общее, используя \*arg и \*\*kwargs. Если *__init__()* класса-миксина принимает какие-либо аргументы, эти аргументы должны быть определены только как именованные, иметь такие имена, чтобы избежать конфликтов с другими аргументами. Вот возможная реализация миксина, определяющего *__init__()* и принимающего именованный аргумент:
```python
class RestrictKeysMixin:
	def __init__(self, *args, _restrict_key_type, **kwargs):
		self.__restrict_key_type = _restrict_key_type
		super().__init__(*args, **kwargs)

	def __setitem__(self, key, value):
		if not isinstance(key, self.__restrict_key_type):
			raise TypeError('Keys must be ' + str(self.__restrict_key_type))
		super().__setitem__(key, value)
```

Вот пример использования этого класса:
```python
>>> class RDict(RestrictKeysMixin, dict):
...		pass
...
>>> d = RDict(_restrict_key_type=str)
>>> e = RDict([('name','Dave'), ('n',37)], _restrict_key_type=str)
>>> f = RDict(name='Dave', n=37, _restrict_key_type=str)
>>> f
{'n': 37, 'name': 'Dave'}
>>> f[42] = 10
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "mixin.py", line 83, in __setitem__
		raise TypeError('Keys must be ' + str(self.__restrict_key_type))
TypeError: Keys must be <class 'str'>
>>>
```

В этом примере вы можете заметить, что инициализация *RDict()* все ещё принимает аргументы, которые понимает функция *dict()*. Однако есть и дополнительный именованный аргумент *restrict_key_type*, который предоставляетя классу-миксину.

И последнее: использование функции *super()* — необходимая и критически важная часть написания классов-миксин. В вышеприведённом решении классы переопределяют некоторые критически важные методы, такие как __getitem__() и *__setitem__()*. Однако им также нужно вызвать изначальные реализации этих методов. Использование *super()* делегируется следующему классу в порядке разрешения методов (ПРМ, MRO — method resolution order). Этот аспект рецепта, однако, неочевиден для новичков, потому что *super()* используется в классах, у которых нет родителей (на первый взгляд это может выглядеть как ошибка). Однако в подобном определении класса:
```python
class LoggedDict(LoggedMappingMixin, dict):
	pass
```
...использование *super()* в *LoggedMappingMixin* делегируется следующему классу в списке множественного наследования. Так, вызов типа *super().__getitem__()* в *LoggedMappingMixin* на самом деле делает дополнительный шаг и вызывает *dict.__getitem__()*. Без такого поведения класс-миксин не работал бы.

Альтернативная реализация миксин подразумевает использование декораторов классов. Например, рассмотрите такой код:
```python
def LoggedMapping(cls):
	cls_getitem = cls.__getitem__
	cls_setitem = cls.__setitem__
	cls_delitem = cls.__delitem__

	def __getitem__(self, key):
		print('Getting ' + str(key))
		return cls_getitem(self, key)

	def __setitem__(self, key, value):
		print('Setting {} = {!r}'.format(key, value))
		return cls_setitem(self, key, value)

	def __delitem__(self, key):
		print('Deleting ' + str(key))
		return cls_delitem(self, key)

	cls.__getitem__ = __getitem__
	cls.__setitem__ = __setitem__
	cls.__delitem__ = __delitem__
	return cls
``` 

Эта функция применяется к определению класса как декоратор. Например:
```python
@LoggedMapping
class LoggedDict(dict):
	pass
```

Если вы попробуете это в работе, то получите такое же поведение, как и ранее, но без использования множественного наследования. Вместо него декоратор просто выполняет небольшую хирургическую операцию на определении класса для замены некоторых методов. Дополнительную информацию о декораторах вы можете почерпнуть в **рецепте 9.12.**

См. также **рецепт 8.13.**, где приведен продвинутый способ, использующий миксины и декораторы классов одновременно. 
































