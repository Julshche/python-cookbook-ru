# 1. Структуры данных и алгоритмы #

Python предоставляет широкий спектр встроенных структур данных, таких как списки, множества и словари. Использовать эти структуры по большей части просто. Однако часто возникают общие вопросы, касающиеся поиска, сортировки, изменения порядка элементов и фильтрования. Цель этой главы — обсудить обычные стуктуры данных и алгоритмы. Также будет дано введение в разнообразные структуры данных из модуля *collections*.

## 1.1. Распаковка последовательности в отдельные переменные ##

### Проблема ###
У вас есть кортеж из N элементов или последовательность, которую вы хотите распаковать в коллекцию из N переменных.

### Решение
Любая последовательность (или итерируемый объект) могут быть распакованы в переменные с помощью простого присваивания. Единственное обязательное условие заключается в том, чтобы количество и структура переменных совпадали с последовательностью. Например:
``` python
>>> p = (4, 5)
>>> x, y = p
>>> x
4
>>> y
5
>>>
```

``` python
>>> data = ['ACME', 50, 91.1, (2012, 12, 21)]
>>> name, shares, price, date = data
>>> name
'ACME'
>>> date
(2012, 12, 21)
```

``` python
>>> name, shares, price, (year, mon, day) = data
>>> name
'ACME'
>>> year
2012
>>> mon
12
>>> day
21
>>>
```

При несовпадении количества элементов вы получите ошибку. Например:
``` python
>>> p = (4, 5)
>>> x, y, z = p
Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
ValueError: need more than 2 values to unpack
>>>
```

### Обсуждение ###
Распаковка работает с любым итерируемым объектом, а не только с кортежами и списками. Это строки, файлы, итераторы и генераторы. Например:
``` python
>>> s = 'Hello'
>>> a, b, c, d, e = s
>>> a
'H'
>>> b
'e'
>>> e
'o'
>>>
```

При распаковке вы иногда можете захотеть отбраковать некоторые значения. Специального синтаксиса для этого в Python нет, но вы можете назначить «выбрасываемые» переменные. Например:
``` python
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>
```

Но убедитесь, что вы уже не использовали где-то эту переменную.


## 1.2. Распаковка элементов из последовательностей произвольной длины ##

### Проблема ###
Вам нужно распаковать N элементов из итерируемого объекта, но этот объект может содержать больше N элементов, что вызывает исключение "too many values to unpack" («слишком много значений для распаковки»).

### Решение ###
Для решения этой задачи могут быть использованы «выражения со звёздочкой». Предположим, например, что вы ведете учебный курс и решаете в конце семестра, что вы не будете принимать во внимание оценки за первое и последнее домашние задания, а по остальным оценкам посчитаете среднее значение. Если у вас было четыре задания, то можно просто распаковать все четыре. Но что делать, если их 24? Выражения со звёздочкой позволяют легко решить проблему:
``` python
def drop_first_last(grades):
	first, *middle, last = grades
	return avg(middle)
```

Рассмотрим еще один пример: предположим, что у вас есть записи о юзерах, которые состоят из имени и email, за которыми следует произвольное количество телефонных номеров. Вы можете распаковать записи так:
``` python
>>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
>>> name, email, *phone_numbers = user_record
>>> name
'Dave'
>>> email
'dave@example.com'
>>> phone_numbers
['773-555-1212', '847-555-1212']
>>>
```

Стоит отметить, что переменная phone_numbers всегда будет списком, несмотря на то, сколько телефонных номеров распаковано (даже если и ни одного). Любой код, который использует phone_numbers не должен учитывать возможность, что в этой будет не список, или производить дополнительные проверки.

Переменная со звёздочкой также может быть первой в списке. Например, у вас есть последовательность значений, представляющая продажи вашей компании за последние восемь кварталов. Если вы хотите посмотреть, как последний квартал соотносится со средним значением по первым семи, вы можете сделать так:
```python
*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
```

Интерпретатор Python выдаст:
```python
>>> *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
>>> trailing
[10, 8, 7, 1, 9, 5, 10]
>>> current
3
```

### Обсуждение ###
Расширенная распаковка отлично подходит для распаковки итерируемых объектов неизвестной или произвольной длины. Часто эти объекты имеют некоторые известные элементы или паттерны (например, «всё, что после элемента 1, является телефонным номером»), и распаковка со звёздочкой позволяет программисту легко использовать эти паттерны — вместо того, чтобы исполнять акробатические трюки для извлечения нужных элементов из итерируемого объекта.

Стоит отметить, что синтаксис звёздочки может быть особенно полезен при итерировании по последовательности кортежей переменной длины. Например, возможна такая последовательность кортежей с тегами:
```python
records = [
	('foo', 1, 2),
	('bar', 'hello'),
	('foo', 3, 4),
]

def do_foo(x, y):
	print('foo', x, y)

def do_bar(s):
	print('bar', s)

for tag, *args in records:
	if tag == 'foo':
		do_foo(*args)
	elif tag == 'bar':
		do_bar(*args)
```

Распаковка со звёздочкой также может быть полезна в комбинации с операциями обработки строк, такими как разрезание. Например:
```python
>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
>>> uname, *fields, homedir, sh = line.split(':')
>>> uname
'nobody'
>>> homedir
'/var/empty'
>>> sh
'/usr/bin/false'
>>>
```

Иногда вам может быть нужно распаковать значения и выбросить их. Вы не можете просто определить голую * при распаковке, но вы можете использовать обычное для выбрасывания имя переменной, такое как _ или ign (ignored). Например:
```python
>>> record = ('ACME', 50, 123.45, (12, 18, 2012))
>>> name, *_, (*_, year) = record
>>> name
'ACME'
>>> year
2012
>>>
```

Есть некоторая схожесть между распаковкой со звёздочкой и обработкой списков в функциональных языках. Например, если у вас есть список, то вы можете легко разделить его на «хвост» и «голову»:
```python
>>> items = [1, 10, 7, 4, 5, 9]
>>> head, *tail = items
>>> head
1
>>> tail
[10, 7, 4, 5, 9]
>>>
```

Можно представить себе функцию, которая произведет такое разрезание с помощью хитрого рекурсивного алгоритма. Например:
```python
>>> def sum(items):
...   head, *tail = items
...   return head + sum(tail) if tail else head
...
>>> sum(items)
36
>>>
```

Однако вам следует знать, что рекурсия не относится к числу сильных сторон Python из-за внутреннего лимита на рекурсию. Поэтому последний пример на практике оказывается просто любопытным предметом для размышления.


## 1.3. Оставление N последних элементов ##
### Задача ###
Вы хотите хранить ограниченную историю из нескольких последних элементов, полученных в ходе итерации или какого-то другого процесса обработки данных.

### Решение ###
Хранение ограниченной истории — отличный повод применить *collections.deque*. Например, следующий отрывок кода производит простое сопоставление текста с последовательностью строк и при совпадении выдает совпадающие строки вместе с N предыдущими строками контекста:
```python
from collections import deque
def search(lines, pattern, history=5):
	previous_lines = deque(maxlen=history)
	for line in lines:
		if pattern in line:
			yield line, previous_lines
		previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
	with open('somefile.txt') as f:
		for line, prevlines in search(f, 'python', 5):
			for pline in prevlines:
				print(pline, end='')
		print(line, end='')
		print('-'*20)
```

### Обсуждение ###
При написании программы для поиска элементов обычно используют функцию-генератор, содержащую *yield* (как и показано в вышеприведенном примере). Это отделяет процесс поиска от кода, который использует результаты. Если вы новичок в обращении с генераторами, см. **Рецепт 4.3.**

Использование *deque(maxlen=N)* создает очередь фиксированной длины. Когда новые элементы добавлены и очередь заполнена, самый старый элемент автоматически удаляется. Пример:
```python
>>> q = deque(maxlen=3)
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3], maxlen=3)
>>> q.append(4)
>>> q
deque([2, 3, 4], maxlen=3)
>>> q.append(5)
>>> q
deque([3, 4, 5], maxlen=3)
```

Хотя вы можете вручную производить такие операции над списком (то есть добавление в конец, удаление и т.п.), решение с использованием очереди элегантнее и работает намного быстрее.

Обобщим: дека может быть использована в любом случае, когда вам нужна простая очередь. Если вы не задатите максимальную длину, вы получите бесконечную очередь, которая позволит вам добавлять и удалять элементы с обоих концов. Например:
```python
>>> q = deque()
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3])
>>> q.appendleft(4)
>>> q
deque([4, 1, 2, 3])
>>> q.pop()
3
>>> q
deque([4, 1, 2])
>>> q.popleft()
4
```

Добавление или удаление элементов с любого из концов очереди имеет сложность O(1). А вот добавление или удаление элемента в начало списка имеет сложность O(N).


## 1.4. Поиск N максимальных и минимальных элементов 
### Задача ###
Вы хотите создать список N максимальных или минимальных элементов коллекции.

### Решение ###
У модуля *heapq* есть две функции, nlargest() и nsmallest(), которые делают именно то, что вам нужно. Например:
```python
import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
```

Обе функции таке принимают параметр key, который позволяет использовать их с более сложными структурами данных. Например:
```python
portfolio = [
	{'name': 'IBM', 'shares': 100, 'price': 91.1},
	{'name': 'AAPL', 'shares': 50, 'price': 543.22},
	{'name': 'FB', 'shares': 200, 'price': 21.09},
	{'name': 'HPQ', 'shares': 35, 'price': 31.75},
	{'name': 'YHOO', 'shares': 45, 'price': 16.35},
	{'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
```

### Обсуждение ###
Если вы ищете N наименьших или N наибольших элементов, причем N невелико по сравнению с общим размером коллекции, эти функции покажут великолепную производительность. «Под капотом» они начинают работу с конвертирования данных в список, где данные упорядочены как куча. Например:
```python
>>> nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
>>> import heapq
>>> heap = list(nums)
>>> heapq.heapify(heap)
>>> heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
>>>
``` 

Самое важная возможность кучи состоит в том, что heap[0] всегда будет наименьшим элементом. Кроме того, последующие элементы могут быть легко найдены с помощью метода heapq.heappop(), который удаляет первый элемент и заменяет его следующим наименьшим элементом (это требует O(log N) операций, где N — размер кучи). Например, чтобы найти три наименьших элемента, вы могли бы сделать это:
```python
>>> heapq.heappop(heap)
-4
>>> heapq.heappop(heap)
1
>>> heapq.heappop(heap)
2
```

Функции nlargest() и nsmallest() лучше всего подходят, если вы пытаетесь найти относительно небольшое количество элементов. Если вы просто хотите найти один наибольший или наименьший элемент (N = 1), функции min() и max() будут быстрее. Похожим образом, если N сопоставимо с размером самой коллекции, обычно будет быстрее отсортировать их и взять срез (то есть сделать sorted(items)[:N] или orted(items)[-N:]). Стоит отметить, что реальная имплементация nlargest() и nsmallest() работает гибко и выполняет некоторые из этих оптимизаций самостоятельно (например, использует сортировку, если размер N близок к размеру входящих данных).

Хотя использовать этот рецепт необязательно, имплементация кучи интересна и заслуживает изучения. Информацию об этом можно найти в любой приличной книге по алгоритмам и структурам данных. В документации модуля *heapq* также обсуждаются детали внутренней имплементации.

## 1.5. Имплементация очереди с приоритетом ##
### Задача ###
Вы хотите реализовать очередь, которая сортирует элементы по заданному приоритету и всегда возвращает элемент с наивысшим приоритетом при каждой операции получения (удаления) элемента.

### Решение
Приведенный ниже класс использует модуль *heapq* для реализации простой очереди с приоритетом.

```python
import heapq

class PriorityQueue:
	def __init__(self):
		self._queue = []
		self._index = 0
	
	def push(self, item, priority):
		heapq.heappush(self._queue, (-priority, self._index, item))
		self._index += 1

def pop(self):
		return heapq.heappop(self._queue)[-1]
```

А вот пример использования:
```python
>>> class Item:
...   def __init__(self, name):
...   self.name = name
...   def __repr__(self):
...   return 'Item({!r})'.format(self.name)
...
>>> q = PriorityQueue()
>>> q.push(Item('foo'), 1)
>>> q.push(Item('bar'), 5)
>>> q.push(Item('spam'), 4)
>>> q.push(Item('grok'), 1)
>>> q.pop()
Item('bar')
>>> q.pop()
Item('spam')
>>> q.pop()
Item('foo')
>>> q.pop()
Item('grok')
>>>
```    

Посмотрите, как первая операция pop() возвращает элемент с наивысшим приоритетом. Также пронаблюдайте, как два элемента с одинаковым приоритетом (foo и grok) были возвращены в том же порядке, в каком они были помещены в очередь.

### Обсуждение ###
Суть этого рецепта заключается в использовании модуля *heapq*. Функции heapq.heappush() и heapq.heappop() вставляют и удаляют элементы из list_queue таким образом, что первый элемент в списке имеет наименьший приоритет (как обсуждалось в **рецепте 1.4.**). Метод heappop() всегда возвращает «наименьший» элемент, что является ключом к тому, чтобы заставить очередь удалять правильные элементы. Кроме того, так как операции вталкивания и снятия имеют сложность O(log N), где N — число элементов в куче, то они являются вполне эффективными даже для весьма больших значений N.

В этом рецепте очередь состоит из кортежей формата *(-priority, index, item)*. Значение приоритета сделано отрицательным, чтобы заставить очередь сортировать элементы от наибольшего к наименьшему приоритету. Это противоположно обычному порядку сортировки кучи (от наименьшего к наибольшему значению).

Роль переменной *index* заключается в установлении правильного порядка элементов с одинаковым приоритетом. Поддержание постоянно увеличивающегося индекса позволяет сортировать элементы в соответствии с порядком, в каком они были вставлены. Однако индекс такде выполняет важную роль в выполнении операций сравнения при работе с элементами с одинаковыми значениями приоритета. 

Если остановиться на этом подробнее, то отметим, что экземпляры класса *Item* не могут быть упорядочены. Например:
```python
>>> a = Item('foo')
>>> b = Item('bar')
>>> a < b
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Если вы создаете кортежи *(priority, item)*, то их можно сравнивать до тех пор, пока приоритеты различны. Однако же если сравниваются два кортежа с равными приоритетами, то сравнение не может быть проведено (как и ранее). Например:
```python
>>> a = (1, Item('foo'))
>>> b = (5, Item('bar'))
>>> a < b
True
>>> c = (1, Item('grok'))
>>> a < c
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: unorderable types: Item() < Item()
>>>
```

Вводя дополнительный индекс и создавая кортежи *(priority, index, item)*, вы избегаете этой проблемы полностью, поскольку два кортежа никогда не будут иметь одинаковые значения переменной *index* (и Python никогда не будет сравнивать остальные значения в кортежах, если результат сравнения уже определен):
```python
>>> a = (1, 0, Item('foo'))
>>> b = (5, 1, Item('bar'))
>>> c = (1, 2, Item('grok'))
>>> a < b
True
>>> a < c
True
>>>
```

Если вы хотите использовать эту очередь для коммуникации между потоками (тредами), вы должны добавить правильную блокировку и передачу сигналов (cм. **рецепт 12.3.**).  

Документация модуля *heapq* содержит дополнительные примеры и обсуждения теории и имплементации куч.


## 1.6. Отображение ключей на множественные значения в словаре ##
### Задача ###
Вы хотите создать словарь, который отображает ключи на более чем одно значение (так называемый «мультисловарь», multidict).

### Решение
Словарь — это отображение, где каждый ключ отображен на единственное значение. Если вы хотите отобразить ключи на множественные значения, вам нужно хранить множественные значения в другом контейнере, таком как список или множество. Например, вы можете создавать такие словари:
```python
d = {
	'a' : [1, 2, 3],
	'b' : [4, 5]
}

e = {
	'a' : {1, 2, 3},
	'b' : {4, 5}
}
```

Выбор того, использовать или не использовать списки или множества, зависит от того, как будет использован мультисловарь. Применяйте список, если вы хотите сохранить порядок, в котором добавлены элементы. Применяйте множество, если вы хотите устранить дубликаты (и при этом не беспокоитесь о порядке элементов).

Чтобы легко создавать такие словари, вы можете использовать *defaultdict* из модуля *collections*. Фишка *defautdict* заключается в автоматической инициализации первого значения, так что вы можете сосредоточиться на добавлении элементов. Например:
```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
...

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
...
```

Одно предупреждение: *defaultdict* автоматически создаст записи словаря для ключей, к которым позже будет осуществлен доступ (даже если их в данный момент в словаре нет). Если такое поведение нежелательно, вы можете использовать *setdefault()* на обычном словаре. Например:
```python
d = {}  # A regular dictionary
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)
...
```

Однако многие программисты находят *setdefault()* несколько неестественным — и это если не учитывать тот факт, что он всегда создает новый экземпляр первоначального значения при каждом вызове (в примере это пустой список []).

### Обсуждение ###
Конструирование словарей с множественными значениями не является чем-то сложным. Однако инициализация первого значения может быть запутанной, если вы пытаетесь сделать это самостоятельно. Например, вы можете написать что-то такое:
```python
d = {}
for key, value in pairs:
	if key not in d:
		d[key] = []
	d[key].append(value)
``` 

Использование *defaultdict* приводит к намного более чистому коду:
```python
d = defaultdict(list)
for key, value in pairs:
	d[key].append(value)
```

Этот рецепт сильно связан с проблемой группировки записей в задачах обработки данных. Посмотрите, например, рецепт **1.15.**

## 1.7. Поддержание порядка в словарях 
### Задача
Вы хотите создать словарь, и вы также хотите контролировать порядок элементов при итерировании или сериализации.

### Решение
Чтобы контролировать порядок элементов в словаре, вы можете использовать *OrderedDict* из модуля *collections*. Он в точности сохраняет изначальный порядок добавления данных при итерировании. Например:
```python
 from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
	print(key, d[key])
```

*OrderedDict* особенно полезен, когда вы хотите создать отображение, которое вы в дальнейшем собираетесь сериализовать или закодировать в другой формат. Например, если вы хотите строго контролировать порядок полей, выводимых в JSON, вам нужно просто создать *OrderedDict* с нужными данными:
```python
>>> import json

>>> json.dumps(d)
'{"foo": 1, "bar": 2, "spam": 3, "grok": 4}'
>>>
```

### Обсуждение
*OrderedDict* внутри себя поддерживает двусвязный список, который упорядочивает ключи в соответствии с порядком добавления. Когда новый элемент вставляется впервые, он помещается в конец этого списка. Последующее связывание значения с существующим ключом не изменяет порядок.

Заметьте, что размер *OrderedDict* более чем в два раза превышает размер обычного словаря из-за содержащегося внутри дополнительного списка. А если вы собираетесь создать структуру данных, в которой будет большое число экземпляров *OrderedDict* (например, вы хотите прочитать 100 000 строк CSV-файла в список экземпляров *OrderedDict*), вам стоит изучить требования вашего приложения, чтобы решить, перевесят ли преимущества использования *OrderedDict* оверхед на дополнительную память. 

## 1.8. Вычисления в словарях
### Задача
Вы хотите проводить различные вычисления (например, поиск минимального и максимального значения, сортировку) в словаре с данными.

### Решение
Рассмотрим словарь, который отображает тикеры (названия) акций на цены:
```python
prices = {
	'ACME': 45.23,
	'AAPL': 612.78,
	'IBM': 205.55,
	'HPQ': 37.20,
	'FB': 10.75
}
```

Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно обратить ключи и значения, используя функцию zip(). Например, вот так можно найти минимальную и максимальную цену, а также соответствующий тикер:
```python
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')

max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
```

Похожим образом для ранжирования данных можно использовать zip() с sorted(), как показано ниже:
```python
prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
# 					(45.23, 'ACME'), (205.55, 'IBM'),
# 					(612.78, 'AAPL')]
``` 

Когда вы производите эти вычисления, обратите внимание, что zip() создает итератор, по которому можно пройти только один раз. Например, следующий фрагмент кода — неправильный:
```python
prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names))  # OK
print(max(prices_and_names))  # ValueError: max() arg is an empty sequence
```

### Обсуждение 
Если вы попытаетесь выполнить обычные обработки данных на словаре, то вы обнаружите, что они обрабатывают только ключи, но не значения. Например:
```python
min(prices)  # Returns 'AAPL'
max(prices)  # Returns 'IBM'
```

Вероятно, это не то, чего вы хотели добиться, поскольку вы пытались выполнить вычисления с использованием значений словаря. Вы можете попробовать исправить это, используя метод словаря values():
```python
min(prices.values())  # Returns 10.75
max(prices.values())  # Returns 612.78
``` 

К несчастью, это часто тоже не позволит вам добиться желаемого. Например, вы можете хотеть знать соответствующие ключи (т.е., у каких акций самая низкая цена?)

Вы можете получить ключ, соответствующий минимальному или максимальному значению, если вы передадите функцию в функции min() и max(). Например:
```python
min(prices, key=lambda k: prices[k])  # Returns 'FB'
max(prices, key=lambda k: prices[k])  # Returns 'AAPL'
```

Однако чтобы получить минимальное значение, вам потребуется дополнительное обращение. Например:
```python
min_value = prices[min(prices, key=lambda k: prices[k])]
```

Решение с использованием функции zip() решает задачу путем «обращения» словаря в последовательность пар (value, key). Когда выполняется сравнение таких кортежей, элемент value сравнивается первым, а key — следующим. Это дает вам то самое поведение, которое вы хотите, и которое позволяет проводить обработки и сортировку словаря с использованием единственного выражения.

Стоит отметить, что в вычислениях с использованием пар (value, key) key будет использован, чтобы определить результат в экземплярах, где множественные записи имеют одинаковые value. Например, в вычислениях min() и max() запись с наименьшим или наибольшим ключом будет возвращена, если найдутся дублированные (одинаковые) значения (value). Например:
```python
>>> prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
>>> min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
>>> max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
>>>
```  

## 1.9. Поиск общих элементов в двух словарях
### Задача
У вас два словаря, и вы хотите выяснить, что у них общего (одинаковые ключи, значения и т.п.)

### Решение
Рассмотрим два словаря:
```python
a = {
	'x' : 1,
	'y' : 2,
	'z' : 3
}

b = {
	'w' : 10,
	'x' : 11,
	'y' : 2
}
```

Чтобы найти общие элементы, просто выполните обычный набор операций с использовением методов keys() и items(). Например:
```python
# Find keys in common
a.keys() & b.keys()  # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys()  # { 'z' }
# Find (key,value) pairs in common
a.items() & b.items() # { ('y', 2) }
```

Операции такого типа также могут быть использованы для изменения или фильтрования содержимого словаря. Предположим, например, что вы хотите создать новый словарь, в котором некоторые ключи удалены. Взгляните на этот пример кода генератора словаря (dictionary comprehension):
```python
# Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
```

### Обсуждение
Словарь — это отображение множества ключей на множество значений. Метод словаря keys() возвращает объект просмотра ключей (keys-view object). Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над множествами (объединения, пересечения, разности и т.п.) Так что если вам нужно выполнить этот набор операций над ключами словаря, вы можете использовать объект просмотра напрямую, без предварительного конвертирования в множество.

Метод словаря items() возвращает объект просмотра элементов, состоящий из пар (key, value). Этот объект поддерживает похожий набор операций и может быть использован для выполнения таких операций, как поиск того, какие пары ключ-значение являются общими для двух словарей.

Хотя метод словаря values() похож на предыдущие, он не поддерживает операции над множествами, описанные выше в этом рецепте. Это происходит, в частности, по причине того, что, в отличие от ключей, элементы объекта просмотра значений могут быть и не уникальными. Один этот факт делает применение к ним операций над множествами малополезным. Если же, однако, вы вынуждены выполнить такие операции, этого можно добиться путем простой предварительного конвертирования значений в множество.

## 1.10. Удаление дубликатов из последовательности с сохранением порядка элементов
### Задача
Вы хотите исключить дублирующиеся значения из последовательности, но при этом сохранить порядок следования оставшихся элементов. 

### Решение 
Если значения в последовательности являются хэшируемыми, задача может быть легко решена с использованием множества и генератора. Например:
```python
def dedupe(items):
	seen = set()
	for item in items:
		if item not in seen:
			yield item
			seen.add(item)
```

Вот пример использования этой функции:
```python
>>> a = [1, 5, 2, 1, 9, 1, 5, 10]
>>> list(dedupe(a))
[1, 5, 2, 9, 10]
>>>
```

Это будет работать только в том случае, если элементы последовательности хэшируются. Если вы пытаетесь удалить дубликаты в последовательности из нехэшируемых типов (таких как словари), вы можете внести небольшое изменение в этот рецепт. Например, такое:
```python
def dedupe(items, key=None):
	seen = set()
	for item in items:
		val = item if key is None else key(item)
		if val not in seen:
			yield item
			seen.add(val)
```

Аргумент key здесь нужен для определения функции, которая конвертирует элементы последовательности в хэшируемый тип, подходящий для поиска дубликатов. Вот как это работает:
```python
>>> a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
>>> list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
>>> list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
>>>
```

Последнее решение также отлично работает, если вам нужно удалить дубликаты, базируясь на значении одного поля или атрибута или более крупной структуры данных.

### Обсуждение
Если всё, что вы хотите сделать, это просто удалить дубликаты, то часто достаточно создать множество. Например:
```python
>>> a
[1, 5, 2, 1, 9, 1, 5, 10]
>>> set(a)
{1, 2, 10, 5, 9}
>>>
```

Однако этот поход не сохраняет какой бы то ни было порядок, поэтому результат будет перемешан. Показанный выше решения помогают избежать этого. 

Использование функции-генератора в этом рецепте отражает тот факт, что вы наверняка хотите написать функцию максимально широкого назначения, а не напрямую привязанную к обработке списков. Например, если вы хотите читать файл, удаляя дублирующиеся строки, вы можете сделать так:
```python
with open(somefile,'r') as f:
	for line in dedupe(f):
		...
```

Передача функции в аргументе key имитирует похожую возможность во встроенных функциях, таких как sorted(), min() и max(). См., например, рецепты **1.8** и **1.13.**

## 1.11. Присваивание имён срезам
### Задача
Ваша программа превратилась в нечитабельную массу индексов срезов, и вы хотите всё это расчистить.

### Решение
Предположим, что у вас есть код, который вытаскивает определенные поля с данными из строковых записей с фиксированным набором полей (то есть из файла с плоской структурой или похожего формата):
```python
###### 0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:32]) * float(record[40:48])
``` 

Вместо этого вы вполне можете присвоить срезам имена:
```python
SHARES = slice(20,32)
PRICE  = slice(40,48)

cost = int(record[SHARES]) * float(record[PRICE])
```

В последнем примере вы избежали появления кучи загадочных индексов, и код стал проще и яснее.

### Обсуждение
Общее правило таково: написание кода с большим количеством неоформленных индексов ведет к проблемам с читабельностью и поддерживаемостью. Например, если вы вернетесь к такому коду через год, то наверняка не сразу вспомните, как и о чём вы думали, когда всё это писали. Приведённое выше решение — простой путь к более ясному обозначению того, что делает ваш код. 

В общем, встроенная функция slice() создает объект среза, который может быть использован везде, где можно бы использовать обычные срезы. Например:
```python
>>> items = [0, 1, 2, 3, 4, 5, 6]
>>> a = slice(2, 4)
>>> items[2:4]
[2, 3]
>>> items[a]
[2, 3]
>>> items[a] = [10,11]
>>> items
[0, 1, 10, 11, 4, 5, 6]
>>> del items[a]
>>> items
[0, 1, 4, 5, 6]
```

Если у вас есть экземпляр *slice* s, вы можете получить больше информации о нём, если посмотрите на атрибуты s.start, s.stop и s.step. Например:
```python
>>> a = slice(10, 50, 2)
>>> a.start
10
>>> a.stop
50
>>> a.step
2
>>>
```

Также вы можете наложить срез на последовательность определенного размера, используя его метод indices(size). Он возвращает кортеж (start, stop, step), где все значения соответственно ограничены, чтобы вписаться в границы (для избегания исключений IndexError при индексировании). Например:
```python
>>> s = 'HelloWorld'
>>> a.indices(len(s))
(5, 10, 2)
>>> for i in range(*a.indices(len(s))):
...   print(s[i])
...
W
r
d
>>>
```

## 1.12. Определение наиболее часто встречающихся элементов в последовательности
### Проблема
У вас есть последовательность элементов, и вы хотите узнать, какие элементы встречаются в ней чаще всего.

### Решение
Класс *collections.Counter* разработан как раз решения для подобных задач. В нем даже есть удобный метод *most_common()*, который сразу выдаст вам ответ.

Чтобы проиллюстрировать это, предположим, что у вас есть список слов, и вы хотите найти наиболее часто встречающееся. Вот как можно это сделать:
```python
words = [
	'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
	'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
	'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
	'my', 'eyes', "you're", 'under'
]

from collections import Counter

word_counts = Counter(words)
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
```

### Обсуждение
На входе объектам класса *Counter* можно скормить любую последовательность хэшируемых элементов. Под капотом *Counter* — это словарь, который отображает элементы на количество вхождений. Например:
```python
>>> word_counts['not']
1
>>> word_counts['eyes']
8
>>>
```

Если вы хотите увеличить счёт вручную, используйте сложение:
```python
>>> morewords = ['why','are','you','not','looking','in','my','eyes']
>>> for word in morewords:
...   word_counts[word] += 1
...
>>> word_counts['eyes']
9
>>>
```

Или же вы можете использовать метод *update()*:
```python
>>> word_counts.update(morewords)
>>>
```

Малоизвестная возможность экземпляров Counter состоит в том, что они могут быть легко скомбинированы с использованием разнообразных математических операций. Например:
```python
>>> a = Counter(words)
>>> b = Counter(morewords)
>>> a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1, 'not': 1})
>>> b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
		'my': 1, 'why': 1})

>>> # Combine counts
>>> c = a + b
>>> c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
		'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,
		'looking': 1, 'are': 1, 'under': 1, 'you': 1})

>>> # Subtract counts
>>> d = a - b
>>> d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
		"you're": 1, "don't": 1, 'under': 1})
>>>
```

Нет смысла упоминать, что объекты Counter — невероятно полезный инструмент для практически любых задач, где вам нужно перевести данные в табличную форму и посчитать их. Рекомендуем использовать этот способ, а не писать вручную решения на основе словарей.

## 1.13. Сортировка списка словарей по общему ключу
### Задача
У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более словарным значениям.

### Решение
Сортировка структур этого типа легко выполняется с помощью функции *itemgetter* из модуля *operator*. Предположим, вы выполнили запрос к таблице базы данных, чтобы получить список зарегистрированных пользователей вашего сайта, и получили в ответ вот такую структуру данных:
```python
rows = [
	{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
	{'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
	{'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
	{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
```  

Можно достаточно легко вывести эти строки упорядоченно по любому из полей, общих для всех словарей. Например:
```python
from operator import itemgetter

rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))

print(rows_by_fname)
print(rows_by_uid)
```

Вышеприведенный код выведет следующее:
```python
[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]

[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
```

Функция *itemgetter()* также может принимать несколько ключей. Пример кода:
```python
rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)
```

Вышеприведенный код выведет:
```python
[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
```

### Обсуждение
В этом примере строки передаются встроенной функции *sorted()*, которая принимает именованный аргумент *key*. Этот аргумент должен быть вызываемым объектом, который принимает один элемент из *rows* и возвращает значение, которое будет использовано в качестве основы для сортировки. Функция *itemgetter()* создает такой вызываемый объект. **(Прим. пер.: вызываемый объект — это объект, который имеет метод __call__).**

Функция *operator.itemgetter()* принимает в качестве аргументов индексы, которые используются для извлечения желаемых значений из записей в *rows*. Это может быть ключ словаря, номер элемента в списке или любое другое значение, которое может быть скормлено методу *__getitem()__*. Если вы передадите несколько индексов функции *itemgetter()*, вызываемый объект, который она создаст, вернет кортеж со всеми элементами, и функция *sorted()* упорядочит выводимые элементы в соответствии с отсортированным порядком кортежей. Это может быть полезно, если вы хотите провести сортировку сразу по нескольким полям (в примере это имя и фамилия):
```python
rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
```

Это решение в большинстве случаев работает отлично. Однако решение с использованием *itemgetter()* обычно выполняется быстрее. Так что обратите на него внимание, если производительность в фокусе вашего внимания.

Последнее по порядку, но не по значению: не забудьте, что описанная в этом рецепте техника может быть применена к таким функциям, как *min()* и *max()*. Например:
```python
>>> min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
>>> max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
>>>
```

## 1.14. Сортировка объектов, не поддерживающих сравнение
### Задача
Вы хотите отсортировать объекты одного класса, но они не поддерживают операции сравнения.

### Решение
Встроенная функция *sorted()* принимает аргумент *key*, в котором может быть передан вызываемый объект, который будет возвращать некоторое значение из объектов, которое *sorted()* будет использовать для сравнения этих объектов. Например, если у вас в приложении есть последовательность экземпляров класса *User*, и вы хотите отсортировать их по атрибуту *user_id*, то вы могли бы предоставить вызываемый объект, который принимает экземпляр класса *User* и возвращает атрибут *user_id*. Например:  
```python
>>> class User:
...  def __init__(self, user_id):
...  	self.user_id = user_id
...  def __repr__(self):
...  	return 'User({})'.format(self.user_id)
...
>>> users = [User(23), User(3), User(99)]
>>> users
[User(23), User(3), User(99)]
>>> sorted(users, key=lambda u: u.user_id)
[User(3), User(23), User(99)]
>>>
```

Вместо лямбды можно применить альтернативный подход с использованием *operator.attrgetter()*: 
```python
>>> from operator import attrgetter
>>> sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
>>>
```

### Обсуждение
Использовать или не использовать лямбду или *attrgetter()* — вопрос личных предпочтений. Однако *attrgetter()* часто оказывается немного быстрее, а также добавляет возможность одновременного извлечения нескольких полей. Это аналогично использованию *operator.itemgetter()* для словарей (см. **рецепт 1.13.**). Например, если экземпляры класса User также имеют атрибуты *first_name* и *last_name*, вы можете выполнить вот такую сортировку:
```python
by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
```

Также стоит отметить, что использованный в этом рецепте приём может быть применён к таким функциям, как *min()* и *max()*. Например:
```python
>>> min(users, key=attrgetter('user_id')
User(3)
>>> max(users, key=attrgetter('user_id')
User(99)
>>>
``` 

## 1.15. Группировка записей на основе полей
### Задача
У вас есть последовательность словарей или экземпляров, и вы хотите итерировать по данным в группах, основываясь на значении конкретного поля (например, на дате).

### Решение
Функция *itertools.groupby()* особенно полезна для такого типа группировки данных. Предположим, что у вас есть список словарей:
```python
rows = [
	{'address': '5412 N CLARK', 'date': '07/01/2012'},
	{'address': '5148 N CLARK', 'date': '07/04/2012'},
	{'address': '5800 E 58TH', 'date': '07/02/2012'},
	{'address': '2122 N CLARK', 'date': '07/03/2012'},
	{'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
	{'address': '1060 W ADDISON', 'date': '07/02/2012'},
	{'address': '4801 N BROADWAY', 'date': '07/01/2012'},
	{'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
```

Предположим также, что вы хотите проитерировать по данным, причем сгруппированными по дате кусочками. Проведем отсортировку по нужному полю (в данном случае по дате), а потом применим *itertools.groupby()*:
```python
from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))

# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
	print(date)
	for i in items:
		print(' ', i)
```    

Вывод будет таким:
```python
07/01/2012
	{'date': '07/01/2012', 'address': '5412 N CLARK'}
	{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
	{'date': '07/02/2012', 'address': '5800 E 58TH'}
	{'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
	{'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
	{'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
	{'date': '07/04/2012', 'address': '5148 N CLARK'}
	{'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
```

### Обсуждение
Функция *groupby()* работает так: сканирует последовательность и ищет последовательные «партии» одинаковых значений (или значений, возвращенных переданной через *key* функцией). В каждой итерации функции возвращает значение вместе с итератором, который выводит все элементы в группу с одинаковым значением.

Важным предварительным шагом тут является сортировка данных по интересующему нас полю. Поскольку *groupby()* проверяет только последовательные элементы, без предварительной сортировки группировка записей выполнена не будет.

Если ваша цель — просто сгруппировать данные вместе в крупную структуру данных с произвольным доступом, то вам больше поможет defaultdict(), которая создает «мультисловарь», как описано в **рецепте 1.6**. Например:
```python
from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
	rows_by_date[row['date']].append(row)
```

Это позволяет легко получить доступ к записям для каждой даты:
```python
>>> for r in rows_by_date['07/01/2012']:
...   print(r)
...
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
>>>
```

В последнем примере предварительная сортировка записей не обязательна. Но если вы не заботитесь о потреблении памяти, то может оказаться быстрее сделать это с помощью предварительной сортировки и итерированию с использованием *groupby()*.  

## 1.16. Фильтрование элементов последовательности
### Задача
У вас есть данные внутри последовательности, и вы хотите извлечь значения или уменьшить последовательность по какому-либо критерию.

### Решение
Самый простой способ фильтрования последовательности — использовать генератор списка (list comprehension). Например:
```python
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> [n for n in mylist if n > 0]
[1, 4, 10, 2, 3]
>>> [n for n in mylist if n < 0]
[-5, -7, -1]
>>>
```

Потенциальная проблема с использованием генераторов списоков заключается в том, что они могут создать большой результат, если размер входных данных тоже большой. Если это вас беспокоит, вы можете использовать выражения-генераторы для итеративного возврата отфильтрованных значений. Например:
```python
>>> pos = (n for n in mylist if n > 0)
>>> pos
<generator object <genexpr> at 0x1006a0eb0>
>>> for x in pos:
...   print(x)
...
1
4
10
2
3
>>>
```
Иногда критерий фильтрования не может быть легко выражен в форме генератора списка или выражения-генератора. Предположим, например, что процесс фильтрования включает обработку исключений или какой-то другой сложный момент. Чтобы справиться с этим, поместите фильтрующий код в функцию и используйте встроенную функцию *filter()*. Например: 
```python
values = ['1', '2', '-3', '-', '4', 'N/A', '5']

def is_int(val):
	try:
		x = int(val)
		return True
	except ValueError:
		return False

ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
```

*filter()* создает итератор, так что если вы хотите получить список результатов, не забудьте использовать *list()*, как показано выше.

### Обсуждение
Генераторы списков и выражения-генераторы часто являются самым лёгким и прямым способом фильтрования простых данных. Но у них также есть дополнительная способность одновременного изменения данных. Например:
```python
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> import math
>>> [math.sqrt(n) for n in mylist if n > 0]
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
>>>
```  

Одна из разновидностей фильтрования включает замену значений, которые не подходят под определенный критерий, другим значением (вместо отбраковки неподходящих). Например, вместо простого поиска положительных значений, вы также хотите обрезать «плохие» значения, чтобы они попадали в определенный диапазон. В большинстве случаев это легко сделать с помощью перемещения критерия фильтрования в условное выражение:
```python
>>> clip_neg = [n if n > 0 else 0 for n in mylist]
>>> clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
>>> clip_pos = [n if n < 0 else 0 for n in mylist]
>>> clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
>>>
```

Другой важный инструмент для фильтрации — *itertools.compress()*, который принимает итерируемый объект вместе с последовательностью-селектором из булевых значений. На выходе функция выдает все элементы итерируемого объекта, для которых совпадающий элемент в селекторе — True. Это может быть полезно, если вы пытаетесь применить результаты фильтрования одной последовательности к другой связанной последовательности. Например, у вас есть две колонки данных:
```python
addresses = [
	'5412 N CLARK',
	'5148 N CLARK',
	'5800 E 58TH',
	'2122 N CLARK'
	'5645 N RAVENSWOOD',
	'1060 W ADDISON',
	'4801 N BROADWAY',
	'1039 W GRANVILLE',
]

counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
```

Теперь предположим, что вы хотите создать список всех адресов, где соответствующие значение из *counts* больше 5. Вот как это можно сделать:
```python
>>> from itertools import compress
>>> more5 = [n > 5 for n in counts]
>>> more5
[False, False, True, False, False, True, True, False]
>>> list(compress(addresses, more5))
['5800 E 58TH', '4801 N BROADWAY', '1039 W GRANVILLE']
>>>
``` 

Ключевой момент — сначала создать последовательность булевых значений, которые будут указывать, какие элементы удовлетворяют заданному условию. Далее функция *compress()* выберет элементы, соответствующие значениям True.

Как и *filter()*, функция *compress()* возвращает итератор. Поэтому если вы хотите на выходе получить список, вам придется использовать *list()*.  

## 1.17. Извлечение подмножества из словаря
### Задача
Вы хотите создать словарь, который будет подмножеством другого словаря.

### Решение
Эту задачу можно легко решить с помощью генератора словаря (dictionary comprehension). Например:
```python
prices = {
	'ACME': 45.23,
	'AAPL': 612.78,
	'IBM': 205.55,
	'HPQ': 37.20,
	'FB': 10.75
}

# Make a dictionary of all prices over 200
p1 = { key:value for key, value in prices.items() if value > 200 }

# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:value for key,value in prices.items() if key in tech_names }
```

### Обсуждение
Большая часть того, что можно сделать с помощью генераторов словарей, можно осуществить путём создания последовательности кортежей и передачи их в функцию *dict()*. Например:
```python
p1 = dict((key, value) for key, value in prices.items() if value > 200)
```

Однако решение на основе генератора словаря немного яснее и работает немного быстрее (в рассмотренном выше примере генератор отработал в два раза быстрее). 

Иногда существует множество путей решить задачу. Например, второй пример можно переписать так:
```python
# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() & tech_names }
```

Однако подсчет времени выполнения открывает нам, что это решение почти в 1,6 раза медленнее, чем первое. Если производительность для вас важна, обычно стоит потратить немного времени на изучение таких вопросов. См. **рецепт 14.13.**, чтобы получить детальную информацию о подсчете времени и профилировании.

## 1.18. Отображение имен на последовательность элементов
### Задача
У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции, но такой подход часто делает программу нечитабельной. Также вы можете захотеть уменьшить зависимость от позиции в структуре данных путём перехода к доступу к элементам по имени.

### Решение
*collections.namedtuple()* предоставляет такую возможность, добавляя минимальный оверхед по сравнению с использованием обычного кортежа. *collections.namedtuple()* — это фабричный метод, который возвращает подкласс стандартного пайтоновского типа tuple (кортеж). Вы скармливаете этому методу имя типа и поля, которые он должен иметь, и он возвращает класс, который может порождать экземпляры с полями, которые вы определили, и значениями этих полей, которые вы передадите при порождении. Например:
```python
>>> from collections import namedtuple
>>> Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
>>> sub = Subscriber('jonesy@example.com', '2012-10-19')
>>> sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
>>> sub.addr
'jonesy@example.com'
>>> sub.joined
'2012-10-19'
>>>
```

Хотя экземпляр *namedtuple* (именованного кортежа) выглядит так же, как и обычный экземпляр класса, он взаимозаменяем с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка. Например:
```python
>>> len(sub)
2
>>> addr, joined = sub
>>> addr
'jonesy@example.com'
>>> joined
'2012-10-19'
>>>
```  

Самый частый случай использования именованного кортежа — отвязка вашего кода от работы с позициями элементов, которыми он манипулирует. Так что если вы получаете большой список кортежей в ответ на запрос к базе данных, а потом манипулируете ими через позиционное обращение к элементам, ваш код может сломаться, если вы, скажем, добавите новую колонку в таблицу. Этого можно избежать, если вы сначала превратите полученные кортежи в именованные кортежи.

Чтобы проиллюстрировать это, приведём пример кода, использующего обычные кортежи:
```python
def compute_cost(records):
	total = 0.0
	for rec in records:
		total += rec[1] * rec[2]
	return total
```

Использование позиционного обращения к элементам часто делает код немного менее выразительным и более зависимым от структуры записей. А вот версия с использованием именованного кортежа:
```python
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
	total = 0.0
	for rec in records:
		s = Stock(*rec)
		total += s.shares * s.price
	return total
```

Естественно, вы можете избежать явной конвертации в именованный кортеж *Stock*, если последовательность *records* из примера уже содержит такие экземпляры. 

### Обсуждение
Возможное использование именованного кортежа — замена словаря, который требует больше места для хранения. Так что если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако не забудьте, что именнованные кортежи неизменяемы (в отличие от словарей). Например:
```python
>>> s = Stock('ACME', 100, 123.45)
>>> s
Stock(name='ACME', shares=100, price=123.45)
>>> s.shares = 75
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
>>>
```

Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода *_replace()*, которым обладают экземпляры именованных кортежей. Он создает полностью новый именованный кортеж, в котором указанные значения заменены. Например:
```python
>>> s = s._replace(shares=75)
>>> s
Stock(name='ACME', shares=75, price=123.45)
>>>
```

Тонкость использования метода *_replace()* заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте *_replace()* для создания новых экземпляров с замененными значениями. Например:
```python
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])

# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)

# Function to convert a dictionary to a Stock
def dict_to_stock(s):
	return stock_prototype._replace(**s)
```   

Вот пример работы этого кода:
```python
>>> a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
>>> dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
>>> b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
>>> dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
>>>
```

Последнее, но важное замечание: стоит отметить, что если вашей целью является создание эффективной структуры данных, где вы сможете менять различные атрибуты экземпляров, использование именованных кортежей — не лучший вариант. Вместо них стоит определить класс с использованием \__slots__ (см. **рецепт 8.4.**)


## 1.19. Одновременное преобразование и сокращение данных
### Задача
Вам нужно выполнить функцию сокращения (т.е. sum(), min(), max()), но сначала необходимо преобразовать или отфильтровать данные.

### Решение
Есть весьма элегантное решение для объединения сокращения и преобразования данных — выражение-генератор в аргументе. Например, если вы хотите подсчитать сумму квадратов, попробуйте следующее:
```python
nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
``` 

Вот еще несколько примеров:
```python
# Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
	print('There be python!')
else:
	print('Sorry, no python.')

# Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))

# Data reduction across fields of a data structure
portfolio = [
	{'name':'GOOG', 'shares': 50},
	{'name':'YHOO', 'shares': 75},
	{'name':'AOL', 'shares': 20},
	{'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio)
```

### Обсуждение
Решение демонстрирует тонкий синтаксический аспект выражений-генераторов, связанный с передачей их как единственного аргумента в функцию — повторяющиеся скобки не нужны. Например, следующие инструкции эквивалентны:
```python
s = sum((x * x for x in nums))  # Pass generator-expr as argument
s = sum(x * x for x in nums)  # More elegant syntax
```

Использование аргумента-генератора часто будет более эффективным и элегантным, нежели предварительное создание временного списка. Например, если вы не используете выражение-генератор, вы можете поразмыслить над этой альтернативной имплементацией:
```python
nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
```

Это работает, но вводит лишний шаг и создает лишний список. Для небольшого списка из примера это не имеет значения, но если *nums* был огромным, вы получите крупную временную структуру данных, которая будет использована только один раз, а потом выброшена. Решение с генератором обрабатывает данные итеративно и потому намного более эффективно с точки зрения использования памяти.

Некоторые функции сокращения, такие как *min()* и *max()*, принимают аргумент *key*, что может оказаться полезным в ситуациях, когда вы склоняетесь к использованию генератора. Например, в этом примере вы можете попробовать альтернативный подход:
```python
# Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)

# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares'])
```

## 1.20. Объединение нескольких отображений в одно
### Задача
У вас есть много словарей или отображений, которые вы хотите логически объединить в одно отображение, чтобы выполнить некоторые операции, такие как поиск значений или проверка существования ключей.

### Решение
Предположим, у вас есть два словаря:
```python
a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
```

А теперь предположим, что вы хотите провести поиски, в которых вы хотите проверить оба словаря (то есть сначала проверить в словаре *a*, а потом в *b*, если в первом словаре искомое не найдено). Простой способ сделать это — использовать класс *ChainMap* из модуля *collections*. Например:
```python
from collections import ChainMap
c = ChainMap(a,b)
print(c['x'])  # Outputs 1 (from a)
print(c['y'])  # Outputs 2 (from b)
print(c['z'])  # Outputs 3 (from a)
```

### Обсуждение
*ChainMap* принимает несколько отображений и делает так, что они логически становятся единым целым. Однако в буквальном смысле они не сливаются. Вместо этого *ChainMap* просто содержит список отображений и переопределяет обычные операции над словарями для сканирования этого списка. Большинство операций работают. Например:
```python
>>> len(c)
3
>>> list(c.keys())
['x', 'y', 'z']
>>> list(c.values())
[1, 2, 3]
>>>
``` 

В случае появления одинаковых ключей будут использованы значения из первого словаря. Например, *c['z']* в примере всегда будет ссылаться на значение из словаря *a*, а не из *b*.

Операции, которые изменяют отображение, всегда действуют на первое отображение в списке. Например:
```python
>>> c['z'] = 10
>>> c['w'] = 40
>>> del c['x']
>>> a
{'w': 40, 'z': 10}
>>> del c['y']
Traceback (most recent call last):
...
KeyError: "Key not found in the first mapping: 'y'"
>>>
``` 

*ChainMap* особенно полезны для работы с ограниченным набором значений, таких как переменные языка программирования (глобальные, локальные и т.п.) На самом деле даже существуют методы, которые всё упрощают:
```python
>>> values = ChainMap()
>>> values['x'] = 1
>>> # Add a new mapping
>>> values = values.new_child()
>>> values['x'] = 2
>>> # Add a new mapping
>>> values = values.new_child()
>>> values['x'] = 3
>>> values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
>>> values['x']
3
>>> # Discard last mapping
>>> values = values.parents
>>> values['x']
2
>>> # Discard last mapping
>>> values = values.parents
>>> values['x']
1
>>> values
ChainMap({'x': 1})
>>>
```  

В качестве альтернативы *ChainMap* вы можете обдумать слияние словарей с использованием метода update(). Например:
```python
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = dict(b)
>>> merged.update(a)
>>> merged['x']
1
>>> merged['y']
2
>>> merged['z']
3
>>>
``` 

Это работает, но требует от вас создания полностью нового объекта словаря (или необратимого изменения одного из существующих). В этом случае при изменении одного из первоначальных словарей новый объект объединенного словаря изменения не затронут. Например:
```python
>>> a['x'] = 13
>>> merged['x']
1
``` 

*ChainMap* использует первоначальные словари, поэтому не подвержен такому поведению. Например:
```python
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = ChainMap(a, b)
>>> merged['x']
1
>>> a['x'] = 42
>>> merged['x']  # Notice change to merged dicts
42
>>>
```

# Строки и текст
Практически любая полезная программа включает тот или иной вид обработки текста: от парсинга данных до генерации вывода. Эта глава рассматривает обычные задачи манипулирования текстом, такие как разбивка строк, поиск, подстановка, лексический анализ и парсинг. Многие из этих задач могут быть легко решены с использованием встроенных строковых методов. Однако более сложные операции могут потребовать использования регулярных выражений ии создания полноценного парсера. Все эти темы разобраны в данной главе. Также мы обратим внимание на несколько хитрых аспектов работы с Unicode.

## 2.1. Разрезание строк, разделенных различными разделителями
### Задача
Вам нужно разделить строку на поля, но разделители (и пробелы вокруг них) внутри строки не одинаковые.

### Решение
Функция *re.split()* будет в этом случае весьма полезной, поскольку вы сможете определить многочисленные шаблоны разделителей. Например, как показано в решении, разделитель может быть либо запятой (,), точкой с запятой (;) или пробелом, за которым следует любое количество дополнительных пробелов. Какой бы из этих шаблонов ни был найден, совпадение становится разделителем. Результатом будет просто список полей, точно такой же, какой создает строковый метод *str.split()*.

При применении re.split() вы должны быть осторожными, если шаблон регулярного выражения использует группу, заключенную в скобки. При использовании групп совпавший с шаблоном текст также включается в результат. Например:
```python
>>> fields = re.split(r'(;|,|\s)\s*', line)
>>> fields
['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
>>>
```

Получение символов-разделителей может быть полезным в некоторых обстоятельствах. Например, вам могут потребоваться эти символы позже — для переформатирования выводимой строки:
```python
>>> values = fields[::2]
>>> delimiters = fields[1::2] + ['']
>>> values
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>> delimiters
[' ', ';', ',', ',', ',', '']

>>> # Reform the line using the same delimiters
>>> ''.join(v+d for v,d in zip(values, delimiters))
'asdf fjdk;afed,fjek,asdf,foo'
>>>
```

Если вы не хотите, чтобы разделители попали в результат, но при этом вам нужно применить группы в шаблоне регулярного выражения, убедитесь, что вы используете незахватывающую (noncapture) группу, которая определяется так: (?:...). Например:
```python
>>> re.split(r'(?:,|;|\s)\s*', line)
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>>
```

## 2.2. Поиск текста в начале и в конце строки
### Задача
Вам нужно проверить начало или конец строки на содержание неких текстовых шаблонов, таких как расширения файлов, схемы URL и т.д.

### Решение
Простой способ проверить начало или конец строки — применить методы *str.startswith()* или *str.endswith()*. Например:
```python
>>> filename = 'spam.txt'
>>> filename.endswith('.txt')
True
>>> filename.startswith('file:')
False
>>> url = 'http://www.python.org'
>>> url.startswith('http:')
True
>>>
```

Если вам нужно проверить несколько вариантов, передайте кортеж с ними в *startswith()* или *endswith()*:
```python
>>> import os
>>> filenames = os.listdir('.')
>>> filenames
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ]
>>> [name for name in filenames if name.endswith(('.c', '.h')) ]
['foo.c', 'spam.c', 'spam.h'
>>> any(name.endswith('.py') for name in filenames)
True
>>>
```

А вот другой пример:
```python
from urllib.request import urlopen

def read_data(name):
	if name.startswith(('http:', 'https:', 'ftp:')):
		return urlopen(name).read()
	else:
		with open(name) as f:
		return f.read()
```

Любопытно, что в этом случае на вход нужно подавать именно кортеж. Если так случилось, что варианты выбора собраны у вас в списке или множестве, сначала сконвертируйте их с помощью *tuple()*. Например:
```python
>>> choices = ['http:', 'ftp:']
>>> url = 'http://www.python.org'
>>> url.startswith(choices)
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: startswith first arg must be str or a tuple of str, not list
>>> url.startswith(tuple(choices))
True
>>>
```

### Обсуждение
Методы *startswith()* и *endswith()* предоставляют весьма удобный способ проверки префиксов и окончаний. Такие же операции можно осуществить с помощью срезов, но это намного менее элегантно. Например:
```python
>>> filename = 'spam.txt'
>>> filename[-4:] == '.txt'
True
>>> url = 'http://www.python.org'
>>> url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
True
>>>
```

Вы также можете склониться к использованию регулярных выражений в качестве альтернативы. Например:
```python
>>> import re
>>> url = 'http://www.python.org'
>>> re.match('http:|https:|ftp:', url)
<_sre.SRE_Match object at 0x101253098>
>>>
```

Такой подход работает, но часто это будет огнем из пушки по воробьям. Использование вышеописанного рецепта проще и работает быстрее.

И последнее: методы *startswith()* и *endswith()* отлично работают вместе с другими операциями, такими как обычные сокращения данных. Например, это выражение проверяет каталог на присутствие файлов определенных типов:
```python
if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
...
```  

## 2.3. Поиск строк с использованием масок оболочки (shell)
### Задача
Вы хотите найти текст, используя те же маски, которые обычно используются в оболочках Unix (например, *.py, Dat[0-9]*.csv и т.д.)

### Решение
Модуль *fnmatch* предоставляет две функции: *fnmatch()* и *fnmatchcase()*, которые можно использовать для такого поиска. Всё просто:
```python
>>> from fnmatch import fnmatch, fnmatchcase
>>> fnmatch('foo.txt', '*.txt')
True
>>> fnmatch('foo.txt', '?oo.txt')
True
>>> fnmatch('Dat45.csv', 'Dat[0-9]*')
True
>>> names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
>>> [name for name in names if fnmatch(name, 'Dat*.csv')]
['Dat1.csv', 'Dat2.csv']
>>>
```

По умолчанию *fnmatch()* использует те же чувствительные к регистру правила, как и файловая система текущей операционной системы (то есть правила меняются от системы к системе). Например:
```python
>>> # On OS X (Mac)
>>> fnmatch('foo.txt', '*.TXT')
False

>>> # On Windows
>>> fnmatch('foo.txt', '*.TXT')
True
>>>
```

Если это различие важно, используйте метод *fnmatchcase()*. Он ищет именно такие совпадения заглавных и строчных букв, которые вы предоставите:
```python
>>> fnmatchcase('foo.txt', '*.TXT')
False
>>>
```

Часто упускается из вида возможность использования этих функций на строках, получаемых при обработке данных, или на строках, не являющихся именами файлов. Например, у вас есть список адресов:
```python
addresses = [
	'5412 N CLARK ST',
	'1060 W ADDISON ST',
	'1039 W GRANVILLE AVE',
	'2122 N CLARK ST',
	'4802 N BROADWAY',
]
``` 

Вы можете написать такой генератор списка (list comprehension):
```python
>>> from fnmatch import fnmatchcase
>>> [addr for addr in addresses if fnmatchcase(addr, '* ST')]
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
>>> [addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')]
['5412 N CLARK ST']
>>>
```

### Обсуждение
Поиск совпадений с использованием *fnmatch* занимает нишу между возможностями простых строковых методов и полной мощью регулярных выражений. Если вы просто хотите простой механизм для применения масок в обработке данных, он часто является подходящим решением.

Если же вы пишете код для поиска имён файлов, используйте модуль *glob* (см. **рецепт 5.13.**)

## 2.4. Поиск совпадений и поиск текстовых паттернов
### Задача
Вы хотите отыскать совпадение или провести поиск по определенному шаблону.

### Решение
Если текст, который вы хотите найти, является простым литералом, в большинстве случаев вам подойдут базовые строковые методы, такие как *str.find()*, *str.endswith()*, *str.startwith()* и другие подобные. Например:
```python
>>> text = 'yeah, but no, but yeah, but no, but yeah'

>>> # Exact match
>>> text == 'yeah'
False

>>> # Match at start or end
>>> text.startswith('yeah')
True
>>> text.endswith('no')
False

>>> # Search for the location of the first occurrence
>>> text.find('no')
10
>>>
```

Для более сложного поиска совпадений используйте регулярные выражения и модуль *re*. Чтобы проиллюстрировать базовые механики использования регулярных выражений, предположим, что вы хотите найти даты, определенные цифрами, такие как «11/27/2012.» Вот пример того, как вы можете это сделать:
```python
>>> text1 = '11/27/2012'
>>> text2 = 'Nov 27, 2012'
>>>
>>> import re
>>> # Simple matching: \d+ means match one or more digits
>>> if re.match(r'\d+/\d+/\d+', text1):
...   print('yes')
... else:
...   print('no')
...
yes
>>> if re.match(r'\d+/\d+/\d+', text2):
...   print('yes')
... else:
...   print('no')
...
no
>>>
```

Если вы собираетесь много раз искать по одному и тому же шаблону, часто окупается предварительная компиляция шаблона регулярного выражения в объект шаблона. Например:
```python
>>> datepat = re.compile(r'\d+/\d+/\d+')
>>> if datepat.match(text1):
...   print('yes')
... else:
...   print('no')
...
yes
>>> if datepat.match(text2):
...   print('yes')
... else:
...   print('no')
...
no
>>>
```

*match()* всегда пытается найти совпадения в начале строки. Если вы хотите провести поиск по всем случаям соответствия шаблону, используйте метод *findall()*. Например:
```python
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
['11/27/2012', '3/13/2013']
>>>
```

При составлении регулярных выражений, часто нужно использовать захватывающие группы, заключая части шаблона в скобки. Например:
```python
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>>
```

Захватывающие группы часто упрощают последующую обработку найденного текста, поскольку содержимое каждой группы может быть извлечено отдельно. Например:
```python
>>> m = datepat.match('11/27/2012')
>>> m
<_sre.SRE_Match object at 0x1005d2750>

>>> # Extract the contents of each group
>>> m.group(0)
'11/27/2012'
>>> m.group(1)
'11'
>>> m.group(2)
'27'
>>> m.group(3)
'2012'
>>> m.groups()
('11', '27', '2012')
>>> month, day, year = m.groups()
>>>

>>> # Find all matches (notice splitting into tuples)
>>> text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>> for month, day, year in datepat.findall(text):
...   print('{}-{}-{}'.format(year, month, day))
...
2012-11-27
2013-3-13
>>>
```

Метод *findall()* проходит по тексту и находит все совпадения, возвращая их в списке. Если вы хотите искать совпадения итеративно, используйте метод *finditer()*:
```python
>>> for m in datepat.finditer(text):
...   print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
>>>
```

### Обсуждение
Вводного курса в теорию регулярных выражений в этой книге вы не найдете. Однако этот рецепт демонстрирует простейшие примеры использования модуля re для поиска совпадений в тексте. Самые основные приёмы — компилирование шаблонов с использованием *re.compile()* и последующее использование таких методов как *match()*, *findall()* или *finditer()*.  

При составлении шаблонов часто нужно использовать «сырые» (raw) строки, такие как r'(\d+)/(\d+)/(\d+)'. Такие строки оставляют символы обратных слэшей необработанными, что может быть полезно в контесте применения регулярных выражений. С другой стороны, вы можете использовать двойные обратные слэши: '(\\d+)/(\\d+)/(\\d+)'. 

Учтите, что метод *match()* проверяет только начало строки. Возможно, что он найдет вещи, которые вы не ожидаете. Например:
```python
>>> m = datepat.match('11/27/2012abcdef')
>>> m
<_sre.SRE_Match object at 0x1005d27e8>
>>> m.group()
'11/27/2012'
>>>
```

Если вам нужно точное совпадение, убедитесь, что шаблон включает символ завершения ($), как в примере ниже:
```python
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
>>> datepat.match('11/27/2012abcdef')
>>> datepat.match('11/27/2012')
<_sre.SRE_Match object at 0x1005d2750>
>>>
```

И последнее: если вы просто проводите простые операции поиска, вы часто можете пропустить шаг компиляции и использовать функции уровня модуля из модуля *re*. Например:
```python
>>> re.findall(r'(\d+)/(\d+)/(\d+)', text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>>
``` 

Обратите внимание, что если вы проводите много операций поиска совпадений, часто окупается компилирование шаблона и многократное его использование. Функции уровня модуля поддерживают кэш недавно скомпилированных паттернов, так что вы не получите огромного выигрыша в производительности, но вы сэкономите несколько обращений и избежите лишней обработки, используя ваш собственный скомпилированный шаблон.

## 2.5. Поиск и замена текста
### Задача
Вы хотите найти в строке и заменить текст, соответствующий некому шаблону. 

### Решение
Для простых литеральных шаблонов используйте метод *str.replace()*. Например:
```python
>>> text = 'yeah, but no, but yeah, but no, but yeah'

>>> text.replace('yeah', 'yep')
'yep, but no, but yep, but no, but yep'
>>>
```

Для более сложных шаблонов используйте функции/методы *sub()* из модуля *re*. Предположим, вы хотите перезаписать даты, чтобы перевести из их формата “11/27/2012” в “2012-11-27.” Вот пример того, как это можно сделать:
```python
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> import re
>>> re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>
```

Первый аргумент, передаваемый в *sub()*, это шаблон для поиска, а второй — шаблон, которым нужно заменять найденное. Цифры, перед которыми поставлен обратный слэш (такие как \3), ссылаются на номера захватывающих групп в шаблоне.

Если вы собираетесь многократно выполнять подстановку по одному и тому же шаблону, рекомендуем скомпилировать его для увеличения производительности. Например:
```python
>>> import re
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>> datepat.sub(r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>
```

В случае более сложных подстановок можно определить подстановочную функцию с обратным вызовом (callback function). Например:
```python
>>> from calendar import month_abbr
>>> def change_date(m):
...   mon_name = month_abbr[int(m.group(1))]
...   return '{} {} {}'.format(m.group(2), mon_name, m.group(3))
...
>>> datepat.sub(change_date, text)
'Today is 27 Nov 2012. PyCon starts 13 Mar 2013.'
>>>
```

На вход подстановочному коллбэку в аргументе передается объект поиска совпадений, возвращенный функцией *match()* или *find()*. Используйте метод *.group()* для извлечения определенных частей совпадения. Функция должна возвращать текст замены (replacement text). 

Если вы хотите знать, сколько подстановок было сделано в дополнение к получению текста замены (replacement text), используйте *re.subn()*. Например:
```python
>>> newtext, n = datepat.subn(r'\3-\1-\2', text)
>>> newtext
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>> n
2
>>>
```

### Обсуждение
В поиске совпадений с помощью регулярных выражений не особо много чего-то дополнительного к показанному примеру с использованием метода *sub()*. Самое сложное — это составление шаблона регулярного выражения, и это мы оставляем читателю в качестве упражнений.


## 2.6. Поиск и замена текста без учета регистра
### Задача
Вам необходимо найти и, возможно, заменить текст, не обращая внимания на регистр букв.

### Решение
Для выполнения действий над текстом без учёта регистра вам понадобится модуль *re* и флаг *re.IGNORECASE*, который можно применять в различных операциях. Например:
```python
>>> text = 'UPPER PYTHON, lower python, Mixed Python'
>>> re.findall('python', text, flags=re.IGNORECASE)
['PYTHON', 'python', 'Python']
>>> re.sub('python', 'snake', text, flags=re.IGNORECASE)
'UPPER snake, lower snake, Mixed snake'
>>>
``` 

Последний пример раскрывает ограничение: текст замены не будет совпадать по регистру с заменяемым текстом. Если вам нужно исправить такое поведение, используйте поддерживающую функцию:
```python
def matchcase(word):
	def replace(m):
		text = m.group()
		if text.isupper():
			return word.upper()
		elif text.islower():
			return word.lower()
		elif text[0].isupper():
			return word.capitalize()
		else:
			return word
	return replace
```

А вот пример использования этой функции:
```python
>>> re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE)
'UPPER SNAKE, lower snake, Mixed Snake'
>>>
```

### Обсуждение
В простых случаях простого использования *re.INGNORECASE* достаточно для поиска совпадений без учёта регистра. Однако обратите внимание, что этого может оказаться недостаточно для некоторых случаев работы с Unicode, использующих выравнивание регистров (case folding). См. **рецепт 2.10.**


## 2.7. Определение регулярных выражений для поиска кратчайшего совпадения
### Задача
Вы пытаетесь найти совпадение по текстовому шаблону, используя регулярное выражение, но оно находит самое длинное из всех возможных совпадений. Вы же хотите найти самое короткое из всех возможных.

### Решение
Эта проблема часто возникает в шаблонах, которые пытаются найти текст, заключенный в пару открывающих и закрывающих разделителей (например, строка в кавычках). Рассмотрим следующий пример:
```python
>>> str_pat = re.compile(r'\"(.*)\"')
>>> text1 = 'Computer says "no."'
>>> str_pat.findall(text1)
['no.']
>>> text2 = 'Computer says "no." Phone says "yes."'
>>> str_pat.findall(text2)
['no." Phone says "yes.']
>>>
```

В этом примере шаблон r'\"(\.\*)\"' пытается найти текст, заключенный в кавычки. Однако оператор \* в регулярном выражении является жадным, поэтому поиск получается поиском самого длинного из возможных совпадений. Поэтому во втором примере с переменной *text2* неверно выполняется сопоставление двух строк в кавычках.

Чтобы исправить это, добавьте модификатор ? после оператора \* в шаблоне:
```python
>>> str_pat = re.compile(r'\"(.*?)\"')
>>> str_pat.findall(text2)
['no.', 'yes.']
>>>
```
Это делает поиск совпадений нежадным и выводит кратчайшее из найденных совпадений.

### Обсуждение
Этот рецепт решает одну из часто встречающихся при написании регулярных выражений с символом точки (\.) задач. В шаблоне точка соотвествует любому символу за исключением символа новой строки. Однако если вы окружите точку открывающим и закрывающим текстом (таким как кавычки), поиск будет пытаться найти самое длинное из возможных совпадений. Это вызывает многочисленные случаи пропуска открывающего и закрывающего текста и включения в результаты самого длинного совпадения. Добавление ? сразу после таких операторов как \* или \+ заставляет алгоритм поиска искать самое короткое совпадение.

## 2.8. Написание регулярного выражения для многострочных шаблонов
### Вы пытаетесь провести поиск по блоку текстов с использованием регулярного выражения, но вам нужно, чтобы совпадение охватывало несколько строк.

### Решение
Эта проблема обычно возникает в шаблонах, которые используют точку (\.) для поиска совпадения с любым символом. Многие забывают, что точка не может совпадать с символом новой строки. Например, вы пытаетесь найти совпадения в комментариях в стиле языка С:
```python
>>> comment = re.compile(r'/\*(.*?)\*/')
>>> text1 = '/* this is a comment */'
>>> text2 = '''/* this is a
... multiline comment */
... '''
>>>
>>> comment.findall(text1)
[' this is a comment ']
>>> comment.findall(text2)
[]
>>>
```

Чтобы исправить проблему, вам нужно добавить поддержку символов новой строки. Например:
```python
>>> comment = re.compile(r'/\*((?:.|\n)*?)\*/')
>>> comment.findall(text2)
[' this is a\n multiline comment ']
>>>
```

В этом шаблоне (?:.|\n) определяет незахватывающую группу (то есть выражение определяет группу для целей поиска совпадений, но эта группа не захватывается и не подсчитывается).

### Обсуждение
Функция *re.compile()* принимает полезный в данном случае флаг *re.DOTALL*. Он заставляет . в регулярном выражении совпадать с любыми символами, включая символ новой строки. Например:
```python
>>> comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)
>>> comment.findall(text2)
[' this is a\n multiline comment ']
```

Использование флага *re.DOTALL* отличное работает в простых случаях, но это может быть проблематично при работе с очень сложными шаблонами или сочетанием отдельных регулярных выражений, которые должны объединяться друг с другом для токенизации (как описано в **рецепте 2.18.**) Если у вас есть выбор, обычно лучше определить шаблон регулярного выражения так, чтобы он работал правильно без необходимости в дополнительных флагах.

## 2.9. Приведение текста в Unicode к стандартному представлению (нормализация)
### Задача
Вы работате со строками Unicode и хотите убедиться, что все эти строки имеют одинаковое внутреннее представление.

### Решение
В Unicode некоторые символы могут быть представлены несколькими допустимыми кодирующими последовательностями. Рассмотрим пример:
```python
>>> s1 = 'Spicy Jalape\u00f1o'
>>> s2 = 'Spicy Jalapen\u0303o'
>>> s1
'Spicy Jalapeño'
>>> s2
'Spicy Jalapeño'
>>> s1 == s2
False
>>> len(s1)
14
>>> len(s2)
15
>>>
```

Здесь текст “Spicy Jalapeño” представлен в двух формах. Первая использует полноценный символ “ñ” (U\+00F1). Второй использует латинскую букву “n”, за которой следует дополняющий символ “~” (U\+0303).

Такие множественные представления становятся проблемой для программ, которые занимаются сравнением строк. Чтобы это исправить, вы должны сначала нормализовать текст, то есть привести его к стандартному представлению с помощью модуля *unicodedata*:
```python
>>> import unicodedata
>>> t1 = unicodedata.normalize('NFC', s1)
>>> t2 = unicodedata.normalize('NFC', s2)
>>> t1 == t2
True
>>> print(ascii(t1))
'Spicy Jalape\xf1o'

>>> t3 = unicodedata.normalize('NFD', s1)
>>> t4 = unicodedata.normalize('NFD', s2)
>>> t3 == t4
True
>>> print(ascii(t3))
'Spicy Jalapen\u0303o'
>>>
```

Первый аргумент, передаваемый в *normalize()*, определяет режим нормализации текста. NFC означает, что символы должны быть полноценными (то есть по возможности использовать только одну кодирующую последовательность). NFD означает, что символы должны быть декомпозированными, то есть разделенными на комбинирующиеся символы. 

Python также поддерживает режимы нормализации NFKC и NFKD, которые добавляют возможности совместимости, которые позволяют работать с определенными типами символов. Например:
```python
>>> s = '\ufb01'  # A single character
>>> s
'ﬁ'
>>> unicodedata.normalize('NFD', s)
'ﬁ'

# Notice how the combined letters are broken apart here
>>> unicodedata.normalize('NFKD', s)
'fi'
>>> unicodedata.normalize('NFKC', s)
'fi'
>>>
``` 

### Обсуждение
Нормализация — это важная часть любой программы, в которой присутствует необходимость обработки текста в Unicode разумным и единообразным способом. Это особенно важно, когда обрабатываемые строки поступают из пользовательского ввода, кодировку которого вы практически никак не контролируете.

Нормализация (приведение) также может быть важной частью чистки и фильтрации текста. Предположим, например, что вы хотите удалить из текста диакритические знаки (возможно, для цели поиска совпадений):
```python
>>> t1 = unicodedata.normalize('NFD', s1)
>>> ''.join(c for c in t1 if not unicodedata.combining(c))
'Spicy Jalapeno'
>>>
```     

Последний пример демонстрирует еще один важный аспект модуля *unicodedata*, а именно полезные функции для проверки принадлежности символов к определенным классам символов. Функция *combining()* проверяет, является ли символ объединяющимся. В этом модуле есть и другие функции для поиска символов определенных категорий, проверки цифр и так далее.

Unicode — весьма обширная тема. Для более подробной информации о нормализации посетите [соответствующую страницу](http://www.unicode.org/faq/normalization.html) на сайте Unicode. Нед Батчелдер также разместил на своем сайте [отличную презентацию](http://nedbatchelder.com/text/unipain.html) о решении проблем, связанных с Unicode в Python.  

## 2.10. Использование символов Unicode в регулярных выражениях
### Задача
Вы используете регулярные выражения для обработки текста, однако беспокоитесь о правильном взаимодействии с символами Unicode.

### Решение
По умолчанию модуль *re* уже имеет некоторые зачаточные представления о некоторых типах символов Unicode. Например, \\d совпадает с любым цифровым символом Unicode:
```python
>>> import re
>>> num = re.compile('\d+')
>>> # ASCII digits
>>> num.match('123')
<_sre.SRE_Match object at 0x1007d9ed0>

>>> # Arabic digits
>>> num.match('\u0661\u0662\u0663')
<_sre.SRE_Match object at 0x101234030>
>>>
```

Если вам нужно включить специфические символы Unicode в шаблоны, вы можете использовать обычные последовательности для экранирования символов Unicode (например, \uFFFF или \UFFFFFFF). Например, вот регексп, который найдет совпадения со всеми символами в нескольких разных арабских страницах:
```python
>>> arabic = re.compile('[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+')
>>>
```

При выполнении поиска совпадений следует нормализовывать и по возможноости чистить текст, приводя его к стандартной форме (см. **рецепт 2.9.**) Также нужно знать о некоторых специальных случаях. Например, рассмотрим поведение нечувствительного к регистру поиска совпадений при объединении с приведением к одному регистру:
```python
>>> pat = re.compile('stra\u00dfe', re.IGNORECASE)
>>> s = 'straße'
>>> pat.match(s)  # Matches
<_sre.SRE_Match object at 0x10069d370>
>>> pat.match(s.upper())  # Doesn't match
>>> s.upper()  # Case folds
'STRASSE'
>>>
```

### Обсуждение
Смешивание Unicode и регулярных выражений — отличный способ взорвать себе голову. Если вы собираетесь серьезно в это погрузиться, установите не включенную в стандартную поставку Python библиотеку [regex](https://pypi.python.org/pypi/regex), в которой есть полная поддержка приведения текстов в Unicode к одному регистру, а также множество других интересных возможностей, включая аппроксимирующий поиск совпадений.

## 2.11. Убирание нежелательных символов из строк
### Задача
Вы хотите убрать ненужные символы, такие как пробелы в начале, конце или середине текстовой строки.

### Решение
Метод *strip()* можно использовать для срезания символов в начале или конце строки. *lstrip()* и *rstrip()* выполняют срезание слева и справа соответственно. По умолчанию они срезают пробел, однако им можно передать и другие символы. Например:
```python
>>> # Whitespace stripping
>>> s = ' hello world  \n'
>>> s.strip()
'hello world'
>>> s.lstrip()
'hello world \n'
>>> s.rstrip()
' hello world'

>>>
>>> # Character stripping
>>> t = '-----hello====='
>>> t.lstrip('-')
'hello====='
>>> t.strip('-=')
'hello'
>>>
``` 

### Обсуждение
Различные методы *strip()* часто используются при чтении и чистке данных для последующей обработки. Например, вы можете использовать их, чтобы избавиться от пробелов, удалить кавычки и т.д.

Обратите внимание, что срезание символов нельзя применить к тексту в середине строки. Например:
```python
>>> s = ' hello world  \n'
>>> s = s.strip()
>>> s
'hello world'
>>>
```

Если вам нужно что-то сделать с внутренним пробелом, вам нужно применить другой приём, такой как использование метода *replace()* или подстановку с использованием регулярного выражения. Например:
```python
>>> s.replace(' ', '')
'helloworld'
>>> import re
>>> re.sub('\s+', ' ', s)
'hello world'
>>>
```

Часто вам нужно сочетать срезание символов с другими видами итерационной обработки, таким как чтением строк данных из файла. Если это так, то стоит применить выражение-генератор:
```python
with open(filename) as f:
	lines = (line.strip() for line in f)
	for line in lines:
		...
```

Здесь выражение *lines = (line.strip() for line in f)* работает как преобразователь данных. Это эффективно, потому что оно не читает данные из какого-либо временного списка. Оно просто создает итератор, где ко всем производимым строкам применена операция срезания символов.

Для более продвинутого срезания вам стоит обратиться к методу *translate()*. Детали вы найдете в следующем рецепте, где описана чистка строк.

## 2.12. Чистка строк
### Решение
Некий деятель ввел текст “pýtĥöñ” в форму на вашей веб-странице, и вы хотите как-то почистить эту строку.

### Решение
Проблема чистки текста применяется к широкому спектру задач с использованием парсинга текста и обработки данных. На самом простом уровне вы можете использовать простые строковые функции (например, *str.upper()* и *str.lower()* для приведения текста к стандартному регистру). Простые замены с использованием *str.replace()* или *re.sub()* помогут справиться с удалением или изменением некоторых специфических последовательностей символов. Вы также можете нормализовать текст, используя функцию *unicodedata.normalize()*, как показано в **рецепте 2.9.**

Однако вы можете пожелать сделать следующий шаг в процессе чистки. Предположим, например, что вы хотите удалить целые диапазоны символов или удалить диакритические знаки. Для этого вы можете обратиться к методу *str.translate()*. Предположим, у вас есть вот такая замусоренная строка:
```python
>>> s = 'pýtĥöñ\fis\tawesome\r\n'
>>> s
'pýtĥöñ\x0cis\tawesome\r\n'
>>>
```

Первый шаг — удалить пробел. Сделаем небольшую таблицу перевода и задействуем *translate()*:
```python
>>> remap = {
...   ord('\t') : ' ',
...   ord('\f') : ' ',
...   ord('\r') : None  # Deleted
... }
>>> a = s.translate(remap)
>>> a
'pýtĥöñ is awesome\n'
>>>
```

Как вы можете увидеть, символы пробелов, такие как \t и \f, были приведены к единой форме. Символ возврата каретки \r был удален. 

Вы можете продолжить идею и создать намного более крупные таблицы перевода. Например, давайте удалим все комбинирующиеся символы:
```python
>>> import unicodedata
>>> import sys
>>> cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode)
...   if unicodedata.combining(chr(c)))
...
>>> b = unicodedata.normalize('NFD', a)
>>> b
'pýtĥöñ is awesome\n'
>>> b.translate(cmb_chrs)
'python is awesome\n'
>>>
``` 

В последнем примере с помощью *dict.fromkeys()* был создан словарь, отображающий все комбинирующиеся символы Unicode на None. 

Первоначальные вводные данные затем были нормализованы в декомпозированную форму с использованием *unicodedata.normalize()*. Далее функция *translate()* используется для удаления значков. Похожие приёмы могут быть использованы для удаления символов другого типа (например, управляющих символов). 

Ещё один пример — таблица перевода, которая отображает все десятичные цифры Unicode на их эквиваленты в ASCII:
```python
>>> digitmap = { c: ord('0') + unicodedata.digit(chr(c))
...   for c in range(sys.maxunicode)
...   if unicodedata.category(chr(c)) == 'Nd' }
...
>>> len(digitmap)
460
>>> # Arabic digits
>>> x = '\u0661\u0662\u0663'
>>> x.translate(digitmap)
'123'
>>>
```

Ещё один приём для чистки текста использует функции кодирования и декодирования ввода-вывода. Идея состоит в выполнении некоторой первичной очистки текста, а затем пропускании его через encode() и decode() для срезания символов или изменения. Например:
```python
>>> a
'pýtĥöñ is awesome\n'
>>> b = unicodedata.normalize('NFD', a)
>>> b.encode('ascii', 'ignore').decode('ascii')
'python is awesome\n'
>>>
```

Здесь процесс нормализации разложил исходный текст на символы вместе с отдельными комбинирующимися символами. Последовательное кодирование и декодирование в ASCII просто удаляет все эти эти символы. Естественно, это сработает только в том случае, если нашей целью было получение ASCII-представления.

### Обсуждение
Большой проблемой с чисткой текста может стать производительность. Общее правило: чем проще обработка, тем быстрее она работает. Для простых замен метод *str.replace()* часто оказывается самым быстрым способом — даже если вызывать его несколько раз. Например, чтобы вычистить пробелы, вы можете использовать такую программу:
```python
def clean_spaces(s):
s = s.replace('\r', '')
s = s.replace('\t', ' ')
s = s.replace('\f', ' ')
return s
``` 

Если вы попробуете это, то обнаружите, что метод немного быстрее использования *translate()* или регулярных выражений.

С другой стороны, метод *translate()* очень быстр, если вам нужно выполнить любую нетривиальную операцию замены символов на другие символы или удаления символов.

Производительность — это нечто, что вам придется изучать в каждом конкретном приложении. К несчастью, невозможно предложить один приём, который будет работать лучше всего во всех возможных ситуациях, поэтому пробуйте разные подходы и измеряйте результы.

Хотя этот рецепт делает акцент на работе с текстом, похожие приёмы могут быть применены к последовательностям байтов.   


## 2.13. Выравнивание текстовых строк
### Задача
Вам нужно отформатировать текст с применением некого выравнивания.

### Решение
Для базового выравнивания строк можно использовать методы *ljust()*, *rjust()* и *center()*. Например:
```python
>>> text = 'Hello World'
>>> text.ljust(20)
'Hello World '
>>> text.rjust(20)
' Hello World'
>>> text.center(20)
' Hello World '
>>>
```

Все эти методы могут принимать опциональный символ заполнения. Например:
```python
>>> text.rjust(20,'=')
'=========Hello World'
>>> text.center(20,'*')
'****Hello World*****'
>>>
``` 

Функция *format()* также может быть использована для выравнивания. Вам нужно просто использовать символы <, > или ^ вместе с желаемой шириной. Например:
```python
>>> format(text, '>20')
' Hello World'
>>> format(text, '<20')
'Hello World '
>>> format(text, '^20')
' Hello World '
>>>
```

Если вы хотите использовать в качестве заполняющего символа не пробел, определите его перед символом выравнивания:
```python
>>> format(text, '=>20s')
'=========Hello World'
>>> format(text, '*^20s')
'****Hello World*****'
>>>
```

Эти коды форматирования могут быть также использованы с методом *format()* при обработке нескольких значений. Например:
```python
>>> '{:>10s} {:>10s}'.format('Hello', 'World')
' Hello World'
>>>
```

У *format()* есть преимущество — он работает не только со строками. Он работает с любыми значениями, что делает его назначение очень широким. Например, вы можете использовать его с числами:
```python
>>> x = 1.2345
>>> format(x, '>10')
' 1.2345'
>>> format(x, '^10.2f')
' 1.23 '
>>>
```

### Обсуждение
В старых программах вы также можете увидеть, как для форматирования текста использовался оператор %. Например:
```python
>>> '%-20s' % text
'Hello World '
>>> '%20s' % text
' Hello World'
>>>
```  

Однако в новых программах вы должны предпочитать функцию или метод *format()*. Онам намного мощнее оператора %. Более того, *format()* может применяться более широко, нежели строковые методы *ljlust()*, *rjust()* или *center()*, поскольку работает с любыми объектами. 

За полным списком возможностей функции *format()* обратитесь к [документации Python](https://docs.python.org/3/library/string.html#formatspec).

## 2.14. Объединение и конкатенация строк
### Задача
Вам нужно объединить много небольших строк в большую строку. 

### Решение
Если строки, которые вы хотите объединить, находятся в последовательности или итерируемом объекте, самый быстрый способ — использовать метод *join()*. Например:
```python
>>> parts = ['Is', 'Chicago', 'Not', 'Chicago?']
>>> ' '.join(parts)
'Is Chicago Not Chicago?'
>>> ','.join(parts)
'Is,Chicago,Not,Chicago?'
>>> ''.join(parts)
'IsChicagoNotChicago?'
>>>
```

На первый взгляд синтаксис может показаться странным, однако операция *join()* относится к строковым методам. Объекты, которые вы хотите объединить, могут приходить из разнообразных последовательностей данных: (списки, кортежи, словари, файлы, множества или генераторы), поэтому было бы избыточным имплементировать метод *join()* для всех этих объектов. Поэтому вы просто задаете нужную строку-разделитель, а затем применяете метод *join()* для склеивания текстовых фрагментов.

Если вы просто объединяете несколько строк, неплохо сработает \+:
```python
>>> a = 'Is Chicago'
>>> b = 'Not Chicago?'
>>> a + ' ' + b
'Is Chicago Not Chicago?'
>>>
```

Оператор \+ также отлично работает в качестве замены более сложным операциям форматирования строк. Например:
```python
>>> print('{} {}'.format(a,b))
Is Chicago Not Chicago?
>>> print(a + ' ' + b)
Is Chicago Not Chicago?
>>>
```

Если вы пытаетесь объединить строковые литералы в исходном коде, вы можете просто разместить их рядом без использования оператора \+. Например:
```python
>>> a = 'Hello' 'World'
>>> a
'HelloWorld'
>>>
```

### Обсуждение
Объединение строк может показаться недостаточно сложным, чтобы писать про него целый рецепт, но часто эта область является критически важной для производительности. 

Важно знать, что использование оператора \+ для объединения большого количества строк крайне неэффективно, посколько в памяти создаются копии, что прибавляет работы сборщику мусора. Никогда не пишите такой код для объединения строк:
```python
s = ''
for p in parts:
	s += p
```

Это работает заметно медленнее метода *join()*, главным образом потому, что каждая \+= операция создает новый строковый объект. Намного лучше собрать все части и только затем объединить.

Еще один классный фокус из этой области — преобразование данных в строки и конкатенация с одновременным использованием выражения-генератора, как описано в **рецепте 1.19.** Например:
```python
>>> data = ['ACME', 50, 91.1]
>>> ','.join(str(d) for d in data)
'ACME,50,91.1'
>>>
```

Берегитесь ненужной конкатенации. Иногда программисты применяют конкатенацию там, где это не нужно. Например:
```python
print(a + ':' + b + ':' + c)  # Ugly
print(':'.join([a, b, c]))  # Still ugly

print(a, b, c, sep=':')  # Better
```

Смешивание операций ввода-вывода и конкатенации строк — момент, с которым нужно быть очень внимательными. Наример, рассмотрим два фрагмента кода:
```python
# Version 1 (string concatenation)
f.write(chunk1 + chunk2)

# Version 2 (separate I/O operations)
f.write(chunk1)
f.write(chunk2)
```

Если две строки невелики, первая может предложить намного большую производительность благодаря дороговизне системного вызова ввода-вывода. Однако если строки велики, вторая версия может быть более эффективной, поскольку в это случае не создается огромный промежуточный результат и не происходит копирования больших блоков памяти. Пробуйте на своих данных и выясняйте, что работает быстрее в вашем конкретном случае.

И последнее: если вы пишите код, который формирует результат из множества небольших строк, подумайте о том, чтобы оформить его как генератор, используя *yield* для производства фрагментов. Например:
```python
def sample():
yield 'Is'
yield 'Chicago'
yield 'Not'
yield 'Chicago?'
```

Интересно, что этот подход не делает предположений по поводу того, как фрагменты будут собираться вместе. Например, вы можете просто объединить фрагменты с помощью *join()*:
```python
text = ''.join(sample())
```

Или же вы можете перенаправить фрагменты на вывод:
```python
for part in sample():
	f.write(part)
```

Или же вы можете создать некую гибридную схему, что умно с точки зрения операций ввода-вывода:
```python
def combine(source, maxsize):
	parts = []
	size = 0
	for part in source:
		parts.append(part)
		size += len(part)
		if size > maxsize:
			yield ''.join(parts)
			parts = []
			size = 0
	yield ''.join(parts)

for part in combine(sample(), 32768):
	f.write(part)
```

Ключевой момент в том, что первоначальный генератор не обязан знать деталей: он просто выдает части.